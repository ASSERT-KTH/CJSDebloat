const args = process.argv.slice(2)
const folderPath = args[0]
const fs = require('fs')
const ACGParseUtils_js_1 = require('./ACGParseUtils')
const childProcess = require('child_process')
const { remove } = require('fs-extra')

const jsonData = fs.readFileSync(`./${folderPath}/dependency-tree.json`)
const unusedFilesData = fs.readFileSync(`./${folderPath}/unused-files.txt`, 'utf-8')
const dataObj = JSON.parse(jsonData)
const unusedFiles = unusedFilesData.split('\n')

fs.writeFileSync(`./${folderPath}/wrapped-dependency-tree.json`, '')

let unusedNodesSet = []
let tempArr = []
let newSet = []
let jsonList = []

// let wrappedTree = {}
function visitDepTree(dataObj) {
    let wrappedTree = {}
    for (let key in dataObj) {
        wrappedTree['path'] = key
        wrappedTree['isFlaged'] = false
        wrappedTree['children'] = []
        const value = dataObj[key]
        if (isFileUnused(key)) {
            wrappedTree['isUnused'] = true
        } else {
            wrappedTree['isUnused'] = false
        }
        
        if (isFileALeaf(value)) {
            // leaf
            wrappedTree['isLeaf'] = true
            wrappedTree['isBranch'] = false
            wrappedTree['children'] = []
        } else {
            wrappedTree['isLeaf'] = false
            wrappedTree['isBranch'] = true
            // has dependencies, recursively traverse
            wrappedTree['children'] = turnValueToChildren(value, key, wrappedTree['isUnused'])
            // visitDepTree(value)
        }
    }
    return wrappedTree
}

function turnValueToChildren(value, parent, isParentUnused) {
    let children = []
    
    for (let key in value) {
        isLeaf = isFileALeaf(value[key])
        isUnused = isFileUnused(key)
        const child = {
            'path': key,
            'parent': parent,
            'isParentUnused': isParentUnused,
            'isLeaf': isLeaf,
            'isBranch': !isLeaf,
            'isUnused': isUnused,
            'isFlaged': false,
            'children': turnValueToChildren(value[key], key, isUnused)
        }
        children.push(child)
        if (key && key.slice(-5).toLocaleLowerCase() === '.json') {
            logJSON(child)
        }
    }
    return children
}

function isFileUnused(filepath) {
    return unusedFiles.indexOf(filepath) > -1 && filepath.indexOf('node_modules') > -1
}

function isFileALeaf(value) {
    return typeof value === 'object' && JSON.stringify(value) == '{}'
}

function isUnusedTree(node) {
    const children = node.children
    let childrenUnused = true

    if (children.length) {
        children.forEach(child => {
          if (!isUnusedTree(child)) childrenUnused = false
        })
        return node.isUnused && childrenUnused
    } else {
        // if a leaf is js node: check unused
        // if a leaf is json node: check in jsonList
        return node.isUnused || jsonList.indexOf(node.path) > -1
    }  
}

function logUnusedTree(node) {
    tempArr.push(node.path)
    const children = node.children
    if (children.length) {
        children.forEach(child => {
            logUnusedTree(child)
        })
    }
    unusedNodesSet.push(tempArr)
}

function logJSON(node) {
    // console.log('json node', node)
    const path = node.path
    const idx = jsonList.indexOf(path)
    // if JSON's parent is unused, push it to jsonList. 
    // Otherwise, remove it from jsonList (if it's already existed in the jsonList)
    if (idx === -1 && node.isParentUnused) {
        jsonList.push(path)
    } else if (idx > -1 && !node.isParentUnused) {
        jsonList.splice(idx, 1)
    }
}


function traverseTree(node) {
    tempArr = []
    // record parents for each json node. 
    // The reason for only recording json is that only json files can not be
    // recognized by unused-files list which is generated by stubbifier, since
    // stubbifier only records js files.
    // if (node.path && node.path.slice(-5).toLocaleLowerCase() === '.json') {
    //     node.isUnused = node.parent.isUnused
    //     logJSON(node)
    // }

    // log unused tree
    if (isUnusedTree(node)) {
        logUnusedTree(node)
        return
    } 
    // recursively traverse
    const children = node.children
    children.forEach(child => {
        traverseTree(child)
    })
}

function removeFiles(files) {
    files.forEach(file => {
        childProcess.exec(`rm -rf ${file}`)
    })
}


// Convert dependency-tree to wrapped-tree. For each node in dependency-tree, 
// generate a new node with path, isLeaf, isUnused, isBranch, children
const result = visitDepTree(dataObj)

fs.writeFileSync(`./${folderPath}/wrapped-dependency-tree.json`, JSON.stringify(result))


traverseTree(result)


unusedNodesSet.forEach(node => {
    str = JSON.stringify(node)
    if (newSet.indexOf(str) == -1) {
        newSet.push(str)
    }
})


// jsonList.forEach(json => {
//     console.log(json)
// })
console.log('Candidates on the tree:')
newSet.forEach(set => console.log(JSON.parse(set)))

combSet = newSet.map(set => JSON.parse(set))

const newSetComb = ACGParseUtils_js_1.getCombinations(combSet)
console.log('Combinations of the candidates:')
console.log(newSetComb)

// Randomly select a seed to remove and generate a variant

var variantsLength = newSetComb.length
console.log('variantsLength: ', variantsLength)
var fileRand = ~~(Math.random() * variantsLength)
console.log("file rand: ", fileRand)
var fileVariants = newSetComb[fileRand]
console.log('fileVariants: \n', fileVariants)


// removeFiles(fileVariants)
13
./VariantsPureDep/execa/variant13/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (860ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.7s)
  ✔ error › result.killed is false if not killed, in sync mode (694ms)
  ✔ error › result.killed is false on process error, in sync mode (193ms)
  ✔ error › Original error.message is kept (1.1s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (301ms)
  ✔ error › stdout/stderr/all on process errors (1.8s)
  ✔ error › stdout/stderr/all available on errors (2s)
  ✔ error › exitCode is 0 on success (1.8s)
  ✔ error › exitCode is 2 (1.8s)
  ✔ error › exitCode is 3 (1.7s)
  ✔ error › exitCode is 4 (1.6s)
  ✔ error › error.message contains the command (1.5s)
  ✔ error › error.message contains stdout/stderr if available (1.5s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.4s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.3s)
  ✔ error › failed is false on success (1.2s)
  ✔ error › failed is true on failure (1.1s)
  ✔ error › error.killed is true if process was killed directly (1s)
  ✔ error › error.killed is false if process was killed indirectly (1s)
  ✔ error › result.killed is false if not killed (989ms)
  ✔ error › error.signal is SIGINT (362ms)
  ✔ error › error.signalDescription is defined (336ms)
  ✔ error › error.signal is SIGTERM (340ms)
  ✔ error › exitCode is undefined on signal termination (302ms)
  ✔ error › custom error.signal (337ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (288ms)
  ✔ error › result.signalDescription is undefined for successful execution (274ms)
  ✔ error › result.signal is undefined for successful execution (377ms)
  ✔ error › error.code is undefined on success (345ms)
  ✔ command › allow commands with spaces and no array arguments (2.3s)
  ✔ command › allow commands with spaces and array arguments (2.3s)
  ✔ command › execaCommand() (2.2s)
  ✔ command › execaCommand() ignores consecutive spaces (2.1s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.1s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2s)
  ✔ command › execaCommand() escapes other whitespaces (2s)
  ✔ command › execaCommand() trims (1.9s)
  ✔ command › command is: " foo bar" (2.5s)
  ✔ command › command is: " baz quz" (2.5s)
  ✔ command › command is: "" (2.5s)
  ✔ command › escapedCommand is: "foo bar" (2.6s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.7s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (2.8s)
  ✔ command › escapedCommand is: "\"*\"" (2.8s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (2.9s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.9s)
  ✔ kill › execa() returns a promise with kill() (2.9s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.7s)
  ✔ kill › cancel method kills the subprocess (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (1.8s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (789ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (2.9s)
  ✔ kill › timeout must not be negative (2.8s)
  ✔ kill › timeout must be an integer (2.8s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (121ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (166ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (199ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.1s)
  ✔ kill › timeout does not kill the process if it does not time out (3s)
  ✔ kill › timedOut is false if timeout is undefined (2.9s)
  ✔ kill › timedOut is false if timeout is 0 (2.9s)
  ✔ kill › spawnAndExit (2.6s)
  ✔ kill › spawnAndExit cleanup (2.6s)
  ✔ kill › spawnAndExit detached (2.6s)
  ✔ kill › spawnAndExit cleanup detached (2.6s)
  ✔ kill › spawnAndKill SIGTERM (2.5s)
  ✔ kill › spawnAndKill SIGKILL (2.5s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.5s)
  ✔ kill › spawnAndKill detached SIGTERM (2.5s)
  ✔ kill › spawnAndKill detached SIGKILL (2.4s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.4s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.3s)
  ✔ kill › removes exit handler on exit (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.1s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (414ms)
  ✔ kill › error.isCanceled is true when cancel method is used (400ms)
  ✔ kill › error.isCanceled is false when kill method is used (391ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (376ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (367ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (354ms)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.5s)
  ✔ kill › timeout kills the process if it times out (3.1s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.3s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (308ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.2s)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (115ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (162ms)
  ✔ node › node pass on nodeOptions (166ms)
  ✔ node › node's forked script has a communication channel (167ms)
  ✔ node › node pipe stdout (208ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › throw in finally function bubbles up on success (196ms)
  ✔ promise › finally function is executed on success (232ms)
  ✔ promise › finally function is executed on failure (242ms)
  ✔ promise › throw in finally bubbles up on error (210ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.1s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1s)
  ✔ stream › input option can be a String - sync (667ms)
  ✔ stream › input option can be a Buffer - sync (442ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (354ms)
  ✔ stream › buffer (1.1s)
  ✔ stream › pass `stdout` to a file descriptor (1.1s)
  ✔ stream › pass `stderr` to a file descriptor (1.1s)
  ✔ stream › result.all is undefined unless opts.all is true (1.1s)
  ✔ stream › stdout/stderr/all are undefined if ignored (1.1s)
  ✔ stream › input option can be a String (934ms)
  ✔ stream › you can write to child.stdin (859ms)
  ✔ stream › input option can be a Buffer (947ms)
  ✔ stream › input can be a Stream (912ms)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (563ms)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (680ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (686ms)
  ✔ stream › do not buffer when streaming (693ms)
  ✔ stream › buffer: false > promise resolves (744ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (798ms)
  ✔ stream › buffer: false > promise resolves when output is big and is read (825ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (763ms)
  ✔ stream › maxBuffer affects stderr (1s)
  ✔ stream › can use all: true with stdout: ignore (800ms)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (912ms)
  ✔ stream › maxBuffer affects stdout (1.1s)
  ✔ stream › can use all: true with stderr: ignore (872ms)
  ✔ test › execaSync() (1.7s)
  ✔ test › execaSync() throws error if written to stderr (1.1s)
  ✔ test › skip throwing when using reject option in sync mode (1.1s)
  ✔ test › stripFinalNewline in sync mode (976ms)
  ✔ test › stripFinalNewline in sync mode on failure (802ms)
  ✔ test › execa() returns a promise with pid (702ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (689ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (642ms)
  ✔ test › child_process.spawn() errors are propagated (701ms)
  ✔ test › write to fast-exit process (625ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (675ms)
  ✔ test › execa() rejects if running non-executable (697ms)
  ✔ test › preferLocal: undefined (842ms)
  ✔ test › preferLocal: false (850ms)
  ✔ test › child process errors rejects promise right away (824ms)
  ✔ test › child process errors are handled (840ms)
  ✔ test › stdin errors are handled (849ms)
  ✔ test › execa() (2s)
  ✔ test › skip throwing when using reject option (1.3s)
  ✔ test › stripFinalNewline: true (1.2s)
  ✔ test › stripFinalNewline: false (1.1s)
  ✔ test › stripFinalNewline on failure (1.1s)
  ✔ test › localDir option (923ms)
  ✔ test › do not try to consume streams twice (825ms)
  ✔ test › use relative path with '..' chars (809ms)
  ✔ test › extend environment variables by default (569ms)
  ✔ test › can use `options.cwd` as a string (473ms)
  ✔ test › localDir option can be a URL (426ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (306ms)
  ✔ test › do not extend environment with `extendEnv: false` (503ms)
  ✔ test › use environment variables by default (652ms)
  ✔ test › can use `options.cwd` as a URL (481ms)
  ✔ test › can use `options.shell: string` (438ms)
  ✔ test › can use `options.shell: true` (525ms)
  ✔ test › execPath option (1.1s)
  ✔ test › detach child process (538ms)
  ✔ test › preferLocal: true (1.5s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsPureDep/execa/variant12/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (605ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.7s)
  ✔ error › result.killed is false if not killed, in sync mode (849ms)
  ✔ error › result.killed is false on process error, in sync mode (207ms)
  ✔ error › Original error.message is kept (1.3s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (296ms)
  ✔ error › stdout/stderr/all on process errors (1.8s)
  ✔ error › stdout/stderr/all available on errors (1.9s)
  ✔ error › exitCode is 0 on success (1.8s)
  ✔ error › exitCode is 2 (1.7s)
  ✔ error › exitCode is 3 (1.7s)
  ✔ error › exitCode is 4 (1.7s)
  ✔ error › error.message contains the command (1.7s)
  ✔ error › error.message contains stdout/stderr if available (1.6s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.6s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.5s)
  ✔ error › failed is false on success (1.4s)
  ✔ error › failed is true on failure (1.3s)
  ✔ error › error.killed is true if process was killed directly (1.3s)
  ✔ error › error.killed is false if process was killed indirectly (1.2s)
  ✔ error › result.killed is false if not killed (1.1s)
  ✔ error › error.signal is SIGINT (370ms)
  ✔ error › error.signalDescription is defined (364ms)
  ✔ error › error.signal is SIGTERM (341ms)
  ✔ error › exitCode is undefined on signal termination (306ms)
  ✔ error › custom error.signal (328ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (369ms)
  ✔ error › result.signalDescription is undefined for successful execution (384ms)
  ✔ error › result.signal is undefined for successful execution (419ms)
  ✔ error › error.code is undefined on success (383ms)
  ✔ command › allow commands with spaces and no array arguments (2.2s)
  ✔ command › allow commands with spaces and array arguments (2.1s)
  ✔ command › execaCommand() (2.1s)
  ✔ command › execaCommand() ignores consecutive spaces (2s)
  ✔ command › execaCommand() allows escaping spaces in commands (1.9s)
  ✔ command › execaCommand() allows escaping spaces in arguments (1.8s)
  ✔ command › execaCommand() escapes other whitespaces (1.7s)
  ✔ command › execaCommand() trims (1.6s)
  ✔ command › command is: " foo bar" (2.5s)
  ✔ command › command is: " baz quz" (2.4s)
  ✔ command › command is: "" (2.4s)
  ✔ command › escapedCommand is: "foo bar" (2.5s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.6s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (2.7s)
  ✔ command › escapedCommand is: "\"*\"" (2.8s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (2.9s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.9s)
  ✔ kill › execa() returns a promise with kill() (2.8s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.7s)
  ✔ kill › cancel method kills the subprocess (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (895ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (2.8s)
  ✔ kill › timeout must not be negative (2.8s)
  ✔ kill › timeout must be an integer (2.8s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (114ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (166ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (178ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.1s)
  ✔ kill › timeout does not kill the process if it does not time out (2.9s)
  ✔ kill › timedOut is false if timeout is undefined (2.9s)
  ✔ kill › timedOut is false if timeout is 0 (2.8s)
  ✔ kill › spawnAndExit (2.5s)
  ✔ kill › spawnAndExit cleanup (2.5s)
  ✔ kill › spawnAndExit detached (2.5s)
  ✔ kill › spawnAndExit cleanup detached (2.5s)
  ✔ kill › spawnAndKill SIGTERM (2.4s)
  ✔ kill › spawnAndKill SIGKILL (2.4s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.4s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.3s)
  ✔ kill › removes exit handler on exit (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.2s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (358ms)
  ✔ kill › error.isCanceled is true when cancel method is used (325ms)
  ✔ kill › error.isCanceled is false when kill method is used (301ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (285ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (271ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (264ms)
  ✔ kill › spawnAndKill detached SIGTERM (2.4s)
  ✔ kill › spawnAndKill detached SIGKILL (2.4s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.4s)
  ✔ kill › timeout kills the process if it times out (3s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.2s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (225ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.2s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.4s)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (165ms)
  ✔ node › node pipe stdout (193ms)
  ✔ node › node's forked script has a communication channel (165ms)
  ✔ node › node pass on nodeOptions (178ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on failure (185ms)
  ✔ promise › finally function is executed on success (224ms)
  ✔ promise › throw in finally bubbles up on error (211ms)
  ✔ promise › throw in finally function bubbles up on success (223ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.1s)
  ✔ kill › kill() with no arguments should kill after a timeout (8s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1s)
  ✔ stream › input option can be a String - sync (751ms)
  ✔ stream › input option can be a Buffer - sync (536ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (450ms)
  ✔ stream › buffer (1.2s)
  ✔ stream › pass `stdout` to a file descriptor (1.2s)
  ✔ stream › pass `stderr` to a file descriptor (1.2s)
  ✔ stream › result.all is undefined unless opts.all is true (1.2s)
  ✔ stream › stdout/stderr/all are undefined if ignored (1.2s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (753ms)
  ✔ stream › input option can be a Buffer (1s)
  ✔ stream › you can write to child.stdin (1s)
  ✔ stream › input option can be a String (1s)
  ✔ stream › input can be a Stream (1s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (718ms)
  ✔ stream › do not buffer when streaming (653ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (695ms)
  ✔ stream › buffer: false > promise resolves (769ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (778ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (738ms)
  ✔ stream › maxBuffer affects stdout (1s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (909ms)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (897ms)
  ✔ stream › can use all: true with stderr: ignore (704ms)
  ✔ stream › maxBuffer affects stderr (1s)
  ✔ stream › can use all: true with stdout: ignore (821ms)
  ✔ test › execaSync() (1.7s)
  ✔ test › execaSync() throws error if written to stderr (1.1s)
  ✔ test › skip throwing when using reject option in sync mode (1s)
  ✔ test › stripFinalNewline in sync mode (834ms)
  ✔ test › stripFinalNewline in sync mode on failure (660ms)
  ✔ test › execa() returns a promise with pid (585ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (573ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (536ms)
  ✔ test › child_process.spawn() errors are propagated (590ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (527ms)
  ✔ test › execa() rejects if running non-executable (590ms)
  ✔ test › preferLocal: undefined (731ms)
  ✔ test › preferLocal: false (756ms)
  ✔ test › child process errors rejects promise right away (740ms)
  ✔ test › child process errors are handled (764ms)
  ✔ test › stdin errors are handled (773ms)
  ✔ test › execa() (2.1s)
  ✔ test › skip throwing when using reject option (1.3s)
  ✔ test › stripFinalNewline: true (1.1s)
  ✔ test › stripFinalNewline: false (1.1s)
  ✔ test › stripFinalNewline on failure (1.1s)
  ✔ test › localDir option (873ms)
  ✔ test › do not try to consume streams twice (780ms)
  ✔ test › use relative path with '..' chars (758ms)
  ✔ test › write to fast-exit process (683ms)
  ✔ test › localDir option can be a URL (508ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (369ms)
  ✔ test › use environment variables by default (670ms)
  ✔ test › can use `options.cwd` as a string (576ms)
  ✔ test › extend environment variables by default (623ms)
  ✔ test › do not extend environment with `extendEnv: false` (591ms)
  ✔ test › can use `options.cwd` as a URL (538ms)
  ✔ test › can use `options.shell: true` (540ms)
  ✔ test › can use `options.shell: string` (528ms)
  ✔ test › detach child process (589ms)
  ✔ test › execPath option (1.1s)
  ✔ test › preferLocal: true (1.4s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsPureDep/execa/variant11/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✖ command › execaCommandSync() Error thrown in test
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.6s)
  ✖ error › result.killed is false if not killed, in sync mode Error thrown in test
  ✔ error › result.killed is false on process error, in sync mode (141ms)
  ✔ error › Original error.message is kept (1.3s)
  ✔ error › error.code is defined on failure if applicable
  ✖ error › result.killed is false on process error 
  ✖ error › stdout/stderr/all on process errors 
  ✖ error › stdout/stderr/all available on errors 
  ✖ error › exitCode is 0 on success Rejected promise returned by test
  ✖ error › exitCode is 2 
  ✖ error › exitCode is 3 
  ✖ error › exitCode is 4 
  ✖ error › error.message contains the command 
  ✖ error › error.message contains stdout/stderr if available 
  ✔ error › error.message does not contain stdout/stderr if not available (1.7s)
  ✖ error › error.shortMessage does not contain stdout/stderr Rejected promise returned by test
  ✖ error › failed is false on success Rejected promise returned by test
  ✖ error › failed is true on failure 
  ✖ error › error.killed is true if process was killed directly 
  ✖ error › error.killed is false if process was killed indirectly 
  ✖ error › result.killed is false if not killed Rejected promise returned by test
  ✖ error › error.signal is SIGINT 
  ✖ error › error.signalDescription is defined 
  ✖ error › error.signal is SIGTERM 
  ✔ error › exitCode is undefined on signal termination (479ms)
  ✖ error › result.signal is undefined for successful execution Rejected promise returned by test
  ✖ error › custom error.signal 
  ✖ error › error.code is undefined on success Rejected promise returned by test
  ✖ error › result.signal is undefined if process failed, but was not killed 
  ✖ error › result.signalDescription is undefined for successful execution Rejected promise returned by test
  ✖ command › allow commands with spaces and no array arguments Rejected promise returned by test
  ✖ command › allow commands with spaces and array arguments Rejected promise returned by test
  ✖ command › execaCommand() Rejected promise returned by test
  ✖ command › execaCommand() ignores consecutive spaces Rejected promise returned by test
  ✖ command › execaCommand() allows escaping spaces in commands Rejected promise returned by test
  ✖ command › execaCommand() allows escaping spaces in arguments Rejected promise returned by test
  ✖ command › execaCommand() escapes other whitespaces Rejected promise returned by test
  ✖ command › execaCommand() trims Rejected promise returned by test
  ✖ command › command is: " foo bar" 
  ✖ command › command is: " baz quz" 
  ✖ command › command is: "" 
  ✖ command › escapedCommand is: "foo bar" 
  ✖ command › escapedCommand is: "\"foo bar\"" 
  ✖ command › escapedCommand is: "\"\\\"foo\\\"\"" 
  ✖ command › escapedCommand is: "\"*\"" 
  ✔ kill › `forceKillAfterTimeout` should not be NaN (2.9s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.9s)
  ✔ kill › execa() returns a promise with kill() (2.9s)
  ✖ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode Error thrown in test
  ✔ kill › cancel method kills the subprocess (1.9s)
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) Error thrown in test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) 
  ✖ kill › timeout kills the process if it times out, in sync mode 
  ✔ kill › timeout must not be negative (2.8s)
  ✔ kill › timeout must be an integer (2.8s)
  ✖ kill › calling abort after cancel should show the same behaviour as only calling cancel 
  ✖ kill › calling cancel after abort should show the same behaviour as only calling cancel 
  ✖ kill › calling abort twice should show the same behaviour as calling it once 
  ✖ kill › calling abort throws an error with message "Command was canceled" 
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.1s)
  ✖ kill › timeout does not kill the process if it does not time out Rejected promise returned by test
  ✖ kill › timedOut is false if timeout is undefined Rejected promise returned by test
  ✖ kill › timedOut is false if timeout is 0 Rejected promise returned by test
  ✖ kill › spawnAndExit 
  ✖ kill › spawnAndExit cleanup 
  ✖ kill › spawnAndExit detached 
  ✖ kill › spawnAndExit cleanup detached 
  ✔ kill › spawnAndKill SIGTERM (2.4s)
  ✔ kill › spawnAndKill SIGKILL (2.4s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.3s)
  ✔ kill › spawnAndKill detached SIGTERM (2.3s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.2s)
  ✔ kill › removes exit handler on exit (2.1s)
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called (success) Rejected promise returned by test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) 
  ✖ kill › calling cancel method throws an error with message "Command was canceled" 
  ✖ kill › error.isCanceled is true when cancel method is used 
  ✖ kill › error.isCanceled is false when kill method is used 
  ✖ kill › calling cancel method twice should show the same behaviour as calling it once 
  ✖ kill › calling cancel method on a process which has been killed does not make error.isCanceled true 
  ✔ kill › spawnAndKill detached SIGKILL (2.3s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.2s)
  ✖ kill › timeout kills the process if it times out 
  ✖ kill › kill("SIGKILL") should terminate cleanly 
  ✖ kill › calling cancel method on a successfully completed process does not make result.isCanceled true Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout: number` should kill after a timeout 
  ✔ kill › spawnAndKill cleanup SIGTERM (2.4s)
  ✖ kill › calling abort on a successfully completed process does not make result.isCanceled true Rejected promise returned by test
  ✖ node › node removes --inspect from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect=9222 from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect-brk from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node should not remove --inspect when passed through nodeOptions Rejected promise returned by test
  ✖ node › node correctly use nodePath Rejected promise returned by test
  ✖ node › node() Rejected promise returned by test
  ✔ node › node's forked script has a communication channel (156ms)
  ✖ node › node pipe stdout Rejected promise returned by test
  ✖ node › node pass on nodeOptions Rejected promise returned by test
  ✖ override-promise › should work with third-party Promise Rejected promise returned by test
  ✔ promise › promise methods are not enumerable
  ✖ promise › finally function is executed on success Rejected promise returned by test
  ✔ promise › throw in finally function bubbles up on success (235ms)
  ✖ promise › finally function is executed on failure 
  ✔ promise › throw in finally bubbles up on error (244ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✖ stream › result.all shows both `stdout` and `stderr` intermixed Rejected promise returned by test
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✖ kill › `forceKillAfterTimeout: true` should kill after a timeout 
  ✖ kill › kill() with no arguments should kill after a timeout 
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.1s)
  ✖ stream › input option can be a String - sync Error thrown in test
  ✖ stream › input option can be a Buffer - sync Error thrown in test
  ✔ stream › helpful error trying to provide an input stream in sync mode (458ms)
  ✖ stream › buffer Rejected promise returned by test
  ✖ stream › pass `stdout` to a file descriptor Rejected promise returned by test
  ✖ stream › pass `stderr` to a file descriptor Rejected promise returned by test
  ✖ stream › result.all is undefined unless opts.all is true Rejected promise returned by test
  ✔ stream › stdout/stderr/all are undefined if ignored (1.2s)
  ✔ stream › do not buffer when streaming (662ms)
  ✖ stream › input option can be a String Rejected promise returned by test
  ✖ stream › input option can be a Buffer Rejected promise returned by test
  ✖ stream › input can be a Stream Rejected promise returned by test
  ✖ stream › you can write to child.stdin Rejected promise returned by test
  ✖ stream › opts.stdout:ignore - stdout will not collect data Rejected promise returned by test
  ✔ stream › do not buffer stdout when `buffer` set to `false` (829ms)
  ✔ stream › buffer: false > promise resolves (769ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (812ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (638ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (796ms)
  ✔ stream › can use all: true with stdout: ignore (703ms)
  ✔ stream › can use all: true with stderr: ignore (679ms)
  ✔ stream › buffer: false > promise resolves when output is big and is read (910ms)
  ✖ stream › maxBuffer affects stderr 
  ✖ stream › maxBuffer affects stdout 
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (984ms)
  ✖ test › execaSync() Error thrown in test
  ✔ test › execaSync() throws error if written to stderr (1.7s)
  ✖ test › skip throwing when using reject option in sync mode Error thrown in test
  ✖ test › stripFinalNewline in sync mode Error thrown in test
  ✖ test › stripFinalNewline in sync mode on failure 
  ✔ test › execa() returns a promise with pid (534ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (516ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (494ms)
  ✔ test › child_process.spawn() errors are propagated (577ms)
  ✖ test › execa() rejects with correct error and doesn't throw if running non-executable with input 
  ✔ test › execa() rejects if running non-executable (596ms)
  ✖ test › preferLocal: undefined 
  ✖ test › preferLocal: false 
  ✖ test › child process errors rejects promise right away 
  ✖ test › child process errors are handled 
  ✖ test › stdin errors are handled 
  ✖ test › execa() Rejected promise returned by test
  ✖ test › skip throwing when using reject option Rejected promise returned by test
  ✖ test › stripFinalNewline: true Rejected promise returned by test
  ✔ test › stripFinalNewline: false (1.2s)
  ✖ test › stripFinalNewline on failure 
  ✖ test › localDir option Rejected promise returned by test
  ✖ test › do not try to consume streams twice Rejected promise returned by test
  ✖ test › use relative path with '..' chars Rejected promise returned by test
  ✖ test › write to fast-exit process 
  ✖ test › localDir option can be a URL Rejected promise returned by test
  ✖ test › use extend environment with `extendEnv: true` and `shell: true` Rejected promise returned by test
  ✖ test › can use `options.cwd` as a string Rejected promise returned by test
  ✖ test › extend environment variables by default Rejected promise returned by test
  ✖ test › use environment variables by default Rejected promise returned by test
  ✖ test › can use `options.cwd` as a URL Rejected promise returned by test
  ✖ test › do not extend environment with `extendEnv: false` Rejected promise returned by test
  ✖ test › can use `options.shell: true` Rejected promise returned by test
  ✖ test › can use `options.shell: string` Rejected promise returned by test
  ✖ test › detach child process Rejected promise returned by test
  ✖ test › execPath option Rejected promise returned by test
  ✖ test › preferLocal: true 
  ─

  command › execaCommandSync()

  test/command.js:85

   84: test('execaCommandSync()', t => {                                        
   85:   const {stdout} = execaCommandSync('node test/fixtures/echo.js foo bar'…
   86:   t.is(stdout, 'foo\nbar');                                              

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › execaCommandSync (file://index.js:234:9)
  › file://test/command.js:85:19



  error › result.killed is false if not killed, in sync mode

  test/error.js:120

   119: test('result.killed is false if not killed, in sync mode', t => {
   120:   const {killed} = execaSync('noop.js');                         
   121:   t.false(killed);                                               

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/error.js:120:19



  error › result.killed is false on process error

  test/error.js:126

   125:   const {killed} = await t.throwsAsync(execa('wrong command'));
   126:   t.false(killed);                                             
   127: });                                                            

  Value is not `false`:

  undefined

  › file://test/error.js:126:9



  error › stdout/stderr/all on process errors

  test/error.js:29

   28:   const {stdout, stderr, all} = await t.throwsAsync(execa('wrong command…
   29:   t.is(stdout, '');                                                      
   30:   t.is(stderr, WRONG_COMMAND);                                           

  Difference:

  - undefined
  + ''

  › file://test/error.js:29:4



  error › stdout/stderr/all available on errors

  test/error.js:17

   16: test('stdout/stderr/all available on errors', async t => {               
   17:   const {stdout, stderr, all} = await t.throwsAsync(execa('exit.js', ['2…
   18:   t.is(typeof stdout, 'string');                                         

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 2/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › exitCode is 0 on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:44:21



  error › exitCode is 2

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 2/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › exitCode is 3

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 3/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › exitCode is 4

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 4/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.message contains the command

  test/error.js:58

   57: test('error.message contains the command', async t => {                  
   58:   await t.throwsAsync(execa('exit.js', ['2', 'foo', 'bar']), {message: /…
   59: });                                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /exit.js 2 foo bar/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.message contains stdout/stderr if available

  test/error.js:63

   62:   const {message} = await t.throwsAsync(execa('echo-fail.js'));
   63:   t.true(message.includes('stderr'));                          
   64:   t.true(message.includes('stdout'));                          

  Value is not `true`:

  false

  › file://test/error.js:63:8



  error › error.shortMessage does not contain stdout/stderr

  test/error.js:75

   74:   const {shortMessage} = await t.throwsAsync(execa('echo-fail.js'));
   75:   t.false(shortMessage.includes('stderr'));                         
   76:   t.false(shortMessage.includes('stdout'));                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'Cannot read properties of undefined (reading \'includes\')',
  }

  › file://test/error.js:75:23



  error › failed is false on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:85:19



  error › failed is true on failure

  test/error.js:91

   90:   const {failed} = await t.throwsAsync(execa('exit.js', ['2']));
   91:   t.true(failed);                                               
   92: });                                                             

  Value is not `true`:

  undefined

  › file://test/error.js:91:8



  error › error.killed is true if process was killed directly

  test/error.js:99

   98:                                                                          
   99:   const {killed} = await t.throwsAsync(subprocess, {message: /was killed…
   100:   t.true(killed);                                                        

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGTERM/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.killed is false if process was killed indirectly

  test/error.js:110

   109:   const message = process.platform === 'win32' ? /failed with exit code…
   110:   const {killed} = await t.throwsAsync(subprocess, {message});          
   111:   t.false(killed);                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGINT/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › result.killed is false if not killed

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:115:19



  error › error.signal is SIGINT

  test/error.js:154

   153:                                                                         
   154:     const {signal} = await t.throwsAsync(subprocess, {message: /was kil…
   155:     t.is(signal, 'SIGINT');                                             

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGINT/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.signalDescription is defined

  test/error.js:163

   162:                                                                         
   163:     const {signalDescription} = await t.throwsAsync(subprocess, {messag…
   164:     t.is(signalDescription, 'User interruption with CTRL-C');           

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /User interruption with CTRL-C/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.signal is SIGTERM

  test/error.js:172

   171:                                                                         
   172:     const {signal} = await t.throwsAsync(subprocess, {message: /was kil…
   173:     t.is(signal, 'SIGTERM');                                            

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGTERM/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › result.signal is undefined for successful execution

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:192:19



  error › custom error.signal

  test/error.js:178

   177:     const {signal} = await t.throwsAsync(execa('noop.js', {killSignal: …
   178:     t.is(signal, 'SIGHUP');                                             
   179:   });                                                                   

  Difference:

  - undefined
  + 'SIGHUP'

  › file://test/error.js:178:5



  error › error.code is undefined on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:207:17



  error › result.signal is undefined if process failed, but was not killed

  test/error.js:197

   196: test('result.signal is undefined if process failed, but was not killed'…
   197:   const {signal} = await t.throwsAsync(execa('exit.js', [2]), {message:…
   198:   t.is(signal, undefined);                                              

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 2/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › result.signalDescription is undefined for successful execution

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:202:30



  command › allow commands with spaces and no array arguments

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:45:19



  command › allow commands with spaces and array arguments

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:50:19



  command › execaCommand()

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:55:19



  command › execaCommand() ignores consecutive spaces

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:60:19



  command › execaCommand() allows escaping spaces in commands

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:65:19



  command › execaCommand() allows escaping spaces in arguments

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:70:19



  command › execaCommand() escapes other whitespaces

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:75:19



  command › execaCommand() trims

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:80:19



  command › command is: " foo bar"

  test/command.js:9

   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                
   10:                                                                           

  Difference:

  - undefined
  + 'fail.js foo bar'

  › command (file://test/command.js:9:4)



  command › command is: " baz quz"

  test/command.js:9

   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                
   10:                                                                           

  Difference:

  - undefined
  + 'fail.js baz quz'

  › command (file://test/command.js:9:4)



  command › command is: ""

  test/command.js:9

   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                
   10:                                                                           

  Difference:

  - undefined
  + 'fail.js'

  › command (file://test/command.js:9:4)



  command › escapedCommand is: "foo bar"

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js foo bar'

  › testEscapedCommand (file://test/command.js:23:4)



  command › escapedCommand is: "\"foo bar\""

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js "foo bar"'

  › testEscapedCommand (file://test/command.js:23:4)



  command › escapedCommand is: "\"\\\"foo\\\"\""

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js "\\"foo\\""'

  › testEscapedCommand (file://test/command.js:23:4)



  command › escapedCommand is: "\"*\""

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js "*"'

  › testEscapedCommand (file://test/command.js:23:4)



  kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode

  test/kill.js:127

   126: test('timedOut is false if timeout is undefined and exit code is 0 in s…
   127:   const {timedOut} = execaSync('noop.js');                              
   128:   t.false(timedOut);                                                    

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/kill.js:127:21



  kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success)

  test/kill.js:211

   210: test('result.isCanceled is false when spawned.cancel() isn\'t called in…
   211:   const {isCanceled} = execaSync('noop.js');                            
   212:   t.false(isCanceled);                                                  

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/kill.js:211:23



  kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure)

  test/kill.js:219

   218:   });                 
   219:   t.false(isCanceled);
   220: });                   

  Value is not `false`:

  undefined

  › file://test/kill.js:219:9



  kill › timeout kills the process if it times out, in sync mode

  test/kill.js:93

   92:   });              
   93:   t.false(killed); 
   94:   t.true(timedOut);

  Value is not `false`:

  undefined

  › file://test/kill.js:93:9



  kill › calling abort after cancel should show the same behaviour as only calling cancel

  test/kill.js:307

   306:     const {isCanceled} = await t.throwsAsync(subprocess);
   307:     t.true(isCanceled);                                  
   308:     t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:307:9



  kill › calling cancel after abort should show the same behaviour as only calling cancel

  test/kill.js:297

   296:     const {isCanceled} = await t.throwsAsync(subprocess);
   297:     t.true(isCanceled);                                  
   298:     t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:297:9



  kill › calling abort twice should show the same behaviour as calling it once

  test/kill.js:279

   278:     const {isCanceled} = await t.throwsAsync(subprocess);
   279:     t.true(isCanceled);                                  
   280:     t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:279:9



  kill › calling abort throws an error with message "Command was canceled"

  test/kill.js:270

   269:     abortController.abort();                                           
   270:     await t.throwsAsync(subprocess, {message: /Command was canceled/});
   271:   });                                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /Command was canceled/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  kill › timeout does not kill the process if it does not time out

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:98:21



  kill › timedOut is false if timeout is undefined

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:117:21



  kill › timedOut is false if timeout is 0

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:122:21



  kill › spawnAndExit

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › spawnAndExit cleanup

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › spawnAndExit detached

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › spawnAndExit cleanup detached

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › result.isCanceled is false when spawned.cancel() isn't called (success)

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:201:23



  kill › result.isCanceled is false when spawned.cancel() isn't called (failure)

  test/kill.js:207

   206:   const {isCanceled} = await t.throwsAsync(execa('fail.js'));
   207:   t.false(isCanceled);                                       
   208: });                                                          

  Value is not `false`:

  undefined

  › file://test/kill.js:207:9



  kill › calling cancel method throws an error with message "Command was canceled"

  test/kill.js:225

   224:   subprocess.cancel();                                               
   225:   await t.throwsAsync(subprocess, {message: /Command was canceled/});
   226: });                                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /Command was canceled/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  kill › error.isCanceled is true when cancel method is used

  test/kill.js:232

   231:   const {isCanceled} = await t.throwsAsync(subprocess);
   232:   t.true(isCanceled);                                  
   233: });                                                    

  Value is not `true`:

  undefined

  › file://test/kill.js:232:8



  kill › error.isCanceled is false when kill method is used

  test/kill.js:239

   238:   const {isCanceled} = await t.throwsAsync(subprocess);
   239:   t.false(isCanceled);                                 
   240: });                                                    

  Value is not `false`:

  undefined

  › file://test/kill.js:239:9



  kill › calling cancel method twice should show the same behaviour as calling it once

  test/kill.js:247

   246:   const {isCanceled} = await t.throwsAsync(subprocess);
   247:   t.true(isCanceled);                                  
   248:   t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:247:8



  kill › calling cancel method on a process which has been killed does not make error.isCanceled true

  test/kill.js:262

   261:   const {isCanceled} = await t.throwsAsync(subprocess);
   262:   t.false(isCanceled);                                 
   263: });                                                    

  Value is not `false`:

  undefined

  › file://test/kill.js:262:9



  kill › timeout kills the process if it times out

  test/kill.js:84

   83: test('timeout kills the process if it times out', async t => {           
   84:   const {killed, timedOut} = await t.throwsAsync(execa('noop.js', {timeo…
   85:   t.false(killed);                                                       

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /timed out after/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  kill › kill("SIGKILL") should terminate cleanly

  test/kill.js:19

   18:   const {signal} = await t.throwsAsync(subprocess);
   19:   t.is(signal, 'SIGKILL');                         
   20: });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:19:4



  kill › calling cancel method on a successfully completed process does not make result.isCanceled true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:253:23



  kill › `forceKillAfterTimeout: number` should kill after a timeout

  test/kill.js:42

   41:     const {signal} = await t.throwsAsync(subprocess);
   42:     t.is(signal, 'SIGKILL');                         
   43:   });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:42:5



  kill › calling abort on a successfully completed process does not make result.isCanceled true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:286:24



  node › node removes --inspect from nodeOptions when defined by parent process

  test/node.js:17

   16:                                               
   17:     const {stdout, stderr} = await subprocess;
   18:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async inspectMacro (file://test/node.js:17:28)



  node › node removes --inspect=9222 from nodeOptions when defined by parent process

  test/node.js:17

   16:                                               
   17:     const {stdout, stderr} = await subprocess;
   18:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async inspectMacro (file://test/node.js:17:28)



  node › node removes --inspect-brk from nodeOptions when defined by parent process

  test/node.js:17

   16:                                               
   17:     const {stdout, stderr} = await subprocess;
   18:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async inspectMacro (file://test/node.js:17:28)



  node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process

  test/node.js:17

   16:                                               
   17:     const {stdout, stderr} = await subprocess;
   18:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async inspectMacro (file://test/node.js:17:28)



  node › node should not remove --inspect when passed through nodeOptions

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:85:28



  node › node correctly use nodePath

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:40:19



  node › node()

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:27:21



  node › node pipe stdout

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:32:19



  node › node pass on nodeOptions

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:50:19



  override-promise › should work with third-party Promise

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/override-promise.js:12:19



  promise › finally function is executed on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/promise.js:16:19



  promise › finally function is executed on failure

  test/promise.js:29

   28:   t.is(isError, true);          
   29:   t.is(typeof stdout, 'string');
   30:   t.is(typeof stderr, 'string');

  Difference:

  - 'undefined'
  + 'string'

  › file://test/promise.js:29:4



  stream › result.all shows both `stdout` and `stderr` intermixed

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:32:16



  kill › `forceKillAfterTimeout: true` should kill after a timeout

  test/kill.js:52

   51:     const {signal} = await t.throwsAsync(subprocess);
   52:     t.is(signal, 'SIGKILL');                         
   53:   });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:52:5



  kill › kill() with no arguments should kill after a timeout

  test/kill.js:62

   61:     const {signal} = await t.throwsAsync(subprocess);
   62:     t.is(signal, 'SIGKILL');                         
   63:   });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:62:5



  stream › input option can be a String - sync

  test/stream.js:81

   80: test('input option can be a String - sync', t => {          
   81:   const {stdout} = execaSync('stdin.js', {input: 'foobar'});
   82:   t.is(stdout, 'foobar');                                   

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/stream.js:81:19



  stream › input option can be a Buffer - sync

  test/stream.js:86

   85: test('input option can be a Buffer - sync', t => {                       
   86:   const {stdout} = execaSync('stdin.js', {input: Buffer.from('testing12'…
   87:   t.is(stdout, 'testing12');                                             

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/stream.js:86:19



  stream › buffer

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:14:19



  stream › pass `stdout` to a file descriptor

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:115:18)
  › async file://test/stream.js:21:2



  stream › pass `stderr` to a file descriptor

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:27:2



  stream › result.all is undefined unless opts.all is true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:37:16



  stream › input option can be a String

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:56:19



  stream › input option can be a Buffer

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:61:19



  stream › input can be a Stream

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:69:19



  stream › you can write to child.stdin

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:76:19



  stream › opts.stdout:ignore - stdout will not collect data

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:115:18)
  › async file://test/stream.js:91:19



  stream › maxBuffer affects stderr

  test/stream.js:115

   114: test('maxBuffer affects stderr', async t => {                           
   115:   await t.notThrowsAsync(execa('max-buffer.js', ['stderr', '10'], {maxB…
   116:   const {stderr, all} = await t.throwsAsync(execa('max-buffer.js', ['st…

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/stream.js:115:10



  stream › maxBuffer affects stdout

  test/stream.js:108

   107: test('maxBuffer affects stdout', async t => {                           
   108:   await t.notThrowsAsync(execa('max-buffer.js', ['stdout', '10'], {maxB…
   109:   const {stdout, all} = await t.throwsAsync(execa('max-buffer.js', ['st…

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/stream.js:108:10



  test › execaSync()

  test/test.js:33

   32: test('execaSync()', t => {                       
   33:   const {stdout} = execaSync('noop.js', ['foo']);
   34:   t.is(stdout, 'foo');                           

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/test.js:33:19



  test › skip throwing when using reject option in sync mode

  test/test.js:49

   48: test('skip throwing when using reject option in sync mode', t => {
   49:   const {exitCode} = execaSync('fail.js', {reject: false});       
   50:   t.is(exitCode, 2);                                              

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/test.js:49:21



  test › stripFinalNewline in sync mode

  test/test.js:69

   68: test('stripFinalNewline in sync mode', t => {                            
   69:   const {stdout} = execaSync('noop.js', ['foo'], {stripFinalNewline: tru…
   70:   t.is(stdout, 'foo');                                                   

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/test.js:69:19



  test › stripFinalNewline in sync mode on failure

  test/test.js:77

   76:   });                 
   77:   t.is(stderr, 'foo');
   78: });                   

  Difference:

  - undefined
  + 'foo'

  › file://test/test.js:77:4



  test › execa() rejects with correct error and doesn't throw if running non-executable with input

  test/test.js:177

   176:   test('execa() rejects with correct error and doesn\'t throw if runnin…
   177:     await t.throwsAsync(execa('non-executable.js', {input: 'Hey!'}), {m…
   178:   });                                                                   

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /EACCES/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › preferLocal: undefined

  test/test.js:96

   95: test('preferLocal: undefined', async t => {                              
   96:   await t.throwsAsync(execa('ava', ['--version'], {env: getPathWithoutLo…
   97: });                                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /spawn.* ENOENT/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › preferLocal: false

  test/test.js:92

   91: test('preferLocal: false', async t => {                                  
   92:   await t.throwsAsync(execa('ava', ['--version'], {preferLocal: false, e…
   93: });                                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /spawn.* ENOENT/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › child process errors rejects promise right away

  test/test.js:127

   126:   subprocess.emit('error', new Error('test'));       
   127:   await t.throwsAsync(subprocess, {message: /test/});
   128: });                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /test/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › child process errors are handled

  test/test.js:121

   120:   subprocess.emit('error', new Error('test'));       
   121:   await t.throwsAsync(subprocess, {message: /test/});
   122: });                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /test/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › stdin errors are handled

  test/test.js:115

   114:   subprocess.stdin.emit('error', new Error('test')); 
   115:   await t.throwsAsync(subprocess, {message: /test/});
   116: });                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /test/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › execa()

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:16:19



  test › skip throwing when using reject option

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:44:21



  test › stripFinalNewline: true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:54:19



  test › stripFinalNewline on failure

  test/test.js:65

   64:   const {stderr} = await t.throwsAsync(execa('noop-throw.js', ['foo'], {…
   65:   t.is(stderr, 'foo');                                                   
   66: });                                                                      

  Difference:

  - undefined
  + 'foo'

  › file://test/test.js:65:4



  test › localDir option

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:101:19



  test › do not try to consume streams twice

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:158:19



  test › use relative path with '..' chars

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:166:19



  test › write to fast-exit process

  test/test.js:189

   188:     } catch (error) {           
   189:       t.is(error.code, 'EPIPE');
   190:     }                           

  Difference:

  - undefined
  + 'EPIPE'

  › file://test/test.js:189:6



  test › localDir option can be a URL

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:217:19



  test › use extend environment with `extendEnv: true` and `shell: true`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:243:19



  test › can use `options.cwd` as a string

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:211:19



  test › extend environment variables by default

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:200:19



  test › use environment variables by default

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:195:19



  test › can use `options.cwd` as a URL

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:225:19



  test › do not extend environment with `extendEnv: false`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:205:19



  test › can use `options.shell: true`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:230:19



  test › can use `options.shell: string`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:236:19



  test › detach child process

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:249:19



  test › execPath option

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:108:19



  test › preferLocal: true

  test/test.js:88

   87: test('preferLocal: true', async t => {                                   
   88:   await t.notThrowsAsync(execa('ava', ['--version'], {preferLocal: true,…
   89: });                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/test.js:88:10

  ─

  125 tests failed
-------------|---------|----------|---------|---------|-----------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s     
-------------|---------|----------|---------|---------|-----------------------
All files    |   98.04 |    96.13 |     100 |   98.04 |                       
 execa       |   97.37 |    89.58 |     100 |   97.37 |                       
  index.js   |   97.37 |    89.58 |     100 |   97.37 | 55-57,135-136,208-209 
 execa/lib   |   98.49 |    98.11 |     100 |   98.49 |                       
  command.js |     100 |      100 |     100 |     100 |                       
  error.js   |   92.94 |    88.46 |     100 |   92.94 | 9-10,23-24,76-77      
  kill.js    |     100 |      100 |     100 |     100 |                       
  promise.js |     100 |      100 |     100 |     100 |                       
  stdio.js   |     100 |      100 |     100 |     100 |                       
  stream.js  |     100 |      100 |     100 |     100 |                       
-------------|---------|----------|---------|---------|-----------------------
./VariantsPureDep/execa/variant10/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (491ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.6s)
  ✔ error › result.killed is false if not killed, in sync mode (1s)
  ✔ error › result.killed is false on process error, in sync mode (194ms)
  ✔ error › Original error.message is kept (1.4s)
  ✔ error › error.code is defined on failure if applicable (107ms)
  ✔ error › result.killed is false on process error (310ms)
  ✔ error › stdout/stderr/all on process errors (1.7s)
  ✔ error › stdout/stderr/all available on errors (1.8s)
  ✔ error › exitCode is 0 on success (1.8s)
  ✔ error › exitCode is 2 (1.8s)
  ✔ error › exitCode is 3 (1.8s)
  ✔ error › exitCode is 4 (1.7s)
  ✔ error › error.message contains the command (1.7s)
  ✔ error › error.message contains stdout/stderr if available (1.7s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.7s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.6s)
  ✔ error › failed is false on success (1.6s)
  ✔ error › failed is true on failure (1.5s)
  ✔ error › error.killed is true if process was killed directly (1.5s)
  ✔ error › error.killed is false if process was killed indirectly (1.4s)
  ✔ error › result.killed is false if not killed (1.3s)
  ✔ error › error.signal is SIGINT (387ms)
  ✔ error › error.signalDescription is defined (369ms)
  ✔ error › error.signal is SIGTERM (360ms)
  ✔ error › exitCode is undefined on signal termination (347ms)
  ✔ error › custom error.signal (363ms)
  ✔ error › result.signalDescription is undefined for successful execution (406ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (457ms)
  ✔ error › result.signal is undefined for successful execution (464ms)
  ✔ error › error.code is undefined on success (467ms)
  ✔ command › allow commands with spaces and no array arguments (2s)
  ✔ command › allow commands with spaces and array arguments (1.9s)
  ✔ command › execaCommand() (1.9s)
  ✔ command › execaCommand() ignores consecutive spaces (1.8s)
  ✔ command › execaCommand() allows escaping spaces in commands (1.7s)
  ✔ command › execaCommand() allows escaping spaces in arguments (1.6s)
  ✔ command › execaCommand() escapes other whitespaces (1.6s)
  ✔ command › execaCommand() trims (1.5s)
  ✔ command › command is: " foo bar" (2.4s)
  ✔ command › command is: " baz quz" (2.3s)
  ✔ command › command is: "" (2.3s)
  ✔ command › escapedCommand is: "foo bar" (2.4s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.5s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (2.5s)
  ✔ command › escapedCommand is: "\"*\"" (2.6s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.9s)
  ✔ kill › execa() returns a promise with kill() (2.9s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.8s)
  ✔ kill › cancel method kills the subprocess (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (1.8s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (690ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (2.9s)
  ✔ kill › timeout must not be negative (2.8s)
  ✔ kill › timeout must be an integer (2.8s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (115ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (183ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (194ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.1s)
  ✔ kill › timeout does not kill the process if it does not time out (2.9s)
  ✔ kill › timedOut is false if timeout is undefined (2.9s)
  ✔ kill › timedOut is false if timeout is 0 (2.9s)
  ✔ kill › spawnAndExit (2.6s)
  ✔ kill › spawnAndExit cleanup (2.5s)
  ✔ kill › spawnAndExit detached (2.5s)
  ✔ kill › spawnAndExit cleanup detached (2.5s)
  ✔ kill › spawnAndKill SIGTERM (2.5s)
  ✔ kill › spawnAndKill SIGKILL (2.4s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.4s)
  ✔ kill › spawnAndKill detached SIGTERM (2.4s)
  ✔ kill › spawnAndKill detached SIGKILL (2.3s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.3s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.3s)
  ✔ kill › removes exit handler on exit (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.1s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (285ms)
  ✔ kill › error.isCanceled is true when cancel method is used (276ms)
  ✔ kill › error.isCanceled is false when kill method is used (270ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (264ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (257ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (251ms)
  ✔ kill › timeout kills the process if it times out (3s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.2s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.2s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.5s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (226ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (184ms)
  ✔ node › node pass on nodeOptions (179ms)
  ✔ node › node's forked script has a communication channel (160ms)
  ✔ node › node pipe stdout (204ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable (119ms)
  ✔ promise › throw in finally function bubbles up on success (200ms)
  ✔ promise › finally function is executed on success (272ms)
  ✔ promise › throw in finally bubbles up on error (215ms)
  ✔ promise › finally function is executed on failure (277ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.1s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.3s)
  ✔ stream › input option can be a String - sync (1s)
  ✔ stream › input option can be a Buffer - sync (737ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (571ms)
  ✔ stream › buffer (1.5s)
  ✔ stream › pass `stdout` to a file descriptor (1.5s)
  ✔ stream › pass `stderr` to a file descriptor (1.5s)
  ✔ stream › result.all is undefined unless opts.all is true (1.5s)
  ✔ stream › stdout/stderr/all are undefined if ignored (1.5s)
  ✔ stream › do not buffer when streaming (631ms)
  ✔ stream › input option can be a String (1.3s)
  ✔ stream › input option can be a Buffer (1.3s)
  ✔ stream › input can be a Stream (1.3s)
  ✔ stream › you can write to child.stdin (1.3s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (846ms)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (859ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (824ms)
  ✔ stream › buffer: false > promise resolves (751ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (551ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (879ms)
  ✔ stream › maxBuffer affects stdout (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (835ms)
  ✔ stream › can use all: true with stdout: ignore (726ms)
  ✔ stream › maxBuffer affects stderr (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (921ms)
  ✔ stream › can use all: true with stderr: ignore (730ms)
  ✔ test › execaSync() (2.2s)
  ✔ test › execaSync() throws error if written to stderr (2.1s)
  ✔ test › skip throwing when using reject option in sync mode (2s)
  ✔ test › stripFinalNewline in sync mode (1.9s)
  ✔ test › stripFinalNewline in sync mode on failure (1.1s)
  ✔ test › execa() returns a promise with pid (657ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (631ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (572ms)
  ✔ test › child_process.spawn() errors are propagated (641ms)
  ✔ test › write to fast-exit process (509ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (566ms)
  ✔ test › execa() rejects if running non-executable (653ms)
  ✔ test › preferLocal: undefined (896ms)
  ✔ test › preferLocal: false (908ms)
  ✔ test › child process errors rejects promise right away (865ms)
  ✔ test › child process errors are handled (882ms)
  ✔ test › stdin errors are handled (915ms)
  ✔ test › execa() (2.5s)
  ✔ test › skip throwing when using reject option (2.3s)
  ✔ test › stripFinalNewline: true (2.2s)
  ✔ test › stripFinalNewline: false (2.2s)
  ✔ test › stripFinalNewline on failure (2.2s)
  ✔ test › localDir option (1s)
  ✔ test › do not try to consume streams twice (852ms)
  ✔ test › use relative path with '..' chars (823ms)
  ✔ test › extend environment variables by default (568ms)
  ✔ test › localDir option can be a URL (504ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (381ms)
  ✔ test › can use `options.cwd` as a string (539ms)
  ✔ test › do not extend environment with `extendEnv: false` (566ms)
  ✔ test › use environment variables by default (653ms)
  ✔ test › can use `options.cwd` as a URL (499ms)
  ✔ test › can use `options.shell: true` (450ms)
  ✔ test › can use `options.shell: string` (511ms)
  ✔ test › execPath option (1.2s)
  ✔ test › detach child process (591ms)
  ✔ test › preferLocal: true (1.5s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsPureDep/execa/variant9/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (848ms)
  ✖ command › command is: " foo bar" Rejected promise returned by test
  ✖ command › command is: " baz quz" Rejected promise returned by test
  ✖ command › command is: "" Rejected promise returned by test
  ✖ command › escapedCommand is: "foo bar" Rejected promise returned by test
  ✖ command › escapedCommand is: "\"foo bar\"" Rejected promise returned by test
  ✖ command › escapedCommand is: "\"\\\"foo\\\"\"" Rejected promise returned by test
  ✖ command › escapedCommand is: "\"*\"" Rejected promise returned by test
  ✖ command › allow commands with spaces and no array arguments Rejected promise returned by test
  ✖ command › allow commands with spaces and array arguments Rejected promise returned by test
  ✖ command › execaCommand() Rejected promise returned by test
  ✖ command › execaCommand() ignores consecutive spaces Rejected promise returned by test
  ✖ command › execaCommand() allows escaping spaces in commands Rejected promise returned by test
  ✖ command › execaCommand() allows escaping spaces in arguments Rejected promise returned by test
  ✖ command › execaCommand() escapes other whitespaces Rejected promise returned by test
  ✖ command › execaCommand() trims Rejected promise returned by test
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.7s)
  ✔ error › result.killed is false if not killed, in sync mode (925ms)
  ✔ error › result.killed is false on process error, in sync mode (242ms)
  ✖ error › stdout/stderr/all available on errors Rejected promise returned by test
  ✖ error › stdout/stderr/all on process errors Rejected promise returned by test
  ✖ error › exitCode is 0 on success Rejected promise returned by test
  ✖ error › exitCode is 2 Rejected promise returned by test
  ✖ error › exitCode is 3 Rejected promise returned by test
  ✖ error › exitCode is 4 Rejected promise returned by test
  ✖ error › error.message contains the command Rejected promise returned by test
  ✖ error › error.message contains stdout/stderr if available Rejected promise returned by test
  ✖ error › error.message does not contain stdout/stderr if not available Rejected promise returned by test
  ✖ error › error.shortMessage does not contain stdout/stderr Rejected promise returned by test
  ✖ error › failed is false on success Rejected promise returned by test
  ✖ error › failed is true on failure Rejected promise returned by test
  ✖ error › error.killed is true if process was killed directly Rejected promise returned by test
  ✖ error › error.killed is false if process was killed indirectly Rejected promise returned by test
  ✖ error › result.killed is false if not killed Rejected promise returned by test
  ✖ error › result.killed is false on process error Rejected promise returned by test
  ✖ error › error.signal is SIGINT Rejected promise returned by test
  ✖ error › error.signalDescription is defined Rejected promise returned by test
  ✖ error › error.signal is SIGTERM Rejected promise returned by test
  ✖ error › custom error.signal Rejected promise returned by test
  ✖ error › exitCode is undefined on signal termination Rejected promise returned by test
  ✖ error › result.signal is undefined for successful execution Rejected promise returned by test
  ✖ error › result.signal is undefined if process failed, but was not killed Rejected promise returned by test
  ✖ error › result.signalDescription is undefined for successful execution Rejected promise returned by test
  ✖ error › error.code is undefined on success Rejected promise returned by test
  ✔ error › Original error.message is kept (1.4s)
  ✔ error › error.code is defined on failure if applicable (165ms)

  Unhandled rejection in test/error.js

  Error: spawn wrong command ENOENT

  Unhandled rejection in test/error.js

  Error: spawn wrong command ENOENT

  ✖ node › node removes --inspect from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect=9222 from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect-brk from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node should not remove --inspect when passed through nodeOptions Rejected promise returned by test
  ✖ node › node() Rejected promise returned by test
  ✖ node › node pipe stdout Rejected promise returned by test
  ✖ node › node correctly use nodePath Rejected promise returned by test
  ✖ node › node pass on nodeOptions Rejected promise returned by test
  ✖ node › node's forked script has a communication channel Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout` should not be NaN 
  ✖ kill › `forceKillAfterTimeout` should not be negative 
  ✖ kill › execa() returns a promise with kill() Error thrown in test
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3s)
  ✖ kill › cancel method kills the subprocess Error thrown in test
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (1.8s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (761ms)
  ✖ kill › kill("SIGKILL") should terminate cleanly Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout: false` should not kill after a timeout Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout: number` should kill after a timeout Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout: true` should kill after a timeout Rejected promise returned by test
  ✖ kill › kill() with no arguments should kill after a timeout Rejected promise returned by test
  ✖ kill › timeout kills the process if it times out Rejected promise returned by test
  ✖ kill › timeout does not kill the process if it does not time out Rejected promise returned by test
  ✖ kill › timedOut is false if timeout is undefined Rejected promise returned by test
  ✖ kill › timedOut is false if timeout is 0 Rejected promise returned by test
  ✖ kill › spawnAndExit Rejected promise returned by test
  ✖ kill › spawnAndExit cleanup Rejected promise returned by test
  ✖ kill › spawnAndExit detached Rejected promise returned by test
  ✖ kill › spawnAndExit cleanup detached Rejected promise returned by test
  ✖ kill › spawnAndKill SIGTERM Rejected promise returned by test
  ✖ kill › spawnAndKill SIGKILL Rejected promise returned by test
  ✖ kill › spawnAndKill cleanup SIGTERM Rejected promise returned by test
  ✖ kill › spawnAndKill cleanup SIGKILL Rejected promise returned by test
  ✖ kill › spawnAndKill detached SIGTERM Rejected promise returned by test
  ✖ kill › spawnAndKill detached SIGKILL Rejected promise returned by test
  ✖ kill › spawnAndKill cleanup detached SIGTERM Rejected promise returned by test
  ✖ kill › spawnAndKill cleanup detached SIGKILL Rejected promise returned by test
  ✖ kill › removes exit handler on exit Rejected promise returned by test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called (success) Rejected promise returned by test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) Rejected promise returned by test
  ✖ kill › calling cancel method throws an error with message "Command was canceled" Rejected promise returned by test
  ✖ kill › error.isCanceled is true when cancel method is used Rejected promise returned by test
  ✖ kill › error.isCanceled is false when kill method is used Rejected promise returned by test
  ✖ kill › calling cancel method twice should show the same behaviour as calling it once Rejected promise returned by test
  ✖ kill › calling cancel method on a successfully completed process does not make result.isCanceled true Rejected promise returned by test
  ✖ kill › calling cancel method on a process which has been killed does not make error.isCanceled true Rejected promise returned by test
  ✖ kill › calling abort throws an error with message "Command was canceled" Rejected promise returned by test
  ✖ kill › calling abort twice should show the same behaviour as calling it once Rejected promise returned by test
  ✖ kill › calling abort on a successfully completed process does not make result.isCanceled true Rejected promise returned by test
  ✖ kill › calling cancel after abort should show the same behaviour as only calling cancel Rejected promise returned by test
  ✖ kill › calling abort after cancel should show the same behaviour as only calling cancel Rejected promise returned by test
  ✔ kill › timeout kills the process if it times out, in sync mode (3.2s)
  ✔ kill › timeout must not be negative (3.2s)
  ✔ kill › timeout must be an integer (3.2s)
  ✖ override-promise › should work with third-party Promise Rejected promise returned by test
  ✖ promise › promise methods are not enumerable Error thrown in test
  ✖ promise › finally function is executed on success Rejected promise returned by test
  ✖ promise › finally function is executed on failure Rejected promise returned by test
  ✖ promise › throw in finally function bubbles up on success Rejected promise returned by test
  ✖ promise › throw in finally bubbles up on error Rejected promise returned by test
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✖ stream › result.all shows both `stdout` and `stderr` intermixed Rejected promise returned by test
  ✖ stream › buffer: false > promise does not resolve when output is big and is not read Rejected promise returned by test
  ✖ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read Rejected promise returned by test
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.1s)
  ✔ stream › input option can be a String - sync (745ms)
  ✔ stream › input option can be a Buffer - sync (493ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (398ms)
  ✖ stream › buffer Rejected promise returned by test
  ✖ stream › pass `stdout` to a file descriptor Rejected promise returned by test
  ✖ stream › pass `stderr` to a file descriptor Rejected promise returned by test
  ✖ stream › result.all is undefined unless opts.all is true Rejected promise returned by test
  ✖ stream › stdout/stderr/all are undefined if ignored Rejected promise returned by test
  ✖ stream › input option can be a String Rejected promise returned by test
  ✖ stream › input option can be a Buffer Rejected promise returned by test
  ✖ stream › input can be a Stream Rejected promise returned by test
  ✖ stream › you can write to child.stdin Rejected promise returned by test
  ✖ stream › opts.stdout:ignore - stdout will not collect data Rejected promise returned by test
  ✖ stream › maxBuffer affects stdout Rejected promise returned by test
  ✖ stream › maxBuffer affects stderr Rejected promise returned by test
  ✖ stream › do not buffer stdout when `buffer` set to `false` Rejected promise returned by test
  ✖ stream › do not buffer stderr when `buffer` set to `false` Rejected promise returned by test
  ✖ stream › do not buffer when streaming Rejected promise returned by test
  ✖ stream › buffer: false > promise resolves Rejected promise returned by test
  ✖ stream › buffer: false > promise resolves when output is big but is not pipable Rejected promise returned by test
  ✖ stream › buffer: false > promise resolves when output is big and is read Rejected promise returned by test
  ✖ stream › buffer: false > promise resolves when output is big and "all" is used and is read Rejected promise returned by test
  ✖ stream › buffer: false > promise rejects when process returns non-zero Rejected promise returned by test
  ✖ stream › can use all: true with stdout: ignore Rejected promise returned by test
  ✖ stream › can use all: true with stderr: ignore Rejected promise returned by test
  ✔ test › execaSync() (1.1s)
  ✔ test › execaSync() throws error if written to stderr (1s)
  ✔ test › skip throwing when using reject option in sync mode (1s)
  ✔ test › stripFinalNewline in sync mode (902ms)
  ✔ test › stripFinalNewline in sync mode on failure (722ms)
  ✖ test › execa() returns a promise with pid Error thrown in test
  ✔ test › child_process.spawn() propagated errors have correct shape (576ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (521ms)
  ✖ test › execa() Rejected promise returned by test
  ✖ test › skip throwing when using reject option Rejected promise returned by test
  ✖ test › stripFinalNewline: true Rejected promise returned by test
  ✖ test › stripFinalNewline: false Rejected promise returned by test
  ✖ test › stripFinalNewline on failure Rejected promise returned by test
  ✖ test › preferLocal: true Rejected promise returned by test
  ✖ test › preferLocal: false Rejected promise returned by test
  ✖ test › preferLocal: undefined Rejected promise returned by test
  ✖ test › localDir option Rejected promise returned by test
  ✖ test › stdin errors are handled Rejected promise returned by test
  ✖ test › child process errors are handled Rejected promise returned by test
  ✖ test › child process errors rejects promise right away Rejected promise returned by test
  ✖ test › do not try to consume streams twice Rejected promise returned by test
  ✖ test › use relative path with '..' chars Rejected promise returned by test
  ✖ test › execa() rejects if running non-executable Rejected promise returned by test
  ✖ test › execa() rejects with correct error and doesn't throw if running non-executable with input Rejected promise returned by test
  ✖ test › write to fast-exit process 
  ✖ test › use environment variables by default Rejected promise returned by test
  ✖ test › extend environment variables by default Rejected promise returned by test
  ✖ test › do not extend environment with `extendEnv: false` Rejected promise returned by test
  ✖ test › can use `options.cwd` as a string Rejected promise returned by test
  ✖ test › localDir option can be a URL Rejected promise returned by test
  ✖ test › can use `options.cwd` as a URL Rejected promise returned by test
  ✖ test › can use `options.shell: true` Rejected promise returned by test
  ✖ test › can use `options.shell: string` Rejected promise returned by test
  ✖ test › use extend environment with `extendEnv: true` and `shell: true` Rejected promise returned by test
  ✖ test › detach child process Rejected promise returned by test
  ✔ test › child_process.spawn() errors are propagated (649ms)
  ✖ test › execPath option Rejected promise returned by test

  Unhandled rejection in test/test.js

  Error: spawn ava ENOENT

  Unhandled rejection in test/test.js

  Error: spawn ava ENOENT

  Unhandled rejection in test/test.js

  Error: spawn non-executable.js EACCES

  Unhandled rejection in test/test.js

  Error: spawn non-executable.js EACCES

  ─

  command › command is: " foo bar"

  test/command.js:8

   7: const command = async (t, expected, ...args) => {                         
   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › command (file://test/command.js:8:53)



  command › command is: " baz quz"

  test/command.js:8

   7: const command = async (t, expected, ...args) => {                         
   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › command (file://test/command.js:8:53)



  command › command is: ""

  test/command.js:8

   7: const command = async (t, expected, ...args) => {                         
   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › command (file://test/command.js:8:53)



  command › escapedCommand is: "foo bar"

  test/command.js:22

   21: const testEscapedCommand = async (t, expected, args) => {                
   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testEscapedCommand (file://test/command.js:22:67)



  command › escapedCommand is: "\"foo bar\""

  test/command.js:22

   21: const testEscapedCommand = async (t, expected, args) => {                
   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testEscapedCommand (file://test/command.js:22:67)



  command › escapedCommand is: "\"\\\"foo\\\"\""

  test/command.js:22

   21: const testEscapedCommand = async (t, expected, args) => {                
   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testEscapedCommand (file://test/command.js:22:67)



  command › escapedCommand is: "\"*\""

  test/command.js:22

   21: const testEscapedCommand = async (t, expected, args) => {                
   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testEscapedCommand (file://test/command.js:22:67)



  command › allow commands with spaces and no array arguments

  test/command.js:45

   44: test('allow commands with spaces and no array arguments', async t => {
   45:   const {stdout} = await execa('command with space.js');              
   46:   t.is(stdout, '');                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/command.js:45:25



  command › allow commands with spaces and array arguments

  test/command.js:50

   49: test('allow commands with spaces and array arguments', async t => {     
   50:   const {stdout} = await execa('command with space.js', ['foo', 'bar']);
   51:   t.is(stdout, 'foo\nbar');                                             

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/command.js:50:25



  command › execaCommand()

  test/command.js:55

   54: test('execaCommand()', async t => {                                      
   55:   const {stdout} = await execaCommand('node test/fixtures/echo.js foo ba…
   56:   t.is(stdout, 'foo\nbar');                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:55:25



  command › execaCommand() ignores consecutive spaces

  test/command.js:60

   59: test('execaCommand() ignores consecutive spaces', async t => {           
   60:   const {stdout} = await execaCommand('node test/fixtures/echo.js foo   …
   61:   t.is(stdout, 'foo\nbar');                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:60:25



  command › execaCommand() allows escaping spaces in commands

  test/command.js:65

   64: test('execaCommand() allows escaping spaces in commands', async t => {   
   65:   const {stdout} = await execaCommand('command\\ with\\ space.js foo bar…
   66:   t.is(stdout, 'foo\nbar');                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:65:25



  command › execaCommand() allows escaping spaces in arguments

  test/command.js:70

   69: test('execaCommand() allows escaping spaces in arguments', async t => {  
   70:   const {stdout} = await execaCommand('node test/fixtures/echo.js foo\\ …
   71:   t.is(stdout, 'foo bar');                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:70:25



  command › execaCommand() escapes other whitespaces

  test/command.js:75

   74: test('execaCommand() escapes other whitespaces', async t => {            
   75:   const {stdout} = await execaCommand('node test/fixtures/echo.js foo\tb…
   76:   t.is(stdout, 'foo\tbar');                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:75:25



  command › execaCommand() trims

  test/command.js:80

   79: test('execaCommand() trims', async t => {                                
   80:   const {stdout} = await execaCommand('  node test/fixtures/echo.js foo …
   81:   t.is(stdout, 'foo\nbar');                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:80:25



  error › stdout/stderr/all available on errors

  test/error.js:17

   16: test('stdout/stderr/all available on errors', async t => {               
   17:   const {stdout, stderr, all} = await t.throwsAsync(execa('exit.js', ['2…
   18:   t.is(typeof stdout, 'string');                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:17:52



  error › stdout/stderr/all on process errors

  test/error.js:28

   27: test('stdout/stderr/all on process errors', async t => {                 
   28:   const {stdout, stderr, all} = await t.throwsAsync(execa('wrong command…
   29:   t.is(stdout, '');                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:28:52



  error › exitCode is 0 on success

  test/error.js:44

   43: test('exitCode is 0 on success', async t => {        
   44:   const {exitCode} = await execa('noop.js', ['foo']);
   45:   t.is(exitCode, 0);                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:44:27



  error › exitCode is 2

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testExitCode (file://test/error.js:49:41)



  error › exitCode is 3

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testExitCode (file://test/error.js:49:41)



  error › exitCode is 4

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testExitCode (file://test/error.js:49:41)



  error › error.message contains the command

  test/error.js:58

   57: test('error.message contains the command', async t => {                  
   58:   await t.throwsAsync(execa('exit.js', ['2', 'foo', 'bar']), {message: /…
   59: });                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:58:22



  error › error.message contains stdout/stderr if available

  test/error.js:62

   61: test('error.message contains stdout/stderr if available', async t => {
   62:   const {message} = await t.throwsAsync(execa('echo-fail.js'));       
   63:   t.true(message.includes('stderr'));                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:62:40



  error › error.message does not contain stdout/stderr if not available

  test/error.js:68

   67: test('error.message does not contain stdout/stderr if not available', as…
   68:   const {message} = await t.throwsAsync(execa('echo-fail.js', {stdio: 'i…
   69:   t.false(message.includes('stderr'));                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:68:40



  error › error.shortMessage does not contain stdout/stderr

  test/error.js:74

   73: test('error.shortMessage does not contain stdout/stderr', async t => {
   74:   const {shortMessage} = await t.throwsAsync(execa('echo-fail.js'));  
   75:   t.false(shortMessage.includes('stderr'));                           

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:74:45



  error › failed is false on success

  test/error.js:85

   84: test('failed is false on success', async t => {    
   85:   const {failed} = await execa('noop.js', ['foo']);
   86:   t.false(failed);                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:85:25



  error › failed is true on failure

  test/error.js:90

   89: test('failed is true on failure', async t => {                  
   90:   const {failed} = await t.throwsAsync(execa('exit.js', ['2']));
   91:   t.true(failed);                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:90:39



  error › error.killed is true if process was killed directly

  test/error.js:95

   94: test('error.killed is true if process was killed directly', async t => {
   95:   const subprocess = execa('noop.js');                                  
   96:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:95:21



  error › error.killed is false if process was killed indirectly

  test/error.js:104

   103: test('error.killed is false if process was killed indirectly', async t …
   104:   const subprocess = execa('noop.js');                                  
   105:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:104:21



  error › result.killed is false if not killed

  test/error.js:115

   114: test('result.killed is false if not killed', async t => {
   115:   const {killed} = await execa('noop.js');               
   116:   t.false(killed);                                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:115:25



  error › result.killed is false on process error

  test/error.js:125

   124: test('result.killed is false on process error', async t => {   
   125:   const {killed} = await t.throwsAsync(execa('wrong command'));
   126:   t.false(killed);                                             

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:125:39



  error › error.signal is SIGINT

  test/error.js:150

   149:   test('error.signal is SIGINT', async t => {
   150:     const subprocess = execa('noop.js');     
   151:                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:150:22



  error › error.signalDescription is defined

  test/error.js:159

   158:   test('error.signalDescription is defined', async t => {
   159:     const subprocess = execa('noop.js');                 
   160:                                                          

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:159:22



  error › error.signal is SIGTERM

  test/error.js:168

   167:   test('error.signal is SIGTERM', async t => {
   168:     const subprocess = execa('noop.js');      
   169:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:168:22



  error › custom error.signal

  test/error.js:177

   176:   test('custom error.signal', async t => {                              
   177:     const {signal} = await t.throwsAsync(execa('noop.js', {killSignal: …
   178:     t.is(signal, 'SIGHUP');                                             

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:177:40



  error › exitCode is undefined on signal termination

  test/error.js:182

   181:   test('exitCode is undefined on signal termination', async t => {
   182:     const subprocess = execa('noop.js');                          
   183:                                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:182:22



  error › result.signal is undefined for successful execution

  test/error.js:192

   191: test('result.signal is undefined for successful execution', async t => {
   192:   const {signal} = await execa('noop.js');                              
   193:   t.is(signal, undefined);                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:192:25



  error › result.signal is undefined if process failed, but was not killed

  test/error.js:197

   196: test('result.signal is undefined if process failed, but was not killed'…
   197:   const {signal} = await t.throwsAsync(execa('exit.js', [2]), {message:…
   198:   t.is(signal, undefined);                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:197:39



  error › result.signalDescription is undefined for successful execution

  test/error.js:202

   201: test('result.signalDescription is undefined for successful execution', …
   202:   const {signalDescription} = await execa('noop.js');                   
   203:   t.is(signalDescription, undefined);                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:202:36



  error › error.code is undefined on success

  test/error.js:207

   206: test('error.code is undefined on success', async t => {
   207:   const {code} = await execa('noop.js');               
   208:   t.is(code, undefined);                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:207:23



  node › node removes --inspect from nodeOptions when defined by parent process

  test/node.js:13

   12:   try {                                                 
   13:     const subprocess = execaNode('console.log("foo")', {
   14:       reject: false,                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › inspectMacro (file://test/node.js:13:22)



  node › node removes --inspect=9222 from nodeOptions when defined by parent process

  test/node.js:13

   12:   try {                                                 
   13:     const subprocess = execaNode('console.log("foo")', {
   14:       reject: false,                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › inspectMacro (file://test/node.js:13:22)



  node › node removes --inspect-brk from nodeOptions when defined by parent process

  test/node.js:13

   12:   try {                                                 
   13:     const subprocess = execaNode('console.log("foo")', {
   14:       reject: false,                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › inspectMacro (file://test/node.js:13:22)



  node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process

  test/node.js:13

   12:   try {                                                 
   13:     const subprocess = execaNode('console.log("foo")', {
   14:       reject: false,                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › inspectMacro (file://test/node.js:13:22)



  node › node should not remove --inspect when passed through nodeOptions

  test/node.js:85

   84:   async t => {                                                      
   85:     const {stdout, stderr} = await execaNode('console.log("foo")', {
   86:       reject: false,                                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:85:34



  node › node()

  test/node.js:27

   26: test('node()', async t => {                                   
   27:   const {exitCode} = await execaNode('test/fixtures/noop.js');
   28:   t.is(exitCode, 0);                                          

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:27:27



  node › node pipe stdout

  test/node.js:32

   31: test('node pipe stdout', async t => {                                 
   32:   const {stdout} = await execaNode('test/fixtures/noop.js', ['foo'], {
   33:     stdout: 'pipe',                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:32:25



  node › node correctly use nodePath

  test/node.js:40

   39: test('node correctly use nodePath', async t => {                         
   40:   const {stdout} = await execaNode(process.platform === 'win32' ? 'hello…
   41:     stdout: 'pipe',                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:40:25



  node › node pass on nodeOptions

  test/node.js:50

   49: test('node pass on nodeOptions', async t => {             
   50:   const {stdout} = await execaNode('console.log("foo")', {
   51:     stdout: 'pipe',                                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:50:25



  node › node's forked script has a communication channel

  test/node.js:96

   95: test('node\'s forked script has a communication channel', async t => {
   96:   const subprocess = execaNode('test/fixtures/send.js');              
   97:   await pEvent(subprocess, 'message');                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:96:21



  kill › `forceKillAfterTimeout` should not be NaN

  test/kill.js:66

   65:   test('`forceKillAfterTimeout` should not be NaN', t => {               
   66:     t.throws(() => {                                                     
   67:       execa('noop.js').kill('SIGTERM', {forceKillAfterTimeout: Number.Na…

  Function threw unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected instance of:

  Function TypeError {}

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › t.throws.instanceOf (file://test/kill.js:67:4)
  › file://test/kill.js:66:5



  kill › `forceKillAfterTimeout` should not be negative

  test/kill.js:72

   71:   test('`forceKillAfterTimeout` should not be negative', t => {     
   72:     t.throws(() => {                                                
   73:       execa('noop.js').kill('SIGTERM', {forceKillAfterTimeout: -1});

  Function threw unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected instance of:

  Function TypeError {}

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › t.throws.instanceOf (file://test/kill.js:73:4)
  › file://test/kill.js:72:5



  kill › execa() returns a promise with kill()

  test/kill.js:79

   78: test('execa() returns a promise with kill()', t => {
   79:   const {kill} = execa('noop.js', ['foo']);         
   80:   t.is(typeof kill, 'function');                    

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:79:17



  kill › cancel method kills the subprocess

  test/kill.js:195

   194: test('cancel method kills the subprocess', t => {
   195:   const subprocess = execa('node');              
   196:   subprocess.cancel();                           

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:195:21



  kill › kill("SIGKILL") should terminate cleanly

  test/kill.js:13

   12: test('kill("SIGKILL") should terminate cleanly', async t => {            
   13:   const subprocess = execa('node', ['./test/fixtures/no-killable.js'], {…
   14:   await pEvent(subprocess, 'message');                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:13:21



  kill › `forceKillAfterTimeout: false` should not kill after a timeout

  test/kill.js:26

   25:   test('`forceKillAfterTimeout: false` should not kill after a timeout',…
   26:     const subprocess = execa('node', ['./test/fixtures/no-killable.js'],…
   27:     await pEvent(subprocess, 'message');                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:26:22



  kill › `forceKillAfterTimeout: number` should kill after a timeout

  test/kill.js:36

   35:   test('`forceKillAfterTimeout: number` should kill after a timeout', as…
   36:     const subprocess = execa('node', ['./test/fixtures/no-killable.js'],…
   37:     await pEvent(subprocess, 'message');                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:36:22



  kill › `forceKillAfterTimeout: true` should kill after a timeout

  test/kill.js:46

   45:   test('`forceKillAfterTimeout: true` should kill after a timeout', asyn…
   46:     const subprocess = execa('node', ['./test/fixtures/no-killable.js'],…
   47:     await pEvent(subprocess, 'message');                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:46:22



  kill › kill() with no arguments should kill after a timeout

  test/kill.js:56

   55:   test('kill() with no arguments should kill after a timeout', async t =…
   56:     const subprocess = execa('node', ['./test/fixtures/no-killable.js'],…
   57:     await pEvent(subprocess, 'message');                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:56:22



  kill › timeout kills the process if it times out

  test/kill.js:84

   83: test('timeout kills the process if it times out', async t => {           
   84:   const {killed, timedOut} = await t.throwsAsync(execa('noop.js', {timeo…
   85:   t.false(killed);                                                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:84:49



  kill › timeout does not kill the process if it does not time out

  test/kill.js:98

   97: test('timeout does not kill the process if it does not time out', async …
   98:   const {timedOut} = await execa('delay.js', ['500'], {timeout: 1e8});   
   99:   t.false(timedOut);                                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:98:27



  kill › timedOut is false if timeout is undefined

  test/kill.js:117

   116: test('timedOut is false if timeout is undefined', async t => {
   117:   const {timedOut} = await execa('noop.js');                  
   118:   t.false(timedOut);                                          

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:117:27



  kill › timedOut is false if timeout is 0

  test/kill.js:122

   121: test('timedOut is false if timeout is 0', async t => {    
   122:   const {timedOut} = await execa('noop.js', {timeout: 0});
   123:   t.false(timedOut);                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:122:27



  kill › spawnAndExit

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndExit (file://test/kill.js:133:25)



  kill › spawnAndExit cleanup

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndExit (file://test/kill.js:133:25)



  kill › spawnAndExit detached

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndExit (file://test/kill.js:133:25)



  kill › spawnAndExit cleanup detached

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndExit (file://test/kill.js:133:25)



  kill › spawnAndKill SIGTERM

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill SIGKILL

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill cleanup SIGTERM

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill cleanup SIGKILL

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill detached SIGTERM

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill detached SIGKILL

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill cleanup detached SIGTERM

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill cleanup detached SIGKILL

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › removes exit handler on exit

  test/kill.js:182

   181:                                                    
   182:   const subprocess = execa('noop.js');             
   183:   const listener = emitter.listeners('exit').pop();

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:182:21



  kill › result.isCanceled is false when spawned.cancel() isn't called (success)

  test/kill.js:201

   200: test('result.isCanceled is false when spawned.cancel() isn\'t called (s…
   201:   const {isCanceled} = await execa('noop.js');                          
   202:   t.false(isCanceled);                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:201:29



  kill › result.isCanceled is false when spawned.cancel() isn't called (failure)

  test/kill.js:206

   205: test('result.isCanceled is false when spawned.cancel() isn\'t called (f…
   206:   const {isCanceled} = await t.throwsAsync(execa('fail.js'));           
   207:   t.false(isCanceled);                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:206:43



  kill › calling cancel method throws an error with message "Command was canceled"

  test/kill.js:223

   222: test('calling cancel method throws an error with message "Command was c…
   223:   const subprocess = execa('noop.js');                                  
   224:   subprocess.cancel();                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:223:21



  kill › error.isCanceled is true when cancel method is used

  test/kill.js:229

   228: test('error.isCanceled is true when cancel method is used', async t => {
   229:   const subprocess = execa('noop.js');                                  
   230:   subprocess.cancel();                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:229:21



  kill › error.isCanceled is false when kill method is used

  test/kill.js:236

   235: test('error.isCanceled is false when kill method is used', async t => {
   236:   const subprocess = execa('noop.js');                                 
   237:   subprocess.kill();                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:236:21



  kill › calling cancel method twice should show the same behaviour as calling it once

  test/kill.js:243

   242: test('calling cancel method twice should show the same behaviour as cal…
   243:   const subprocess = execa('noop.js');                                  
   244:   subprocess.cancel();                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:243:21



  kill › calling cancel method on a successfully completed process does not make result.isCanceled true

  test/kill.js:252

   251: test('calling cancel method on a successfully completed process does no…
   252:   const subprocess = execa('noop.js');                                  
   253:   const {isCanceled} = await subprocess;                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:252:21



  kill › calling cancel method on a process which has been killed does not make error.isCanceled true

  test/kill.js:259

   258: test('calling cancel method on a process which has been killed does not…
   259:   const subprocess = execa('noop.js');                                  
   260:   subprocess.kill();                                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:259:21



  kill › calling abort throws an error with message "Command was canceled"

  test/kill.js:268

   267:     const abortController = new AbortController();                      
   268:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   269:     abortController.abort();                                            

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:268:22



  kill › calling abort twice should show the same behaviour as calling it once

  test/kill.js:275

   274:     const abortController = new AbortController();                      
   275:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   276:     abortController.abort();                                            

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:275:22



  kill › calling abort on a successfully completed process does not make result.isCanceled true

  test/kill.js:285

   284:     const abortController = new AbortController();                      
   285:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   286:     const {isCanceled} = await subprocess;                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:285:22



  kill › calling cancel after abort should show the same behaviour as only calling cancel

  test/kill.js:293

   292:     const abortController = new AbortController();                      
   293:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   294:     abortController.abort();                                            

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:293:22



  kill › calling abort after cancel should show the same behaviour as only calling cancel

  test/kill.js:303

   302:     const abortController = new AbortController();                      
   303:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   304:     subprocess.cancel();                                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:303:22



  override-promise › should work with third-party Promise

  test/override-promise.js:12

   11: test('should work with third-party Promise', async t => {
   12:   const {stdout} = await execa('noop.js', ['foo']);      
   13:   t.is(stdout, 'foo');                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/override-promise.js:12:25



  promise › promise methods are not enumerable

  test/promise.js:8

   7: test('promise methods are not enumerable', t => {                        
   8:   const descriptors = Object.getOwnPropertyDescriptors(execa('noop.js'));
   9:   t.false(descriptors.then.enumerable);                                  

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/promise.js:8:55



  promise › finally function is executed on success

  test/promise.js:16

   15:   let isCalled = false;                                           
   16:   const {stdout} = await execa('noop.js', ['foo']).finally(() => {
   17:     isCalled = true;                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/promise.js:16:25



  promise › finally function is executed on failure

  test/promise.js:25

   24:   let isError = false;                                                   
   25:   const {stdout, stderr} = await t.throwsAsync(execa('exit.js', ['2']).f…
   26:     isError = true;                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/promise.js:25:47



  promise › throw in finally function bubbles up on success

  test/promise.js:34

   33: test('throw in finally function bubbles up on success', async t => {     
   34:   const {message} = await t.throwsAsync(execa('noop.js', ['foo']).finall…
   35:     throw new Error('called');                                           

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/promise.js:34:40



  promise › throw in finally bubbles up on error

  test/promise.js:41

   40: test('throw in finally bubbles up on error', async t => {                
   41:   const {message} = await t.throwsAsync(execa('exit.js', ['2']).finally(…
   42:     throw new Error('called');                                           

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/promise.js:41:40



  stream › result.all shows both `stdout` and `stderr` intermixed

  test/stream.js:32

   31: test.serial('result.all shows both `stdout` and `stderr` intermixed', as…
   32:   const {all} = await execa('noop-132.js', {all: true});                 
   33:   t.is(all, '132');                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:32:22



  stream › buffer: false > promise does not resolve when output is big and is not read

  test/stream.js:189

   188:   test.serial('buffer: false > promise does not resolve when output is …
   189:     const {timedOut} = await t.throwsAsync(execa('max-buffer.js', {buff…
   190:     t.true(timedOut);                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:189:42



  stream › buffer: false > promise does not resolve when output is big and "all" is used but not read

  test/stream.js:194

   193:   test.serial('buffer: false > promise does not resolve when output is …
   194:     const subprocess = execa('max-buffer.js', {buffer: false, all: true…
   195:     subprocess.stdout.resume();                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:194:22



  stream › buffer

  test/stream.js:14

   13: test('buffer', async t => {                                          
   14:   const {stdout} = await execa('noop.js', ['foo'], {encoding: null});
   15:   t.true(Buffer.isBuffer(stdout));                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:14:25



  stream › pass `stdout` to a file descriptor

  test/stream.js:21

   20:   const file = tempfile('.txt');                                         
   21:   await execa('test/fixtures/noop.js', ['foo bar'], {stdout: fs.openSync…
   22:   t.is(fs.readFileSync(file, 'utf8'), 'foo bar\n');                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:21:8



  stream › pass `stderr` to a file descriptor

  test/stream.js:27

   26:   const file = tempfile('.txt');                                         
   27:   await execa('test/fixtures/noop-err.js', ['foo bar'], {stderr: fs.open…
   28:   t.is(fs.readFileSync(file, 'utf8'), 'foo bar\n');                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:27:8



  stream › result.all is undefined unless opts.all is true

  test/stream.js:37

   36: test('result.all is undefined unless opts.all is true', async t => {
   37:   const {all} = await execa('noop.js');                             
   38:   t.is(all, undefined);                                             

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:37:22



  stream › stdout/stderr/all are undefined if ignored

  test/stream.js:42

   41: test('stdout/stderr/all are undefined if ignored', async t => {          
   42:   const {stdout, stderr, all} = await execa('noop.js', {stdio: 'ignore',…
   43:   t.is(stdout, undefined);                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:42:38



  stream › input option can be a String

  test/stream.js:56

   55: test('input option can be a String', async t => {             
   56:   const {stdout} = await execa('stdin.js', {input: 'foobar'});
   57:   t.is(stdout, 'foobar');                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:56:25



  stream › input option can be a Buffer

  test/stream.js:61

   60: test('input option can be a Buffer', async t => {                
   61:   const {stdout} = await execa('stdin.js', {input: 'testing12'});
   62:   t.is(stdout, 'testing12');                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:61:25



  stream › input can be a Stream

  test/stream.js:69

   68:   stream.end();                                             
   69:   const {stdout} = await execa('stdin.js', {input: stream});
   70:   t.is(stdout, 'howdy');                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:69:25



  stream › you can write to child.stdin

  test/stream.js:74

   73: test('you can write to child.stdin', async t => {
   74:   const subprocess = execa('stdin.js');          
   75:   subprocess.stdin.end('unicorns');              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:74:21



  stream › opts.stdout:ignore - stdout will not collect data

  test/stream.js:91

   90: test('opts.stdout:ignore - stdout will not collect data', async t => {
   91:   const {stdout} = await execa('stdin.js', {                          
   92:     input: 'hello',                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:91:25



  stream › maxBuffer affects stdout

  test/stream.js:108

   107: test('maxBuffer affects stdout', async t => {                           
   108:   await t.notThrowsAsync(execa('max-buffer.js', ['stdout', '10'], {maxB…
   109:   const {stdout, all} = await t.throwsAsync(execa('max-buffer.js', ['st…

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:108:25



  stream › maxBuffer affects stderr

  test/stream.js:115

   114: test('maxBuffer affects stderr', async t => {                           
   115:   await t.notThrowsAsync(execa('max-buffer.js', ['stderr', '10'], {maxB…
   116:   const {stderr, all} = await t.throwsAsync(execa('max-buffer.js', ['st…

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:115:25



  stream › do not buffer stdout when `buffer` set to `false`

  test/stream.js:122

   121: test('do not buffer stdout when `buffer` set to `false`', async t => {  
   122:   const promise = execa('max-buffer.js', ['stdout', '10'], {buffer: fal…
   123:   const [result, stdout] = await Promise.all([                          

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:122:18



  stream › do not buffer stderr when `buffer` set to `false`

  test/stream.js:133

   132: test('do not buffer stderr when `buffer` set to `false`', async t => {  
   133:   const promise = execa('max-buffer.js', ['stderr', '10'], {buffer: fal…
   134:   const [result, stderr] = await Promise.all([                          

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:133:18



  stream › do not buffer when streaming

  test/stream.js:144

   143: test('do not buffer when streaming', async t => {                       
   144:   const {stdout} = execa('max-buffer.js', ['stdout', '21'], {maxBuffer:…
   145:   const result = await getStream(stdout);                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:144:19



  stream › buffer: false > promise resolves

  test/stream.js:150

   149: test('buffer: false > promise resolves', async t => {       
   150:   await t.notThrowsAsync(execa('noop.js', {buffer: false}));
   151: });                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:150:25



  stream › buffer: false > promise resolves when output is big but is not pipable

  test/stream.js:154

   153: test('buffer: false > promise resolves when output is big but is not pi…
   154:   await t.notThrowsAsync(execa('max-buffer.js', {buffer: false, stdout:…
   155: });                                                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:154:25



  stream › buffer: false > promise resolves when output is big and is read

  test/stream.js:158

   157: test('buffer: false > promise resolves when output is big and is read',…
   158:   const subprocess = execa('max-buffer.js', {buffer: false});           
   159:   subprocess.stdout.resume();                                           

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:158:21



  stream › buffer: false > promise resolves when output is big and "all" is used and is read

  test/stream.js:165

   164: test('buffer: false > promise resolves when output is big and "all" is …
   165:   const subprocess = execa('max-buffer.js', {buffer: false, all: true});
   166:   subprocess.all.resume();                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:165:21



  stream › buffer: false > promise rejects when process returns non-zero

  test/stream.js:171

   170: test('buffer: false > promise rejects when process returns non-zero', a…
   171:   const subprocess = execa('fail.js', {buffer: false});                 
   172:   const {exitCode} = await t.throwsAsync(subprocess);                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:171:21



  stream › can use all: true with stdout: ignore

  test/stream.js:177

   176: test('can use all: true with stdout: ignore', async t => {              
   177:   await t.notThrowsAsync(execa('max-buffer.js', {buffer: false, stdout:…
   178: });                                                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:177:25



  stream › can use all: true with stderr: ignore

  test/stream.js:181

   180: test('can use all: true with stderr: ignore', async t => {              
   181:   await t.notThrowsAsync(execa('max-buffer.js', ['stderr'], {buffer: fa…
   182: });                                                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:181:25



  test › execa() returns a promise with pid

  test/test.js:131

   130: test('execa() returns a promise with pid', t => {
   131:   const {pid} = execa('noop.js', ['foo']);       
   132:   t.is(typeof pid, 'number');                    

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:131:16



  test › execa()

  test/test.js:16

   15: test('execa()', async t => {                       
   16:   const {stdout} = await execa('noop.js', ['foo']);
   17:   t.is(stdout, 'foo');                             

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:16:25



  test › skip throwing when using reject option

  test/test.js:44

   43: test('skip throwing when using reject option', async t => {  
   44:   const {exitCode} = await execa('fail.js', {reject: false});
   45:   t.is(exitCode, 2);                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:44:27



  test › stripFinalNewline: true

  test/test.js:54

   53: test('stripFinalNewline: true', async t => {       
   54:   const {stdout} = await execa('noop.js', ['foo']);
   55:   t.is(stdout, 'foo');                             

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:54:25



  test › stripFinalNewline: false

  test/test.js:59

   58: test('stripFinalNewline: false', async t => {                            
   59:   const {stdout} = await execa('noop.js', ['foo'], {stripFinalNewline: f…
   60:   t.is(stdout, 'foo\n');                                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:59:25



  test › stripFinalNewline on failure

  test/test.js:64

   63: test('stripFinalNewline on failure', async t => {                        
   64:   const {stderr} = await t.throwsAsync(execa('noop-throw.js', ['foo'], {…
   65:   t.is(stderr, 'foo');                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:64:39



  test › preferLocal: true

  test/test.js:88

   87: test('preferLocal: true', async t => {                                   
   88:   await t.notThrowsAsync(execa('ava', ['--version'], {preferLocal: true,…
   89: });                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:88:25



  test › preferLocal: false

  test/test.js:92

   91: test('preferLocal: false', async t => {                                  
   92:   await t.throwsAsync(execa('ava', ['--version'], {preferLocal: false, e…
   93: });                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:92:22



  test › preferLocal: undefined

  test/test.js:96

   95: test('preferLocal: undefined', async t => {                              
   96:   await t.throwsAsync(execa('ava', ['--version'], {env: getPathWithoutLo…
   97: });                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:96:22



  test › localDir option

  test/test.js:101

   100:   const command = process.platform === 'win32' ? 'echo %PATH%' : 'echo …
   101:   const {stdout} = await execa(command, {shell: true, preferLocal: true…
   102:   const envPaths = stdout.split(path.delimiter);                        

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:101:25



  test › stdin errors are handled

  test/test.js:113

   112: test('stdin errors are handled', async t => {       
   113:   const subprocess = execa('noop.js');              
   114:   subprocess.stdin.emit('error', new Error('test'));

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:113:21



  test › child process errors are handled

  test/test.js:119

   118: test('child process errors are handled', async t => {
   119:   const subprocess = execa('noop.js');               
   120:   subprocess.emit('error', new Error('test'));       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:119:21



  test › child process errors rejects promise right away

  test/test.js:125

   124: test('child process errors rejects promise right away', async t => {
   125:   const subprocess = execa('noop.js');                              
   126:   subprocess.emit('error', new Error('test'));                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:125:21



  test › do not try to consume streams twice

  test/test.js:157

   156: test('do not try to consume streams twice', async t => {
   157:   const subprocess = execa('noop.js', ['foo']);         
   158:   const {stdout} = await subprocess;                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:157:21



  test › use relative path with '..' chars

  test/test.js:166

   165:   const pathViaParentDir = path.join('..', path.basename(fileURLToPath(…
   166:   const {stdout} = await execa(pathViaParentDir, ['foo']);              
   167:   t.is(stdout, 'foo');                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:166:25



  test › execa() rejects if running non-executable

  test/test.js:172

   171:   test('execa() rejects if running non-executable', async t => {
   172:     const subprocess = execa('non-executable.js');              
   173:     await t.throwsAsync(subprocess);                            

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:172:22



  test › execa() rejects with correct error and doesn't throw if running non-executable with input

  test/test.js:177

   176:   test('execa() rejects with correct error and doesn\'t throw if runnin…
   177:     await t.throwsAsync(execa('non-executable.js', {input: 'Hey!'}), {m…
   178:   });                                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:177:23



  test › write to fast-exit process

  test/test.js:189

   188:     } catch (error) {           
   189:       t.is(error.code, 'EPIPE');
   190:     }                           

  Difference:

  - undefined
  + 'EPIPE'

  › file://test/test.js:189:6



  test › use environment variables by default

  test/test.js:195

   194: test('use environment variables by default', async t => {
   195:   const {stdout} = await execa('environment.js');        
   196:   t.deepEqual(stdout.split('\n'), ['foo', 'undefined']); 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:195:25



  test › extend environment variables by default

  test/test.js:200

   199: test('extend environment variables by default', async t => {            
   200:   const {stdout} = await execa('environment.js', [], {env: {BAR: 'bar',…
   201:   t.deepEqual(stdout.split('\n'), ['foo', 'bar']);                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:200:25



  test › do not extend environment with `extendEnv: false`

  test/test.js:205

   204: test('do not extend environment with `extendEnv: false`', async t => {  
   205:   const {stdout} = await execa('environment.js', [], {env: {BAR: 'bar',…
   206:   t.deepEqual(stdout.split('\n'), ['undefined', 'bar']);                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:205:25



  test › can use `options.cwd` as a string

  test/test.js:211

   210:   const cwd = '/';                                                     
   211:   const {stdout} = await execa('node', ['-p', 'process.cwd()'], {cwd});
   212:   t.is(path.toNamespacedPath(stdout), path.toNamespacedPath(cwd));     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:211:25



  test › localDir option can be a URL

  test/test.js:217

   216:   const command = process.platform === 'win32' ? 'echo %PATH%' : 'echo …
   217:   const {stdout} = await execa(command, {shell: true, preferLocal: true…
   218:   const envPaths = stdout.split(path.delimiter);                        

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:217:25



  test › can use `options.cwd` as a URL

  test/test.js:225

   224:   const cwdUrl = pathToFileURL(cwd);                                    
   225:   const {stdout} = await execa('node', ['-p', 'process.cwd()'], {cwd: c…
   226:   t.is(path.toNamespacedPath(stdout), path.toNamespacedPath(cwd));      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:225:25



  test › can use `options.shell: true`

  test/test.js:230

   229: test('can use `options.shell: true`', async t => {                      
   230:   const {stdout} = await execa('node test/fixtures/noop.js foo', {shell…
   231:   t.is(stdout, 'foo');                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:230:25



  test › can use `options.shell: string`

  test/test.js:236

   235:   const shell = process.platform === 'win32' ? 'cmd.exe' : '/bin/bash'; 
   236:   const {stdout} = await execa('node test/fixtures/noop.js foo', {shell…
   237:   t.is(stdout, 'foo');                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:236:25



  test › use extend environment with `extendEnv: true` and `shell: true`

  test/test.js:243

   242:   const command = process.platform === 'win32' ? 'echo %TEST%' : 'echo …
   243:   const {stdout} = await execa(command, {shell: true, env: {}, extendEn…
   244:   t.is(stdout, 'test');                                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:243:25



  test › detach child process

  test/test.js:249

   248: test('detach child process', async t => {   
   249:   const {stdout} = await execa('detach.js');
   250:   const pid = Number(stdout);               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:249:25



  test › execPath option

  test/test.js:108

   107:   const {path: execPath} = await getNode('6.0.0');                      
   108:   const {stdout} = await execa('node', ['-p', 'process.env.Path || proc…
   109:   t.true(stdout.includes('6.0.0'));                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:108:25

  ─

  149 tests failed
  6 unhandled rejections
-------------|---------|----------|---------|---------|------------------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s            
-------------|---------|----------|---------|---------|------------------------------
All files    |   81.53 |    93.67 |   81.08 |   81.53 |                              
 execa       |   83.14 |     92.5 |   88.88 |   83.14 |                              
  index.js   |   83.14 |     92.5 |   88.88 |   83.14 | 55-57,71-72,113-152          
 execa/lib   |   80.45 |    94.06 |   78.57 |   80.45 |                              
  command.js |     100 |      100 |     100 |     100 |                              
  error.js   |   90.58 |    85.18 |     100 |   90.58 | 9-10,17-18,23-24,76-77       
  kill.js    |   89.21 |    93.54 |      90 |   89.21 | 20,41,43-46,51-55            
  promise.js |   97.22 |     90.9 |     100 |   97.22 | 33                           
  stdio.js   |     100 |      100 |     100 |     100 |                              
  stream.js  |   32.55 |      100 |   16.66 |   32.55 | 7-15,20-34,39-49,53-61,66-79 
-------------|---------|----------|---------|---------|------------------------------
./VariantsPureDep/execa/variant8/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (503ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.7s)
  ✔ error › result.killed is false if not killed, in sync mode (1.2s)
  ✔ error › result.killed is false on process error, in sync mode (298ms)
  ✔ error › Original error.message is kept (1.6s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (428ms)
  ✔ error › stdout/stderr/all on process errors (1.9s)
  ✔ error › stdout/stderr/all available on errors (1.9s)
  ✔ error › exitCode is 0 on success (1.9s)
  ✔ error › exitCode is 2 (1.9s)
  ✔ error › exitCode is 3 (1.9s)
  ✔ error › exitCode is 4 (1.8s)
  ✔ error › error.message contains the command (1.8s)
  ✔ error › error.message contains stdout/stderr if available (1.8s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.8s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.7s)
  ✔ error › failed is false on success (1.7s)
  ✔ error › failed is true on failure (1.7s)
  ✔ error › error.killed is true if process was killed directly (1.6s)
  ✔ error › error.killed is false if process was killed indirectly (1.6s)
  ✔ error › result.killed is false if not killed (1.5s)
  ✔ error › error.signal is SIGINT (465ms)
  ✔ error › error.signalDescription is defined (434ms)
  ✔ error › error.signal is SIGTERM (414ms)
  ✔ error › exitCode is undefined on signal termination (373ms)
  ✔ error › custom error.signal (409ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (383ms)
  ✔ error › result.signal is undefined for successful execution (447ms)
  ✔ error › result.signalDescription is undefined for successful execution (451ms)
  ✔ error › error.code is undefined on success (439ms)
  ✔ command › allow commands with spaces and no array arguments (2s)
  ✔ command › allow commands with spaces and array arguments (1.9s)
  ✔ command › execaCommand() (1.9s)
  ✔ command › execaCommand() ignores consecutive spaces (1.8s)
  ✔ command › execaCommand() allows escaping spaces in commands (1.7s)
  ✔ command › execaCommand() allows escaping spaces in arguments (1.7s)
  ✔ command › execaCommand() escapes other whitespaces (1.6s)
  ✔ command › execaCommand() trims (1.5s)
  ✔ command › command is: " foo bar" (2.5s)
  ✔ command › command is: " baz quz" (2.4s)
  ✔ command › command is: "" (2.3s)
  ✔ command › escapedCommand is: "foo bar" (2.4s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.5s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (2.5s)
  ✔ command › escapedCommand is: "\"*\"" (2.7s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (2.8s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.8s)
  ✔ kill › execa() returns a promise with kill() (2.8s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.6s)
  ✔ kill › cancel method kills the subprocess (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (1.7s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (680ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (2.8s)
  ✔ kill › timeout must not be negative (2.7s)
  ✔ kill › timeout must be an integer (2.7s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel
  ✔ kill › calling abort twice should show the same behaviour as calling it once (116ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (146ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3s)
  ✔ kill › timeout does not kill the process if it does not time out (2.8s)
  ✔ kill › timedOut is false if timeout is undefined (2.8s)
  ✔ kill › timedOut is false if timeout is 0 (2.8s)
  ✔ kill › spawnAndExit (2.5s)
  ✔ kill › spawnAndExit cleanup (2.5s)
  ✔ kill › spawnAndExit detached (2.5s)
  ✔ kill › spawnAndExit cleanup detached (2.5s)
  ✔ kill › spawnAndKill SIGTERM (2.4s)
  ✔ kill › spawnAndKill SIGKILL (2.4s)
  ✔ kill › spawnAndKill detached SIGTERM (2.3s)
  ✔ kill › spawnAndKill detached SIGKILL (2.3s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.2s)
  ✔ kill › removes exit handler on exit (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (1.9s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (311ms)
  ✔ kill › error.isCanceled is true when cancel method is used (301ms)
  ✔ kill › error.isCanceled is false when kill method is used (296ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (285ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (260ms)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.4s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.4s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.2s)
  ✔ kill › timeout kills the process if it times out (2.9s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.2s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (295ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.1s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (230ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node pipe stdout (186ms)
  ✔ node › node() (199ms)
  ✔ node › node's forked script has a communication channel (166ms)
  ✔ node › node pass on nodeOptions (195ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable (103ms)
  ✔ promise › finally function is executed on failure (197ms)
  ✔ promise › finally function is executed on success (242ms)
  ✔ promise › throw in finally bubbles up on error (201ms)
  ✔ promise › throw in finally function bubbles up on success (236ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8s)
  ✔ kill › kill() with no arguments should kill after a timeout (8s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.3s)
  ✔ stream › input option can be a String - sync (1s)
  ✔ stream › input option can be a Buffer - sync (681ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (533ms)
  ✔ stream › buffer (1.5s)
  ✔ stream › pass `stdout` to a file descriptor (1.5s)
  ✔ stream › pass `stderr` to a file descriptor (1.5s)
  ✔ stream › result.all is undefined unless opts.all is true (1.5s)
  ✔ stream › stdout/stderr/all are undefined if ignored (1.5s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (610ms)
  ✔ stream › input option can be a String (1.3s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (763ms)
  ✔ stream › you can write to child.stdin (1.3s)
  ✔ stream › input option can be a Buffer (1.3s)
  ✔ stream › input can be a Stream (1.3s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (760ms)
  ✔ stream › do not buffer when streaming (739ms)
  ✔ stream › buffer: false > promise resolves (801ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (892ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (746ms)
  ✔ stream › maxBuffer affects stderr (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (848ms)
  ✔ stream › can use all: true with stdout: ignore (752ms)
  ✔ stream › can use all: true with stderr: ignore (699ms)
  ✔ stream › maxBuffer affects stdout (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (949ms)
  ✔ test › execaSync() (2.2s)
  ✔ test › execaSync() throws error if written to stderr (2s)
  ✔ test › skip throwing when using reject option in sync mode (2s)
  ✔ test › stripFinalNewline in sync mode (1.8s)
  ✔ test › stripFinalNewline in sync mode on failure (1.1s)
  ✔ test › execa() returns a promise with pid (645ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (620ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (552ms)
  ✔ test › child_process.spawn() errors are propagated (673ms)
  ✔ test › write to fast-exit process (482ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (529ms)
  ✔ test › execa() rejects if running non-executable (609ms)
  ✔ test › preferLocal: undefined (859ms)
  ✔ test › preferLocal: false (871ms)
  ✔ test › child process errors rejects promise right away (836ms)
  ✔ test › child process errors are handled (869ms)
  ✔ test › stdin errors are handled (880ms)
  ✔ test › execa() (2.6s)
  ✔ test › skip throwing when using reject option (2.3s)
  ✔ test › stripFinalNewline: true (2.2s)
  ✔ test › stripFinalNewline: false (2.2s)
  ✔ test › stripFinalNewline on failure (2.1s)
  ✔ test › localDir option (998ms)
  ✔ test › do not try to consume streams twice (846ms)
  ✔ test › use relative path with '..' chars (804ms)
  ✔ test › can use `options.cwd` as a string (543ms)
  ✔ test › localDir option can be a URL (523ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (412ms)
  ✔ test › can use `options.cwd` as a URL (516ms)
  ✔ test › do not extend environment with `extendEnv: false` (579ms)
  ✔ test › use environment variables by default (628ms)
  ✔ test › extend environment variables by default (599ms)
  ✔ test › can use `options.shell: true` (560ms)
  ✔ test › can use `options.shell: string` (517ms)
  ✔ test › execPath option (1.1s)
  ✔ test › detach child process (610ms)
  ✔ test › preferLocal: true (1.5s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsPureDep/execa/variant7/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/error.js

  ReferenceError: lyx is not defined

  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:3)
  › file://node_modules/human-signals/build/src/main.js:24:28

  Uncaught exception in test/command.js

  ReferenceError: lyx is not defined

  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:3)
  › file://node_modules/human-signals/build/src/main.js:24:28

  ✖ test/error.js exited with a non-zero exit code: 1
  ✖ test/command.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  ReferenceError: lyx is not defined

  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:3)
  › file://node_modules/human-signals/build/src/main.js:24:28

  Uncaught exception in test/node.js

  ReferenceError: lyx is not defined

  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:3)
  › file://node_modules/human-signals/build/src/main.js:24:28

  ✖ test/kill.js exited with a non-zero exit code: 1
  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  ReferenceError: lyx is not defined

  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:3)
  › file://node_modules/human-signals/build/src/main.js:24:28

  Uncaught exception in test/promise.js

  ReferenceError: lyx is not defined

  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:3)
  › file://node_modules/human-signals/build/src/main.js:24:28

  ✖ test/promise.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }

  Uncaught exception in test/stream.js

  ReferenceError: lyx is not defined

  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:3)
  › file://node_modules/human-signals/build/src/main.js:24:28

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  ReferenceError: lyx is not defined

  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:3)
  › file://node_modules/human-signals/build/src/main.js:24:28

  ✖ test/test.js exited with a non-zero exit code: 1

  ✖ Timed out while running tests

  ─

  36 tests passed
  8 uncaught exceptions
-------------|---------|----------|---------|---------|---------------------------------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                           
-------------|---------|----------|---------|---------|---------------------------------------------
All files    |   27.32 |      100 |    8.33 |   27.32 |                                             
 execa       |    13.1 |      100 |       0 |    13.1 |                                             
  index.js   |    13.1 |      100 |       0 |    13.1 | ...2,76-162,165-225,228-230,233-235,238-267 
 execa/lib   |   36.84 |      100 |   10.71 |   36.84 |                                             
  command.js |    43.9 |      100 |       0 |    43.9 | 2-6,13-17,28-40                             
  error.js   |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                  
  kill.js    |   36.27 |      100 |       0 |   36.27 | ...-29,38-46,51-55,59-60,65-80,84-86,91-101 
  promise.js |   30.55 |      100 |       0 |   30.55 | 3-4,9-18,23-35                              
  stdio.js   |     100 |      100 |     100 |     100 |                                             
  stream.js  |   29.06 |      100 |       0 |   29.06 | 7-15,20-34,39-49,53-61,66-79,83-85          
-------------|---------|----------|---------|---------|---------------------------------------------
./VariantsPureDep/execa/variant6/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (661ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.7s)
  ✔ error › result.killed is false if not killed, in sync mode (1s)
  ✔ error › result.killed is false on process error, in sync mode (214ms)
  ✔ error › Original error.message is kept (1.4s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (306ms)
  ✔ error › stdout/stderr/all on process errors (1.8s)
  ✔ error › stdout/stderr/all available on errors (1.9s)
  ✔ error › exitCode is 0 on success (1.9s)
  ✔ error › exitCode is 2 (1.8s)
  ✔ error › exitCode is 3 (1.8s)
  ✔ error › exitCode is 4 (1.8s)
  ✔ error › error.message contains the command (1.8s)
  ✔ error › error.message contains stdout/stderr if available (1.7s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.7s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.6s)
  ✔ error › failed is false on success (1.6s)
  ✔ error › failed is true on failure (1.5s)
  ✔ error › error.killed is true if process was killed directly (1.5s)
  ✔ error › error.killed is false if process was killed indirectly (1.4s)
  ✔ error › result.killed is false if not killed (1.3s)
  ✔ error › error.signal is SIGINT (430ms)
  ✔ error › error.signalDescription is defined (425ms)
  ✔ error › error.signal is SIGTERM (419ms)
  ✔ error › exitCode is undefined on signal termination (368ms)
  ✔ error › custom error.signal (411ms)
  ✔ error › error.code is undefined on success (315ms)
  ✔ error › result.signal is undefined for successful execution (435ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (431ms)
  ✔ error › result.signalDescription is undefined for successful execution (424ms)
  ✔ command › allow commands with spaces and no array arguments (2.1s)
  ✔ command › allow commands with spaces and array arguments (2.1s)
  ✔ command › execaCommand() (2s)
  ✔ command › execaCommand() ignores consecutive spaces (1.9s)
  ✔ command › execaCommand() allows escaping spaces in commands (1.9s)
  ✔ command › execaCommand() allows escaping spaces in arguments (1.8s)
  ✔ command › execaCommand() escapes other whitespaces (1.7s)
  ✔ command › execaCommand() trims (1.7s)
  ✔ command › command is: " foo bar" (2.4s)
  ✔ command › command is: " baz quz" (2.4s)
  ✔ command › command is: "" (2.4s)
  ✔ command › escapedCommand is: "foo bar" (2.5s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.6s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (2.7s)
  ✔ command › escapedCommand is: "\"*\"" (2.7s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (2.8s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.8s)
  ✔ kill › execa() returns a promise with kill() (2.7s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.6s)
  ✔ kill › cancel method kills the subprocess (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (1.9s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (714ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (2.7s)
  ✔ kill › timeout must not be negative (2.7s)
  ✔ kill › timeout must be an integer (2.7s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel
  ✔ kill › calling abort twice should show the same behaviour as calling it once (137ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (154ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3s)
  ✔ kill › timeout does not kill the process if it does not time out (2.8s)
  ✔ kill › timedOut is false if timeout is undefined (2.8s)
  ✔ kill › timedOut is false if timeout is 0 (2.7s)
  ✔ kill › spawnAndExit (2.5s)
  ✔ kill › spawnAndExit cleanup (2.5s)
  ✔ kill › spawnAndExit detached (2.5s)
  ✔ kill › spawnAndExit cleanup detached (2.5s)
  ✔ kill › spawnAndKill SIGTERM (2.5s)
  ✔ kill › spawnAndKill SIGKILL (2.4s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.4s)
  ✔ kill › spawnAndKill detached SIGTERM (2.4s)
  ✔ kill › spawnAndKill detached SIGKILL (2.3s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.3s)
  ✔ kill › removes exit handler on exit (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.1s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (327ms)
  ✔ kill › error.isCanceled is true when cancel method is used (317ms)
  ✔ kill › error.isCanceled is false when kill method is used (310ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (302ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (277ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (266ms)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.3s)
  ✔ kill › timeout kills the process if it times out (2.9s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.1s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.1s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.5s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (254ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (159ms)
  ✔ node › node pipe stdout (197ms)
  ✔ node › node's forked script has a communication channel (166ms)
  ✔ node › node pass on nodeOptions (178ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on success (220ms)
  ✔ promise › throw in finally function bubbles up on success (203ms)
  ✔ promise › finally function is executed on failure (234ms)
  ✔ promise › throw in finally bubbles up on error (206ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8s)
  ✔ kill › kill() with no arguments should kill after a timeout (8s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.2s)
  ✔ stream › input option can be a String - sync (913ms)
  ✔ stream › input option can be a Buffer - sync (611ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (457ms)
  ✔ stream › buffer (1.4s)
  ✔ stream › pass `stdout` to a file descriptor (1.4s)
  ✔ stream › pass `stderr` to a file descriptor (1.4s)
  ✔ stream › result.all is undefined unless opts.all is true (1.4s)
  ✔ stream › stdout/stderr/all are undefined if ignored (1.4s)
  ✔ stream › input option can be a String (1.2s)
  ✔ stream › input option can be a Buffer (1.2s)
  ✔ stream › input can be a Stream (1.2s)
  ✔ stream › you can write to child.stdin (1.2s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (770ms)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (741ms)
  ✔ stream › buffer: false > promise resolves (755ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (875ms)
  ✔ stream › do not buffer when streaming (874ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (920ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (946ms)
  ✔ stream › can use all: true with stdout: ignore (890ms)
  ✔ stream › can use all: true with stderr: ignore (860ms)
  ✔ stream › maxBuffer affects stderr (1.2s)
  ✔ stream › maxBuffer affects stdout (1.2s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1s)
  ✔ test › execaSync() (2.2s)
  ✔ test › execaSync() throws error if written to stderr (2s)
  ✔ test › skip throwing when using reject option in sync mode (2s)
  ✔ test › stripFinalNewline in sync mode (1.7s)
  ✔ test › stripFinalNewline in sync mode on failure (888ms)
  ✔ test › execa() returns a promise with pid (612ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (572ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (527ms)
  ✔ test › child_process.spawn() errors are propagated (583ms)
  ✔ test › write to fast-exit process (565ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (588ms)
  ✔ test › execa() rejects if running non-executable (648ms)
  ✔ test › preferLocal: undefined (848ms)
  ✔ test › preferLocal: false (857ms)
  ✔ test › child process errors rejects promise right away (810ms)
  ✔ test › child process errors are handled (824ms)
  ✔ test › stdin errors are handled (862ms)
  ✔ test › execa() (2.6s)
  ✔ test › skip throwing when using reject option (2.4s)
  ✔ test › stripFinalNewline: true (2.1s)
  ✔ test › stripFinalNewline: false (2.1s)
  ✔ test › stripFinalNewline on failure (2.1s)
  ✔ test › localDir option (977ms)
  ✔ test › do not try to consume streams twice (852ms)
  ✔ test › use relative path with '..' chars (836ms)
  ✔ test › extend environment variables by default (723ms)
  ✔ test › can use `options.cwd` as a string (655ms)
  ✔ test › localDir option can be a URL (619ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (454ms)
  ✔ test › can use `options.shell: true` (564ms)
  ✔ test › can use `options.shell: string` (522ms)
  ✔ test › can use `options.cwd` as a URL (610ms)
  ✔ test › use environment variables by default (778ms)
  ✔ test › do not extend environment with `extendEnv: false` (711ms)
  ✔ test › execPath option (1.1s)
  ✔ test › detach child process (610ms)
  ✔ test › preferLocal: true (1.5s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsPureDep/execa/variant5/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/command.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  Uncaught exception in test/error.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/command.js exited with a non-zero exit code: 1
  ✖ test/error.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  Uncaught exception in test/node.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/kill.js exited with a non-zero exit code: 1
  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  Uncaught exception in test/promise.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/promise.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }

  Uncaught exception in test/stream.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › <anonymous> (node_modules/get-node/src/archive/p7z.js:93:18)

  ✖ test/test.js exited with a non-zero exit code: 1

  ✖ Timed out while running tests

  ─

  36 tests passed
  8 uncaught exceptions
-------------|---------|----------|---------|---------|---------------------------------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                           
-------------|---------|----------|---------|---------|---------------------------------------------
All files    |   27.62 |      100 |    8.33 |   27.62 |                                             
 execa       |    13.1 |      100 |       0 |    13.1 |                                             
  index.js   |    13.1 |      100 |       0 |    13.1 | ...2,76-162,165-225,228-230,233-235,238-267 
 execa/lib   |   37.34 |      100 |   10.71 |   37.34 |                                             
  command.js |    43.9 |      100 |       0 |    43.9 | 2-6,13-17,28-40                             
  error.js   |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                  
  kill.js    |   36.27 |      100 |       0 |   36.27 | ...-29,38-46,51-55,59-60,65-80,84-86,91-101 
  promise.js |   36.11 |      100 |       0 |   36.11 | 9-18,23-35                                  
  stdio.js   |     100 |      100 |     100 |     100 |                                             
  stream.js  |   29.06 |      100 |       0 |   29.06 | 7-15,20-34,39-49,53-61,66-79,83-85          
-------------|---------|----------|---------|---------|---------------------------------------------
./VariantsPureDep/execa/variant4/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (846ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.7s)
  ✔ error › result.killed is false if not killed, in sync mode (801ms)
  ✔ error › result.killed is false on process error, in sync mode (244ms)
  ✔ error › Original error.message is kept (1.3s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (332ms)
  ✔ error › stdout/stderr/all on process errors (1.8s)
  ✔ error › stdout/stderr/all available on errors (1.9s)
  ✔ error › exitCode is 0 on success (1.8s)
  ✔ error › exitCode is 2 (1.8s)
  ✔ error › exitCode is 3 (1.8s)
  ✔ error › exitCode is 4 (1.7s)
  ✔ error › error.message contains the command (1.6s)
  ✔ error › error.message contains stdout/stderr if available (1.6s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.5s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.4s)
  ✔ error › failed is false on success (1.4s)
  ✔ error › failed is true on failure (1.3s)
  ✔ error › error.killed is true if process was killed directly (1.2s)
  ✔ error › error.killed is false if process was killed indirectly (1.1s)
  ✔ error › result.killed is false if not killed (1s)
  ✔ error › error.signal is SIGINT (391ms)
  ✔ error › error.signalDescription is defined (379ms)
  ✔ error › error.signal is SIGTERM (359ms)
  ✔ error › exitCode is undefined on signal termination (327ms)
  ✔ error › custom error.signal (359ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (331ms)
  ✔ error › result.signal is undefined for successful execution (379ms)
  ✔ error › result.signalDescription is undefined for successful execution (324ms)
  ✔ error › error.code is undefined on success (356ms)
  ✔ command › allow commands with spaces and no array arguments (2.2s)
  ✔ command › allow commands with spaces and array arguments (2.2s)
  ✔ command › execaCommand() (2.1s)
  ✔ command › execaCommand() ignores consecutive spaces (2.1s)
  ✔ command › execaCommand() allows escaping spaces in commands (2s)
  ✔ command › execaCommand() allows escaping spaces in arguments (1.9s)
  ✔ command › execaCommand() escapes other whitespaces (1.9s)
  ✔ command › execaCommand() trims (1.8s)
  ✔ command › command is: " foo bar" (2.5s)
  ✔ command › command is: " baz quz" (2.5s)
  ✔ command › command is: "" (2.5s)
  ✔ command › escapedCommand is: "foo bar" (2.7s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.7s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (2.8s)
  ✔ command › escapedCommand is: "\"*\"" (2.9s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (2.9s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.9s)
  ✔ kill › execa() returns a promise with kill() (2.8s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.7s)
  ✔ kill › cancel method kills the subprocess (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (1.8s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (746ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (2.8s)
  ✔ kill › timeout must not be negative (2.7s)
  ✔ kill › timeout must be an integer (2.7s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (112ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (153ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (182ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.1s)
  ✔ kill › timeout does not kill the process if it does not time out (2.8s)
  ✔ kill › timedOut is false if timeout is undefined (2.8s)
  ✔ kill › timedOut is false if timeout is 0 (2.8s)
  ✔ kill › spawnAndExit (2.5s)
  ✔ kill › spawnAndExit cleanup (2.5s)
  ✔ kill › spawnAndExit detached (2.5s)
  ✔ kill › spawnAndExit cleanup detached (2.5s)
  ✔ kill › spawnAndKill SIGTERM (2.5s)
  ✔ kill › spawnAndKill SIGKILL (2.5s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.4s)
  ✔ kill › spawnAndKill detached SIGTERM (2.4s)
  ✔ kill › spawnAndKill detached SIGKILL (2.3s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.3s)
  ✔ kill › removes exit handler on exit (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (334ms)
  ✔ kill › error.isCanceled is true when cancel method is used (315ms)
  ✔ kill › error.isCanceled is false when kill method is used (302ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (294ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (287ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (276ms)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.3s)
  ✔ kill › timeout kills the process if it times out (2.9s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.2s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.2s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (244ms)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.5s)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node pipe stdout (152ms)
  ✔ node › node() (193ms)
  ✔ node › node's forked script has a communication channel (162ms)
  ✔ node › node pass on nodeOptions (177ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on failure (231ms)
  ✔ promise › finally function is executed on success (247ms)
  ✔ promise › throw in finally function bubbles up on success (216ms)
  ✔ promise › throw in finally bubbles up on error (220ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.1s)
  ✔ kill › kill() with no arguments should kill after a timeout (8s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.2s)
  ✔ stream › input option can be a String - sync (870ms)
  ✔ stream › input option can be a Buffer - sync (657ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (487ms)
  ✔ stream › buffer (1.3s)
  ✔ stream › pass `stdout` to a file descriptor (1.3s)
  ✔ stream › pass `stderr` to a file descriptor (1.3s)
  ✔ stream › result.all is undefined unless opts.all is true (1.3s)
  ✔ stream › stdout/stderr/all are undefined if ignored (1.3s)
  ✔ stream › input option can be a String (1.2s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (818ms)
  ✔ stream › input option can be a Buffer (1.2s)
  ✔ stream › you can write to child.stdin (1.2s)
  ✔ stream › input can be a Stream (1.2s)
  ✔ stream › do not buffer when streaming (685ms)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (780ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (740ms)
  ✔ stream › buffer: false > promise resolves (872ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (864ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (716ms)
  ✔ stream › buffer: false > promise resolves when output is big and is read (961ms)
  ✔ stream › maxBuffer affects stdout (1.2s)
  ✔ stream › maxBuffer affects stderr (1.2s)
  ✔ stream › can use all: true with stdout: ignore (902ms)
  ✔ stream › can use all: true with stderr: ignore (875ms)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1s)
  ✔ test › execaSync() (2.2s)
  ✔ test › execaSync() throws error if written to stderr (2s)
  ✔ test › skip throwing when using reject option in sync mode (1.9s)
  ✔ test › stripFinalNewline in sync mode (1.2s)
  ✔ test › stripFinalNewline in sync mode on failure (771ms)
  ✔ test › execa() returns a promise with pid (622ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (605ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (557ms)
  ✔ test › child_process.spawn() errors are propagated (648ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (558ms)
  ✔ test › execa() rejects if running non-executable (609ms)
  ✔ test › preferLocal: undefined (798ms)
  ✔ test › preferLocal: false (808ms)
  ✔ test › child process errors rejects promise right away (780ms)
  ✔ test › child process errors are handled (797ms)
  ✔ test › stdin errors are handled (806ms)
  ✔ test › execa() (2.5s)
  ✔ test › skip throwing when using reject option (2.2s)
  ✔ test › stripFinalNewline: true (1.7s)
  ✔ test › stripFinalNewline: false (1.6s)
  ✔ test › stripFinalNewline on failure (1.6s)
  ✔ test › localDir option (944ms)
  ✔ test › do not try to consume streams twice (835ms)
  ✔ test › use relative path with '..' chars (795ms)
  ✔ test › write to fast-exit process (710ms)
  ✔ test › use environment variables by default (690ms)
  ✔ test › localDir option can be a URL (528ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (403ms)
  ✔ test › can use `options.cwd` as a URL (493ms)
  ✔ test › can use `options.cwd` as a string (584ms)
  ✔ test › can use `options.shell: true` (475ms)
  ✔ test › do not extend environment with `extendEnv: false` (626ms)
  ✔ test › extend environment variables by default (663ms)
  ✔ test › can use `options.shell: string` (442ms)
  ✔ test › execPath option (1.1s)
  ✔ test › detach child process (563ms)
  ✔ test › preferLocal: true (1.4s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsPureDep/execa/variant3/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (824ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.7s)
  ✔ error › result.killed is false if not killed, in sync mode (829ms)
  ✔ error › result.killed is false on process error, in sync mode (251ms)
  ✔ error › Original error.message is kept (1.2s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (356ms)
  ✔ error › stdout/stderr/all on process errors (1.8s)
  ✔ error › stdout/stderr/all available on errors (1.9s)
  ✔ error › exitCode is 0 on success (1.8s)
  ✔ error › exitCode is 2 (1.8s)
  ✔ error › exitCode is 3 (1.8s)
  ✔ error › exitCode is 4 (1.7s)
  ✔ error › error.message contains the command (1.7s)
  ✔ error › error.message contains stdout/stderr if available (1.6s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.5s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.4s)
  ✔ error › failed is false on success (1.4s)
  ✔ error › failed is true on failure (1.3s)
  ✔ error › error.killed is true if process was killed directly (1.2s)
  ✔ error › error.killed is false if process was killed indirectly (1.1s)
  ✔ error › result.killed is false if not killed (1.1s)
  ✔ error › error.signal is SIGINT (420ms)
  ✔ error › error.signalDescription is defined (411ms)
  ✔ error › error.signal is SIGTERM (383ms)
  ✔ error › exitCode is undefined on signal termination (338ms)
  ✔ error › custom error.signal (369ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (389ms)
  ✔ error › result.signal is undefined for successful execution (412ms)
  ✔ error › result.signalDescription is undefined for successful execution (395ms)
  ✔ error › error.code is undefined on success (402ms)
  ✔ command › allow commands with spaces and no array arguments (2.3s)
  ✔ command › allow commands with spaces and array arguments (2.2s)
  ✔ command › execaCommand() (2.2s)
  ✔ command › execaCommand() ignores consecutive spaces (2.2s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.1s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2s)
  ✔ command › execaCommand() escapes other whitespaces (2s)
  ✔ command › execaCommand() trims (2s)
  ✔ command › command is: " foo bar" (2.5s)
  ✔ command › command is: " baz quz" (2.5s)
  ✔ command › command is: "" (2.4s)
  ✔ command › escapedCommand is: "foo bar" (2.5s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.6s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (2.7s)
  ✔ command › escapedCommand is: "\"*\"" (2.8s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (2.9s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.9s)
  ✔ kill › execa() returns a promise with kill() (2.9s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.7s)
  ✔ kill › cancel method kills the subprocess (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (1.8s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (793ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (2.8s)
  ✔ kill › timeout must not be negative (2.8s)
  ✔ kill › timeout must be an integer (2.8s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (130ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (173ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (189ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.1s)
  ✔ kill › timeout does not kill the process if it does not time out (2.9s)
  ✔ kill › timedOut is false if timeout is undefined (2.9s)
  ✔ kill › timedOut is false if timeout is 0 (2.9s)
  ✔ kill › spawnAndExit (2.5s)
  ✔ kill › spawnAndExit cleanup (2.5s)
  ✔ kill › spawnAndExit detached (2.5s)
  ✔ kill › spawnAndExit cleanup detached (2.5s)
  ✔ kill › spawnAndKill SIGTERM (2.4s)
  ✔ kill › spawnAndKill SIGKILL (2.4s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.4s)
  ✔ kill › spawnAndKill detached SIGTERM (2.3s)
  ✔ kill › spawnAndKill detached SIGKILL (2.3s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.3s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.2s)
  ✔ kill › removes exit handler on exit (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (321ms)
  ✔ kill › error.isCanceled is true when cancel method is used (303ms)
  ✔ kill › error.isCanceled is false when kill method is used (295ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (290ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (284ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (278ms)
  ✔ kill › timeout kills the process if it times out (3s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.2s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (248ms)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.4s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.2s)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (106ms)
  ✔ node › node pass on nodeOptions (161ms)
  ✔ node › node pipe stdout (192ms)
  ✔ node › node's forked script has a communication channel (153ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › throw in finally function bubbles up on success (143ms)
  ✔ promise › finally function is executed on failure (216ms)
  ✔ promise › finally function is executed on success (249ms)
  ✔ promise › throw in finally bubbles up on error (204ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.1s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.1s)
  ✔ stream › input option can be a String - sync (792ms)
  ✔ stream › input option can be a Buffer - sync (583ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (457ms)
  ✔ stream › buffer (1.3s)
  ✔ stream › pass `stdout` to a file descriptor (1.3s)
  ✔ stream › pass `stderr` to a file descriptor (1.3s)
  ✔ stream › result.all is undefined unless opts.all is true (1.3s)
  ✔ stream › stdout/stderr/all are undefined if ignored (1.3s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (654ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (652ms)
  ✔ stream › input option can be a String (1.2s)
  ✔ stream › input option can be a Buffer (1.2s)
  ✔ stream › input can be a Stream (1.2s)
  ✔ stream › you can write to child.stdin (1.1s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (823ms)
  ✔ stream › do not buffer when streaming (681ms)
  ✔ stream › buffer: false > promise resolves (670ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (851ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (747ms)
  ✔ stream › maxBuffer affects stdout (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (954ms)
  ✔ stream › can use all: true with stderr: ignore (800ms)
  ✔ stream › maxBuffer affects stderr (1.1s)
  ✔ stream › can use all: true with stdout: ignore (854ms)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1s)
  ✔ test › execaSync() (2.1s)
  ✔ test › execaSync() throws error if written to stderr (1.7s)
  ✔ test › skip throwing when using reject option in sync mode (1.5s)
  ✔ test › stripFinalNewline in sync mode (913ms)
  ✔ test › stripFinalNewline in sync mode on failure (672ms)
  ✔ test › execa() returns a promise with pid (550ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (533ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (502ms)
  ✔ test › child_process.spawn() errors are propagated (573ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (517ms)
  ✔ test › execa() rejects if running non-executable (550ms)
  ✔ test › preferLocal: undefined (720ms)
  ✔ test › preferLocal: false (746ms)
  ✔ test › child process errors rejects promise right away (714ms)
  ✔ test › child process errors are handled (728ms)
  ✔ test › stdin errors are handled (742ms)
  ✔ test › execa() (2.4s)
  ✔ test › skip throwing when using reject option (1.9s)
  ✔ test › stripFinalNewline: true (1.3s)
  ✔ test › stripFinalNewline: false (1.2s)
  ✔ test › stripFinalNewline on failure (1.2s)
  ✔ test › localDir option (851ms)
  ✔ test › do not try to consume streams twice (753ms)
  ✔ test › write to fast-exit process (632ms)
  ✔ test › localDir option can be a URL (478ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (363ms)
  ✔ test › use relative path with '..' chars (737ms)
  ✔ test › extend environment variables by default (601ms)
  ✔ test › use environment variables by default (627ms)
  ✔ test › can use `options.cwd` as a string (546ms)
  ✔ test › can use `options.cwd` as a URL (540ms)
  ✔ test › can use `options.shell: true` (492ms)
  ✔ test › do not extend environment with `extendEnv: false` (642ms)
  ✔ test › can use `options.shell: string` (523ms)
  ✔ test › execPath option (1.1s)
  ✔ test › detach child process (636ms)
  ✔ test › preferLocal: true (1.4s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsPureDep/execa/variant2/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✖ command › execaCommandSync() Error thrown in test
  ✖ error › stdout/stderr/all on process errors, in sync mode 
  ✖ error › result.killed is false if not killed, in sync mode Error thrown in test
  ✖ error › result.killed is false on process error, in sync mode 
  ✔ error › Original error.message is kept (1.3s)
  ✔ error › error.code is defined on failure if applicable (196ms)
  ✔ error › result.killed is false on process error (1s)
  ✔ error › stdout/stderr/all on process errors (1.7s)
  ✔ command › allow commands with spaces and array arguments (1.4s)
  ✔ command › allow commands with spaces and no array arguments (1.4s)
  ✔ command › execaCommand() (1.3s)
  ✔ command › execaCommand() ignores consecutive spaces (1.3s)
  ✔ command › execaCommand() allows escaping spaces in commands (1.1s)
  ✔ command › execaCommand() allows escaping spaces in arguments (1.1s)
  ✔ command › execaCommand() trims (1s)
  ✔ command › execaCommand() escapes other whitespaces (1s)
  ✔ error › stdout/stderr/all available on errors (1.9s)
  ✔ error › exitCode is 0 on success (1.8s)
  ✔ error › exitCode is 2 (1.8s)
  ✔ error › exitCode is 3 (1.8s)
  ✔ error › exitCode is 4 (1.8s)
  ✔ error › error.message contains the command (1.8s)
  ✔ error › error.message contains stdout/stderr if available (1.7s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.7s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.6s)
  ✔ error › failed is false on success (1.5s)
  ✔ error › failed is true on failure (1.5s)
  ✔ error › error.killed is true if process was killed directly (1.4s)
  ✔ error › error.killed is false if process was killed indirectly (1.3s)
  ✔ error › result.killed is false if not killed (1.3s)
  ✔ error › error.signal is SIGINT (1s)
  ✔ error › error.signalDescription is defined (1s)
  ✔ error › error.signal is SIGTERM (932ms)
  ✔ error › exitCode is undefined on signal termination (816ms)
  ✔ error › custom error.signal (877ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (716ms)
  ✔ error › result.signalDescription is undefined for successful execution (642ms)
  ✔ error › result.signal is undefined for successful execution (787ms)
  ✔ command › command is: "" (1.9s)
  ✔ command › command is: " foo bar" (2s)
  ✖ command › escapedCommand is: "foo bar" 
  ✔ command › command is: " baz quz" (2s)
  ✔ error › error.code is undefined on success (741ms)
  ✖ command › escapedCommand is: "\"foo bar\"" 
  ✖ command › escapedCommand is: "\"\\\"foo\\\"\"" 
  ✖ command › escapedCommand is: "\"*\"" 
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (1s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (2.1s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2s)
  ✔ kill › execa() returns a promise with kill() (2s)
  ✖ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode Error thrown in test
  ✔ kill › cancel method kills the subprocess (1.2s)
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) Error thrown in test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) 
  ✖ kill › timeout kills the process if it times out, in sync mode 
  ✔ kill › timeout must not be negative (2s)
  ✔ kill › timeout must be an integer (2s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel (361ms)
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (406ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process (1s)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (645ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (809ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (2.6s)
  ✔ kill › timeout does not kill the process if it does not time out (2.5s)
  ✔ kill › timedOut is false if timeout is undefined (2.4s)
  ✔ kill › timedOut is false if timeout is 0 (2.4s)
  ✔ kill › spawnAndKill SIGTERM (2.2s)
  ✔ kill › spawnAndKill SIGKILL (2.1s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2s)
  ✔ kill › spawnAndKill detached SIGTERM (2s)
  ✔ kill › spawnAndKill detached SIGKILL (1.9s)
  ✔ kill › removes exit handler on exit (1.7s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (1.6s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (1.6s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (1.5s)
  ✔ kill › error.isCanceled is true when cancel method is used (1.4s)
  ✔ kill › error.isCanceled is false when kill method is used (1.4s)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (1.3s)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (1.1s)
  ✔ kill › timeout kills the process if it times out (2.6s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (2.8s)
  ✔ kill › spawnAndExit cleanup (2.4s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (1.3s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (2.8s)
  ✔ kill › spawnAndExit (2.5s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.2s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (1.9s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (903ms)
  ✔ kill › spawnAndExit detached (2.4s)
  ✔ kill › spawnAndExit cleanup detached (2.4s)
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process (420ms)
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (134ms)
  ✔ node › node's forked script has a communication channel (138ms)
  ✔ node › node pipe stdout (191ms)
  ✔ node › node pass on nodeOptions (177ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on success (223ms)
  ✔ promise › throw in finally bubbles up on error (198ms)
  ✔ promise › finally function is executed on failure (249ms)
  ✔ promise › throw in finally function bubbles up on success (233ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (7.5s)
  ✔ kill › kill() with no arguments should kill after a timeout (7.5s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✖ stream › stdout/stderr/all are undefined if ignored in sync mode Error thrown in test
  ✖ stream › input option can be a String - sync Error thrown in test
  ✖ stream › input option can be a Buffer - sync Error thrown in test
  ✖ stream › helpful error trying to provide an input stream in sync mode 
  ✖ stream › input option can be a String Rejected promise returned by test
  ✖ stream › input option can be a Buffer Rejected promise returned by test
  ✖ stream › input can be a Stream Rejected promise returned by test
  ✖ stream › opts.stdout:ignore - stdout will not collect data Rejected promise returned by test
  ✔ stream › buffer (995ms)
  ✔ stream › pass `stdout` to a file descriptor (985ms)
  ✔ stream › pass `stderr` to a file descriptor (976ms)
  ✔ stream › result.all is undefined unless opts.all is true (961ms)
  ✔ stream › stdout/stderr/all are undefined if ignored (968ms)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (709ms)
  ✔ stream › you can write to child.stdin (991ms)
  ✔ stream › buffer: false > promise resolves (635ms)
  ✔ stream › do not buffer when streaming (679ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (735ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (547ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (887ms)
  ✔ stream › maxBuffer affects stdout (1.2s)
  ✔ stream › maxBuffer affects stderr (1.1s)
  ✔ stream › can use all: true with stdout: ignore (690ms)
  ✔ stream › buffer: false > promise resolves when output is big and is read (936ms)
  ✔ stream › can use all: true with stderr: ignore (719ms)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (890ms)
  ✖ test › execaSync() Error thrown in test
  ✖ test › execaSync() throws error if written to stderr 
  ✖ test › skip throwing when using reject option in sync mode Error thrown in test
  ✖ test › stripFinalNewline in sync mode Error thrown in test
  ✖ test › stripFinalNewline in sync mode on failure 
  ✔ test › execa() returns a promise with pid (688ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (637ms)
  ✖ test › child_process.spawnSync() errors are propagated with a correct shape 
  ✖ test › execa() rejects with correct error and doesn't throw if running non-executable with input Rejected promise returned by test
  ✖ test › write to fast-exit process 
  ✔ test › child_process.spawn() errors are propagated (658ms)
  ✔ test › execa() rejects if running non-executable (530ms)
  ✔ test › preferLocal: undefined (1s)
  ✔ test › preferLocal: false (1s)
  ✔ test › child process errors rejects promise right away (902ms)
  ✔ test › child process errors are handled (927ms)
  ✔ test › stdin errors are handled (976ms)
  ✔ test › execa() (1.4s)
  ✔ test › skip throwing when using reject option (1.3s)
  ✔ test › stripFinalNewline: true (1.2s)
  ✔ test › stripFinalNewline: false (1.2s)
  ✔ test › stripFinalNewline on failure (1.2s)
  ✔ test › localDir option (1s)
  ✔ test › do not try to consume streams twice (768ms)
  ✔ test › use relative path with '..' chars (738ms)
  ✔ test › extend environment variables by default (556ms)
  ✔ test › localDir option can be a URL (476ms)
  ✔ test › can use `options.cwd` as a URL (430ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (322ms)
  ✔ test › do not extend environment with `extendEnv: false` (523ms)
  ✔ test › use environment variables by default (593ms)
  ✔ test › can use `options.cwd` as a string (525ms)
  ✔ test › can use `options.shell: true` (429ms)
  ✔ test › can use `options.shell: string` (466ms)
  ✔ test › execPath option (1.2s)
  ✔ test › detach child process (549ms)
  ✔ test › preferLocal: true (1.7s)

  Unhandled rejection in test/test.js

  Error: spawn non-executable.js EACCES

  ─

  command › execaCommandSync()

  test/command.js:85

   84: test('execaCommandSync()', t => {                                        
   85:   const {stdout} = execaCommandSync('node test/fixtures/echo.js foo bar'…
   86:   t.is(stdout, 'foo\nbar');                                              

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › execaCommandSync (file://index.js:234:9)
  › file://test/command.js:85:19



  error › stdout/stderr/all on process errors, in sync mode

  test/error.js:38

   37:   });                         
   38:   t.is(stdout, '');           
   39:   t.is(stderr, WRONG_COMMAND);

  Difference:

  - undefined
  + ''

  › file://test/error.js:38:4



  error › result.killed is false if not killed, in sync mode

  test/error.js:120

   119: test('result.killed is false if not killed, in sync mode', t => {
   120:   const {killed} = execaSync('noop.js');                         
   121:   t.false(killed);                                               

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › file://test/error.js:120:19



  error › result.killed is false on process error, in sync mode

  test/error.js:133

   132:   });             
   133:   t.false(killed);
   134: });               

  Value is not `false`:

  undefined

  › file://test/error.js:133:9



  command › escapedCommand is: "foo bar"

  test/command.js:28

   27:   });                                                 
   28:   t.is(failEscapedCommandSync, `fail.js ${expected}`);
   29:                                                       

  Difference:

  - undefined
  + 'fail.js foo bar'

  › testEscapedCommand (file://test/command.js:28:4)



  command › escapedCommand is: "\"foo bar\""

  test/command.js:28

   27:   });                                                 
   28:   t.is(failEscapedCommandSync, `fail.js ${expected}`);
   29:                                                       

  Difference:

  - undefined
  + 'fail.js "foo bar"'

  › testEscapedCommand (file://test/command.js:28:4)



  command › escapedCommand is: "\"\\\"foo\\\"\""

  test/command.js:28

   27:   });                                                 
   28:   t.is(failEscapedCommandSync, `fail.js ${expected}`);
   29:                                                       

  Difference:

  - undefined
  + 'fail.js "\\"foo\\""'

  › testEscapedCommand (file://test/command.js:28:4)



  command › escapedCommand is: "\"*\""

  test/command.js:28

   27:   });                                                 
   28:   t.is(failEscapedCommandSync, `fail.js ${expected}`);
   29:                                                       

  Difference:

  - undefined
  + 'fail.js "*"'

  › testEscapedCommand (file://test/command.js:28:4)



  kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode

  test/kill.js:127

   126: test('timedOut is false if timeout is undefined and exit code is 0 in s…
   127:   const {timedOut} = execaSync('noop.js');                              
   128:   t.false(timedOut);                                                    

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › file://test/kill.js:127:21



  kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success)

  test/kill.js:211

   210: test('result.isCanceled is false when spawned.cancel() isn\'t called in…
   211:   const {isCanceled} = execaSync('noop.js');                            
   212:   t.false(isCanceled);                                                  

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › file://test/kill.js:211:23



  kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure)

  test/kill.js:219

   218:   });                 
   219:   t.false(isCanceled);
   220: });                   

  Value is not `false`:

  undefined

  › file://test/kill.js:219:9



  kill › timeout kills the process if it times out, in sync mode

  test/kill.js:93

   92:   });              
   93:   t.false(killed); 
   94:   t.true(timedOut);

  Value is not `false`:

  undefined

  › file://test/kill.js:93:9



  stream › stdout/stderr/all are undefined if ignored in sync mode

  test/stream.js:49

   48: test('stdout/stderr/all are undefined if ignored in sync mode', t => {   
   49:   const {stdout, stderr, all} = execaSync('noop.js', {stdio: 'ignore', a…
   50:   t.is(stdout, undefined);                                               

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › file://test/stream.js:49:32



  stream › input option can be a String - sync

  test/stream.js:81

   80: test('input option can be a String - sync', t => {          
   81:   const {stdout} = execaSync('stdin.js', {input: 'foobar'});
   82:   t.is(stdout, 'foobar');                                   

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › file://test/stream.js:81:19



  stream › input option can be a Buffer - sync

  test/stream.js:86

   85: test('input option can be a Buffer - sync', t => {                       
   86:   const {stdout} = execaSync('stdin.js', {input: Buffer.from('testing12'…
   87:   t.is(stdout, 'testing12');                                             

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › file://test/stream.js:86:19



  stream › helpful error trying to provide an input stream in sync mode

  test/stream.js:99

   98: test('helpful error trying to provide an input stream in sync mode', t =…
   99:   t.throws(                                                              
   100:     () => {                                                              

  Function threw unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /The `input` option cannot be a stream in sync mode/

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › t.throws.message (file://test/stream.js:101:4)
  › file://test/stream.js:99:4



  stream › input option can be a String

  test/stream.js:56

   55: test('input option can be a String', async t => {             
   56:   const {stdout} = await execa('stdin.js', {input: 'foobar'});
   57:   t.is(stdout, 'foobar');                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › handleInput (file://lib/stream.js:11:6)
  › execa (file://index.js:157:2)
  › file://test/stream.js:56:25



  stream › input option can be a Buffer

  test/stream.js:61

   60: test('input option can be a Buffer', async t => {                
   61:   const {stdout} = await execa('stdin.js', {input: 'testing12'});
   62:   t.is(stdout, 'testing12');                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › handleInput (file://lib/stream.js:11:6)
  › execa (file://index.js:157:2)
  › file://test/stream.js:61:25



  stream › input can be a Stream

  test/stream.js:69

   68:   stream.end();                                             
   69:   const {stdout} = await execa('stdin.js', {input: stream});
   70:   t.is(stdout, 'howdy');                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › handleInput (file://lib/stream.js:11:6)
  › execa (file://index.js:157:2)
  › file://test/stream.js:69:25



  stream › opts.stdout:ignore - stdout will not collect data

  test/stream.js:91

   90: test('opts.stdout:ignore - stdout will not collect data', async t => {
   91:   const {stdout} = await execa('stdin.js', {                          
   92:     input: 'hello',                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › handleInput (file://lib/stream.js:11:6)
  › execa (file://index.js:157:2)
  › file://test/stream.js:91:25



  test › execaSync()

  test/test.js:33

   32: test('execaSync()', t => {                       
   33:   const {stdout} = execaSync('noop.js', ['foo']);
   34:   t.is(stdout, 'foo');                           

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › file://test/test.js:33:19



  test › execaSync() throws error if written to stderr

  test/test.js:38

   37: test('execaSync() throws error if written to stderr', t => {
   38:   t.throws(() => {                                          
   39:     execaSync('foo');                                       

  Function threw unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /spawn.* ENOENT/

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › t.throws.message (file://test/test.js:39:3)
  › file://test/test.js:38:4



  test › skip throwing when using reject option in sync mode

  test/test.js:49

   48: test('skip throwing when using reject option in sync mode', t => {
   49:   const {exitCode} = execaSync('fail.js', {reject: false});       
   50:   t.is(exitCode, 2);                                              

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › file://test/test.js:49:21



  test › stripFinalNewline in sync mode

  test/test.js:69

   68: test('stripFinalNewline in sync mode', t => {                            
   69:   const {stdout} = execaSync('noop.js', ['foo'], {stripFinalNewline: tru…
   70:   t.is(stdout, 'foo');                                                   

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › file://test/test.js:69:19



  test › stripFinalNewline in sync mode on failure

  test/test.js:77

   76:   });                 
   77:   t.is(stderr, 'foo');
   78: });                   

  Difference:

  - undefined
  + 'foo'

  › file://test/test.js:77:4



  test › child_process.spawnSync() errors are propagated with a correct shape

  test/test.js:153

   152:   });            
   153:   t.true(failed);
   154: });              

  Value is not `true`:

  undefined

  › file://test/test.js:153:8



  test › execa() rejects with correct error and doesn't throw if running non-executable with input

  test/test.js:177

   176:   test('execa() rejects with correct error and doesn\'t throw if runnin…
   177:     await t.throwsAsync(execa('non-executable.js', {input: 'Hey!'}), {m…
   178:   });                                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › handleInput (file://lib/stream.js:11:6)
  › execa (file://index.js:157:2)
  › file://test/test.js:177:23



  test › write to fast-exit process

  test/test.js:189

   188:     } catch (error) {           
   189:       t.is(error.code, 'EPIPE');
   190:     }                           

  Difference:

  - undefined
  + 'EPIPE'

  › file://test/test.js:189:6

  ─

  28 tests failed
  1 unhandled rejection
-------------|---------|----------|---------|---------|-----------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s     
-------------|---------|----------|---------|---------|-----------------------
All files    |   91.29 |    96.11 |     100 |   91.29 |                       
 execa       |   80.52 |    86.36 |     100 |   80.52 |                       
  index.js   |   80.52 |    86.36 |     100 |   80.52 | 55-57,175-191,193-224 
 execa/lib   |   98.49 |    98.76 |     100 |   98.49 |                       
  command.js |     100 |      100 |     100 |     100 |                       
  error.js   |     100 |      100 |     100 |     100 |                       
  kill.js    |     100 |      100 |     100 |     100 |                       
  promise.js |     100 |      100 |     100 |     100 |                       
  stdio.js   |     100 |      100 |     100 |     100 |                       
  stream.js  |   93.02 |    93.75 |     100 |   93.02 | 12-15,84-85           
-------------|---------|----------|---------|---------|-----------------------
./VariantsPureDep/execa/variant1/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (747ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.6s)
  ✔ error › result.killed is false if not killed, in sync mode (759ms)
  ✔ error › result.killed is false on process error, in sync mode (159ms)
  ✔ error › Original error.message is kept (1.3s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (271ms)
  ✔ error › stdout/stderr/all on process errors (1.7s)
  ✔ error › stdout/stderr/all available on errors (1.8s)
  ✔ error › exitCode is 0 on success (1.8s)
  ✔ error › exitCode is 2 (1.8s)
  ✔ error › exitCode is 3 (1.7s)
  ✔ error › exitCode is 4 (1.7s)
  ✔ error › error.message contains the command (1.7s)
  ✔ error › error.message contains stdout/stderr if available (1.6s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.6s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.5s)
  ✔ error › failed is false on success (1.4s)
  ✔ error › failed is true on failure (1.3s)
  ✔ error › error.killed is true if process was killed directly (1.2s)
  ✔ error › error.killed is false if process was killed indirectly (1.1s)
  ✔ error › result.killed is false if not killed (1.1s)
  ✔ error › error.signal is SIGINT (392ms)
  ✔ error › error.signalDescription is defined (384ms)
  ✔ error › error.signal is SIGTERM (379ms)
  ✔ error › exitCode is undefined on signal termination (365ms)
  ✔ error › custom error.signal (374ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (383ms)
  ✔ error › result.signal is undefined for successful execution (468ms)
  ✔ error › result.signalDescription is undefined for successful execution (455ms)
  ✔ error › error.code is undefined on success (446ms)
  ✔ command › allow commands with spaces and no array arguments (2.4s)
  ✔ command › allow commands with spaces and array arguments (2.3s)
  ✔ command › execaCommand() (2.3s)
  ✔ command › execaCommand() ignores consecutive spaces (2.2s)
  ✔ command › execaCommand() allows escaping spaces in commands (2s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2s)
  ✔ command › execaCommand() escapes other whitespaces (1.9s)
  ✔ command › execaCommand() trims (1.9s)
  ✔ command › command is: " foo bar" (2.6s)
  ✔ command › command is: " baz quz" (2.5s)
  ✔ command › command is: "" (2.5s)
  ✔ command › escapedCommand is: "foo bar" (2.6s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.7s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (2.8s)
  ✔ command › escapedCommand is: "\"*\"" (2.9s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.9s)
  ✔ kill › execa() returns a promise with kill() (2.9s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.7s)
  ✔ kill › cancel method kills the subprocess (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (1.6s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (585ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (2.9s)
  ✔ kill › timeout must not be negative (2.8s)
  ✔ kill › timeout must be an integer (2.8s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel
  ✔ kill › calling abort twice should show the same behaviour as calling it once (135ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (156ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.2s)
  ✔ kill › timeout does not kill the process if it does not time out (2.9s)
  ✔ kill › timedOut is false if timeout is undefined (2.9s)
  ✔ kill › timedOut is false if timeout is 0 (2.9s)
  ✔ kill › spawnAndExit (2.5s)
  ✔ kill › spawnAndExit cleanup (2.5s)
  ✔ kill › spawnAndExit detached (2.5s)
  ✔ kill › spawnAndExit cleanup detached (2.4s)
  ✔ kill › spawnAndKill SIGTERM (2.4s)
  ✔ kill › spawnAndKill SIGKILL (2.4s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.3s)
  ✔ kill › spawnAndKill detached SIGTERM (2.3s)
  ✔ kill › spawnAndKill detached SIGKILL (2.3s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.2s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.2s)
  ✔ kill › removes exit handler on exit (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (1.8s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (304ms)
  ✔ kill › error.isCanceled is true when cancel method is used (288ms)
  ✔ kill › error.isCanceled is false when kill method is used (279ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (271ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (264ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (254ms)
  ✔ kill › timeout kills the process if it times out (3.1s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.3s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.4s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.2s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (236ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (188ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (135ms)
  ✔ node › node's forked script has a communication channel (143ms)
  ✔ node › node pipe stdout (198ms)
  ✔ node › node pass on nodeOptions (180ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on success (190ms)
  ✔ promise › finally function is executed on failure (238ms)
  ✔ promise › throw in finally function bubbles up on success (222ms)
  ✔ promise › throw in finally bubbles up on error (221ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.1s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.1s)
  ✔ stream › input option can be a String - sync (812ms)
  ✔ stream › input option can be a Buffer - sync (625ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (429ms)
  ✔ stream › buffer (1.4s)
  ✔ stream › pass `stdout` to a file descriptor (1.4s)
  ✔ stream › pass `stderr` to a file descriptor (1.3s)
  ✔ stream › result.all is undefined unless opts.all is true (1.3s)
  ✔ stream › stdout/stderr/all are undefined if ignored (1.3s)
  ✔ stream › do not buffer when streaming (718ms)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (774ms)
  ✔ stream › input option can be a Buffer (1.2s)
  ✔ stream › you can write to child.stdin (1.2s)
  ✔ stream › input option can be a String (1.2s)
  ✔ stream › input can be a Stream (1.2s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (864ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (796ms)
  ✔ stream › buffer: false > promise resolves (843ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (944ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (836ms)
  ✔ stream › buffer: false > promise resolves when output is big and is read (993ms)
  ✔ stream › maxBuffer affects stderr (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1s)
  ✔ stream › can use all: true with stdout: ignore (945ms)
  ✔ stream › maxBuffer affects stdout (1.2s)
  ✔ stream › can use all: true with stderr: ignore (908ms)
  ✔ test › execaSync() (2.1s)
  ✔ test › execaSync() throws error if written to stderr (2s)
  ✔ test › skip throwing when using reject option in sync mode (1.9s)
  ✔ test › stripFinalNewline in sync mode (1.4s)
  ✔ test › stripFinalNewline in sync mode on failure (804ms)
  ✔ test › execa() returns a promise with pid (650ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (630ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (593ms)
  ✔ test › child_process.spawn() errors are propagated (656ms)
  ✔ test › write to fast-exit process (544ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (605ms)
  ✔ test › execa() rejects if running non-executable (647ms)
  ✔ test › preferLocal: undefined (810ms)
  ✔ test › preferLocal: false (826ms)
  ✔ test › child process errors rejects promise right away (795ms)
  ✔ test › child process errors are handled (817ms)
  ✔ test › stdin errors are handled (830ms)
  ✔ test › execa() (2.5s)
  ✔ test › skip throwing when using reject option (2.3s)
  ✔ test › stripFinalNewline: true (1.8s)
  ✔ test › stripFinalNewline: false (1.8s)
  ✔ test › stripFinalNewline on failure (1.8s)
  ✔ test › localDir option (932ms)
  ✔ test › do not try to consume streams twice (833ms)
  ✔ test › use relative path with '..' chars (796ms)
  ✔ test › localDir option can be a URL (514ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (369ms)
  ✔ test › extend environment variables by default (632ms)
  ✔ test › do not extend environment with `extendEnv: false` (609ms)
  ✔ test › can use `options.cwd` as a URL (525ms)
  ✔ test › use environment variables by default (679ms)
  ✔ test › can use `options.cwd` as a string (577ms)
  ✔ test › can use `options.shell: string` (469ms)
  ✔ test › can use `options.shell: true` (572ms)
  ✔ test › detach child process (538ms)
  ✔ test › execPath option (1.1s)
  ✔ test › preferLocal: true (1.4s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------

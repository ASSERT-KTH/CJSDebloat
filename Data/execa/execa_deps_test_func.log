13
./VariantsDeps/execa/variant13/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (1s)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.6s)
  ✔ error › result.killed is false if not killed, in sync mode (881ms)
  ✔ error › result.killed is false on process error, in sync mode (189ms)
  ✔ error › Original error.message is kept (1.2s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (310ms)
  ✔ error › stdout/stderr/all on process errors (1.8s)
  ✔ error › stdout/stderr/all available on errors (2s)
  ✔ error › exitCode is 0 on success (1.7s)
  ✔ error › exitCode is 2 (1.7s)
  ✔ error › exitCode is 3 (1.6s)
  ✔ error › exitCode is 4 (1.6s)
  ✔ error › error.message contains the command (1.5s)
  ✔ error › error.message contains stdout/stderr if available (1.5s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.4s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.4s)
  ✔ error › failed is false on success (1.3s)
  ✔ error › failed is true on failure (1.2s)
  ✔ error › error.killed is true if process was killed directly (1.2s)
  ✔ error › error.killed is false if process was killed indirectly (1.2s)
  ✔ error › result.killed is false if not killed (1.1s)
  ✔ error › error.signal is SIGINT (369ms)
  ✔ error › error.signalDescription is defined (353ms)
  ✔ error › error.signal is SIGTERM (342ms)
  ✔ error › exitCode is undefined on signal termination (324ms)
  ✔ error › custom error.signal (359ms)
  ✔ error › result.signalDescription is undefined for successful execution (353ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (409ms)
  ✔ error › error.code is undefined on success (386ms)
  ✔ error › result.signal is undefined for successful execution (441ms)
  ✔ command › allow commands with spaces and no array arguments (2.4s)
  ✔ command › allow commands with spaces and array arguments (2.4s)
  ✔ command › execaCommand() (2.4s)
  ✔ command › execaCommand() ignores consecutive spaces (2.3s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.3s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.3s)
  ✔ command › execaCommand() escapes other whitespaces (2.2s)
  ✔ command › execaCommand() trims (2.2s)
  ✔ command › command is: " foo bar" (2.6s)
  ✔ command › command is: " baz quz" (2.6s)
  ✔ command › command is: "" (2.5s)
  ✔ command › escapedCommand is: "foo bar" (2.7s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.8s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (2.9s)
  ✔ command › escapedCommand is: "\"*\"" (3s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (2.8s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.8s)
  ✔ kill › execa() returns a promise with kill() (2.8s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.6s)
  ✔ kill › cancel method kills the subprocess (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (1.9s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (924ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (2.8s)
  ✔ kill › timeout must not be negative (2.7s)
  ✔ kill › timeout must be an integer (2.7s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (123ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (159ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (190ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3s)
  ✔ kill › timeout does not kill the process if it does not time out (2.8s)
  ✔ kill › timedOut is false if timeout is undefined (2.8s)
  ✔ kill › timedOut is false if timeout is 0 (2.8s)
  ✔ kill › spawnAndExit (2.4s)
  ✔ kill › spawnAndExit cleanup (2.4s)
  ✔ kill › spawnAndExit detached (2.4s)
  ✔ kill › spawnAndExit cleanup detached (2.4s)
  ✔ kill › spawnAndKill SIGTERM (2.4s)
  ✔ kill › spawnAndKill SIGKILL (2.3s)
  ✔ kill › spawnAndKill detached SIGTERM (2.3s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.2s)
  ✔ kill › removes exit handler on exit (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.1s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (370ms)
  ✔ kill › error.isCanceled is true when cancel method is used (358ms)
  ✔ kill › error.isCanceled is false when kill method is used (326ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (307ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (300ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (295ms)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.3s)
  ✔ kill › spawnAndKill detached SIGKILL (2.3s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.3s)
  ✔ kill › timeout kills the process if it times out (3s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.1s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.1s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.4s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (299ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (108ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node pipe stdout (150ms)
  ✔ node › node() (193ms)
  ✔ node › node's forked script has a communication channel (175ms)
  ✔ node › node pass on nodeOptions (193ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on success (228ms)
  ✔ promise › finally function is executed on failure (246ms)
  ✔ promise › throw in finally function bubbles up on success (239ms)
  ✔ promise › throw in finally bubbles up on error (222ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8s)
  ✔ kill › kill() with no arguments should kill after a timeout (7.9s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.8s)
  ✔ stream › input option can be a String - sync (1.4s)
  ✔ stream › input option can be a Buffer - sync (951ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (686ms)
  ✔ stream › buffer (2s)
  ✔ stream › pass `stdout` to a file descriptor (2.1s)
  ✔ stream › pass `stderr` to a file descriptor (2s)
  ✔ stream › result.all is undefined unless opts.all is true (2s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2s)
  ✔ stream › input option can be a String (1.8s)
  ✔ stream › you can write to child.stdin (1.7s)
  ✔ stream › input option can be a Buffer (1.8s)
  ✔ stream › input can be a Stream (1.8s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (1.2s)
  ✔ test › execaSync() (2.3s)
  ✔ test › execaSync() throws error if written to stderr (2s)
  ✔ test › skip throwing when using reject option in sync mode (1.9s)
  ✔ test › stripFinalNewline in sync mode (1.5s)
  ✔ test › stripFinalNewline in sync mode on failure (1.4s)
  ✔ test › execa() returns a promise with pid (1.2s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1.2s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (1.1s)
  ✔ test › child_process.spawn() errors are propagated (1.4s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (1.2s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (1.2s)
  ✔ stream › do not buffer when streaming (1.3s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (1.4s)
  ✔ test › execa() rejects if running non-executable (1.4s)
  ✔ stream › buffer: false > promise resolves (1.3s)
  ✔ test › preferLocal: undefined (1.6s)
  ✔ test › preferLocal: false (1.7s)
  ✔ test › child process errors rejects promise right away (1.6s)
  ✔ test › child process errors are handled (1.6s)
  ✔ test › stdin errors are handled (1.6s)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1.3s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (1.3s)
  ✔ test › execa() (3s)
  ✔ test › skip throwing when using reject option (2.7s)
  ✔ test › stripFinalNewline: true (2.4s)
  ✔ test › stripFinalNewline: false (2.3s)
  ✔ test › stripFinalNewline on failure (2.3s)
  ✔ test › localDir option (1.9s)
  ✔ test › do not try to consume streams twice (1.8s)
  ✔ test › use relative path with '..' chars (1.7s)
  ✔ test › write to fast-exit process (1.6s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.4s)
  ✔ test › use environment variables by default (1.6s)
  ✔ test › extend environment variables by default (1.5s)
  ✔ test › localDir option can be a URL (1.3s)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (1s)
  ✔ test › can use `options.cwd` as a string (1.4s)
  ✔ test › do not extend environment with `extendEnv: false` (1.5s)
  ✔ test › can use `options.cwd` as a URL (1.3s)
  ✔ test › can use `options.shell: true` (1.2s)
  ✔ stream › can use all: true with stdout: ignore (1.3s)
  ✔ test › can use `options.shell: string` (1.1s)
  ✔ stream › can use all: true with stderr: ignore (1.3s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.6s)
  ✔ stream › maxBuffer affects stderr (1.9s)
  ✔ stream › maxBuffer affects stdout (1.9s)
  ✔ test › detach child process (1.2s)
  ✔ test › preferLocal: true (2.6s)
  ✔ test › execPath option (2.9s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsDeps/execa/variant12/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (831ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.7s)
  ✔ error › result.killed is false if not killed, in sync mode (965ms)
  ✔ error › result.killed is false on process error, in sync mode (171ms)
  ✔ error › Original error.message is kept (1.4s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (330ms)
  ✔ error › stdout/stderr/all on process errors (1.9s)
  ✔ error › stdout/stderr/all available on errors (2s)
  ✔ error › exitCode is 0 on success (2s)
  ✔ error › exitCode is 2 (1.9s)
  ✔ error › exitCode is 3 (1.9s)
  ✔ error › exitCode is 4 (1.9s)
  ✔ error › error.message contains the command (1.8s)
  ✔ error › error.message contains stdout/stderr if available (1.8s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.7s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.7s)
  ✔ error › failed is false on success (1.6s)
  ✔ error › failed is true on failure (1.5s)
  ✔ error › error.killed is true if process was killed directly (1.4s)
  ✔ error › error.killed is false if process was killed indirectly (1.3s)
  ✔ error › result.killed is false if not killed (1.3s)
  ✔ error › error.signal is SIGINT (420ms)
  ✔ error › error.signalDescription is defined (446ms)
  ✔ error › error.signal is SIGTERM (440ms)
  ✔ error › exitCode is undefined on signal termination (426ms)
  ✔ error › custom error.signal (437ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (425ms)
  ✔ error › error.code is undefined on success (426ms)
  ✔ error › result.signal is undefined for successful execution (549ms)
  ✔ error › result.signalDescription is undefined for successful execution (521ms)
  ✔ command › allow commands with spaces and no array arguments (2.4s)
  ✔ command › allow commands with spaces and array arguments (2.3s)
  ✔ command › execaCommand() (2.3s)
  ✔ command › execaCommand() ignores consecutive spaces (2.2s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.2s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.1s)
  ✔ command › execaCommand() escapes other whitespaces (2s)
  ✔ command › execaCommand() trims (1.9s)
  ✔ command › command is: " foo bar" (2.6s)
  ✔ command › command is: " baz quz" (2.6s)
  ✔ command › command is: "" (2.5s)
  ✔ command › escapedCommand is: "foo bar" (2.7s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.8s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (2.9s)
  ✔ command › escapedCommand is: "\"*\"" (2.9s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.9s)
  ✔ kill › execa() returns a promise with kill() (2.9s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.8s)
  ✔ kill › cancel method kills the subprocess (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (1s)
  ✔ kill › timeout kills the process if it times out, in sync mode (3s)
  ✔ kill › timeout must not be negative (2.9s)
  ✔ kill › timeout must be an integer (2.9s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel (185ms)
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (267ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (350ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (365ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.2s)
  ✔ kill › timeout does not kill the process if it does not time out (3.1s)
  ✔ kill › timedOut is false if timeout is undefined (3.1s)
  ✔ kill › timedOut is false if timeout is 0 (3.1s)
  ✔ kill › spawnAndExit (2.7s)
  ✔ kill › spawnAndExit cleanup (2.7s)
  ✔ kill › spawnAndExit detached (2.7s)
  ✔ kill › spawnAndExit cleanup detached (2.7s)
  ✔ kill › spawnAndKill SIGTERM (2.7s)
  ✔ kill › spawnAndKill SIGKILL (2.7s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.6s)
  ✔ kill › spawnAndKill detached SIGTERM (2.6s)
  ✔ kill › spawnAndKill detached SIGKILL (2.6s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.6s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.5s)
  ✔ kill › removes exit handler on exit (2.5s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.4s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.4s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (679ms)
  ✔ kill › error.isCanceled is true when cancel method is used (648ms)
  ✔ kill › error.isCanceled is false when kill method is used (630ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (616ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (575ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (563ms)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.7s)
  ✔ kill › timeout kills the process if it times out (3.3s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.4s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (529ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.4s)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (277ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process (205ms)
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process (137ms)
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process (331ms)
  ✔ node › node should not remove --inspect when passed through nodeOptions (301ms)
  ✔ node › node correctly use nodePath
  ✔ node › node() (412ms)
  ✔ node › node pipe stdout (391ms)
  ✔ node › node's forked script has a communication channel (457ms)
  ✔ node › node pass on nodeOptions (492ms)
  ✔ override-promise › should work with third-party Promise (208ms)
  ✔ promise › promise methods are not enumerable (137ms)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.2s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.2s)
  ✔ promise › finally function is executed on failure (336ms)
  ✔ promise › finally function is executed on success (467ms)
  ✔ promise › throw in finally bubbles up on error (404ms)
  ✔ promise › throw in finally function bubbles up on success (471ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.2s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ test › execaSync() (1.6s)
  ✔ test › execaSync() throws error if written to stderr (1.3s)
  ✔ test › skip throwing when using reject option in sync mode (1.3s)
  ✔ test › stripFinalNewline in sync mode (1s)
  ✔ test › stripFinalNewline in sync mode on failure (810ms)
  ✔ test › execa() returns a promise with pid (697ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (691ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (633ms)
  ✔ test › child_process.spawn() errors are propagated (764ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (753ms)
  ✔ test › execa() rejects if running non-executable (789ms)
  ✔ test › preferLocal: undefined (978ms)
  ✔ test › preferLocal: false (993ms)
  ✔ test › child process errors rejects promise right away (953ms)
  ✔ test › child process errors are handled (978ms)
  ✔ test › stdin errors are handled (992ms)
  ✔ test › execa() (2.2s)
  ✔ test › skip throwing when using reject option (1.9s)
  ✔ test › stripFinalNewline: true (1.6s)
  ✔ test › stripFinalNewline: false (1.6s)
  ✔ test › stripFinalNewline on failure (1.6s)
  ✔ test › localDir option (1.1s)
  ✔ test › write to fast-exit process (994ms)
  ✔ test › localDir option can be a URL (896ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (740ms)
  ✔ test › do not try to consume streams twice (1.1s)
  ✔ test › use relative path with '..' chars (1s)
  ✔ test › can use `options.cwd` as a string (988ms)
  ✔ test › use environment variables by default (1s)
  ✔ test › can use `options.cwd` as a URL (957ms)
  ✔ test › extend environment variables by default (1s)
  ✔ test › do not extend environment with `extendEnv: false` (1s)
  ✔ test › can use `options.shell: true` (992ms)
  ✔ test › can use `options.shell: string` (1s)
  ✔ test › execPath option (1.7s)
  ✔ test › detach child process (1.2s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.8s)
  ✔ stream › input option can be a String - sync (953ms)
  ✔ stream › input option can be a Buffer - sync (561ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (356ms)
  ✔ stream › buffer (2.2s)
  ✔ stream › pass `stdout` to a file descriptor (2.2s)
  ✔ stream › pass `stderr` to a file descriptor (2.1s)
  ✔ stream › result.all is undefined unless opts.all is true (2s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2s)
  ✔ stream › input option can be a String (1.2s)
  ✔ stream › you can write to child.stdin (1.1s)
  ✔ stream › input option can be a Buffer (1.2s)
  ✔ stream › input can be a Stream (1.2s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (669ms)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (762ms)
  ✔ stream › buffer: false > promise resolves (790ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (829ms)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (935ms)
  ✔ stream › do not buffer when streaming (959ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (851ms)
  ✔ stream › can use all: true with stdout: ignore (836ms)
  ✔ stream › buffer: false > promise resolves when output is big and is read (981ms)
  ✔ stream › can use all: true with stderr: ignore (846ms)
  ✔ stream › maxBuffer affects stdout (1.1s)
  ✔ stream › maxBuffer affects stderr (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1s)
  ✔ test › preferLocal: true (3.5s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsDeps/execa/variant11/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/command.js

  ReferenceError: lyx is not defined

  › supported (node_modules/human-signals/src/main.js:9:3)
  › <anonymous> (node_modules/human-signals/src/main.js:24:34)

  Uncaught exception in test/error.js

  ReferenceError: lyx is not defined

  › supported (node_modules/human-signals/src/main.js:9:3)
  › <anonymous> (node_modules/human-signals/src/main.js:24:34)

  ✖ test/command.js exited with a non-zero exit code: 1
  ✖ test/error.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  ReferenceError: lyx is not defined

  › supported (node_modules/human-signals/src/main.js:9:3)
  › <anonymous> (node_modules/human-signals/src/main.js:24:34)

  Uncaught exception in test/node.js

  ReferenceError: lyx is not defined

  › supported (node_modules/human-signals/src/main.js:9:3)
  › <anonymous> (node_modules/human-signals/src/main.js:24:34)

  ✖ test/kill.js exited with a non-zero exit code: 1
  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  ReferenceError: lyx is not defined

  › supported (node_modules/human-signals/src/main.js:9:3)
  › <anonymous> (node_modules/human-signals/src/main.js:24:34)

  Uncaught exception in test/promise.js

  ReferenceError: lyx is not defined

  › supported (node_modules/human-signals/src/main.js:9:3)
  › <anonymous> (node_modules/human-signals/src/main.js:24:34)

  ✖ test/promise.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }

  Uncaught exception in test/stream.js

  ReferenceError: lyx is not defined

  › supported (node_modules/human-signals/src/main.js:9:3)
  › <anonymous> (node_modules/human-signals/src/main.js:24:34)

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  ReferenceError: lyx is not defined

  › supported (node_modules/human-signals/src/main.js:9:3)
  › <anonymous> (node_modules/human-signals/src/main.js:24:34)

  ✖ test/test.js exited with a non-zero exit code: 1

  ✖ Timed out while running tests

  ─

  36 tests passed
  8 uncaught exceptions
-------------|---------|----------|---------|---------|---------------------------------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                           
-------------|---------|----------|---------|---------|---------------------------------------------
All files    |   27.32 |      100 |    8.33 |   27.32 |                                             
 execa       |    13.1 |      100 |       0 |    13.1 |                                             
  index.js   |    13.1 |      100 |       0 |    13.1 | ...2,76-162,165-225,228-230,233-235,238-267 
 execa/lib   |   36.84 |      100 |   10.71 |   36.84 |                                             
  command.js |    43.9 |      100 |       0 |    43.9 | 2-6,13-17,28-40                             
  error.js   |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                  
  kill.js    |   36.27 |      100 |       0 |   36.27 | ...-29,38-46,51-55,59-60,65-80,84-86,91-101 
  promise.js |   30.55 |      100 |       0 |   30.55 | 3-4,9-18,23-35                              
  stdio.js   |     100 |      100 |     100 |     100 |                                             
  stream.js  |   29.06 |      100 |       0 |   29.06 | 7-15,20-34,39-49,53-61,66-79,83-85          
-------------|---------|----------|---------|---------|---------------------------------------------
./VariantsDeps/execa/variant10/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (961ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.7s)
  ✔ error › result.killed is false if not killed, in sync mode (883ms)
  ✔ error › result.killed is false on process error, in sync mode (175ms)
  ✔ error › Original error.message is kept (1.3s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (268ms)
  ✔ error › stdout/stderr/all on process errors (1.8s)
  ✔ error › stdout/stderr/all available on errors (2s)
  ✔ error › exitCode is 0 on success (1.9s)
  ✔ error › exitCode is 2 (1.8s)
  ✔ error › exitCode is 3 (1.8s)
  ✔ error › exitCode is 4 (1.7s)
  ✔ error › error.message contains the command (1.7s)
  ✔ error › error.message contains stdout/stderr if available (1.6s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.5s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.5s)
  ✔ error › failed is false on success (1.5s)
  ✔ error › failed is true on failure (1.3s)
  ✔ error › error.killed is true if process was killed directly (1.3s)
  ✔ error › error.killed is false if process was killed indirectly (1.3s)
  ✔ error › result.killed is false if not killed (1.1s)
  ✔ error › error.signal is SIGINT (399ms)
  ✔ error › error.signalDescription is defined (393ms)
  ✔ error › error.signal is SIGTERM (387ms)
  ✔ error › exitCode is undefined on signal termination (375ms)
  ✔ error › custom error.signal (397ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (417ms)
  ✔ error › result.signal is undefined for successful execution (447ms)
  ✔ error › result.signalDescription is undefined for successful execution (459ms)
  ✔ error › error.code is undefined on success (449ms)
  ✔ command › allow commands with spaces and no array arguments (2.4s)
  ✔ command › allow commands with spaces and array arguments (2.4s)
  ✔ command › execaCommand() (2.4s)
  ✔ command › execaCommand() ignores consecutive spaces (2.3s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.3s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.2s)
  ✔ command › execaCommand() escapes other whitespaces (2.1s)
  ✔ command › execaCommand() trims (2s)
  ✔ command › command is: " foo bar" (2.6s)
  ✔ command › command is: " baz quz" (2.6s)
  ✔ command › command is: "" (2.6s)
  ✔ command › escapedCommand is: "foo bar" (2.7s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.9s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3s)
  ✔ command › escapedCommand is: "\"*\"" (3.1s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (2.8s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.8s)
  ✔ kill › execa() returns a promise with kill() (2.8s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.6s)
  ✔ kill › cancel method kills the subprocess (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (1.9s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (823ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (2.7s)
  ✔ kill › timeout must not be negative (2.7s)
  ✔ kill › timeout must be an integer (2.7s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel (118ms)
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (135ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (168ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (179ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3s)
  ✔ kill › timeout does not kill the process if it does not time out (2.8s)
  ✔ kill › timedOut is false if timeout is undefined (2.8s)
  ✔ kill › timedOut is false if timeout is 0 (2.8s)
  ✔ kill › spawnAndExit (2.4s)
  ✔ kill › spawnAndExit cleanup (2.4s)
  ✔ kill › spawnAndExit detached (2.4s)
  ✔ kill › spawnAndExit cleanup detached (2.4s)
  ✔ kill › spawnAndKill SIGTERM (2.4s)
  ✔ kill › spawnAndKill SIGKILL (2.3s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.3s)
  ✔ kill › spawnAndKill detached SIGTERM (2.3s)
  ✔ kill › spawnAndKill detached SIGKILL (2.3s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.2s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.2s)
  ✔ kill › removes exit handler on exit (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.1s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (324ms)
  ✔ kill › error.isCanceled is true when cancel method is used (310ms)
  ✔ kill › error.isCanceled is false when kill method is used (305ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (299ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (293ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (289ms)
  ✔ kill › timeout kills the process if it times out (2.9s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.1s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.1s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.3s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (305ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (146ms)
  ✔ node › node pass on nodeOptions (167ms)
  ✔ node › node pipe stdout (206ms)
  ✔ node › node's forked script has a communication channel (172ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on failure (240ms)
  ✔ promise › finally function is executed on success (259ms)
  ✔ promise › throw in finally bubbles up on error (212ms)
  ✔ promise › throw in finally function bubbles up on success (236ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8s)
  ✔ kill › kill() with no arguments should kill after a timeout (7.9s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.2s)
  ✔ stream › input option can be a String - sync (788ms)
  ✔ stream › input option can be a Buffer - sync (541ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (304ms)
  ✔ stream › buffer (1.3s)
  ✔ stream › pass `stdout` to a file descriptor (1.4s)
  ✔ stream › pass `stderr` to a file descriptor (1.3s)
  ✔ stream › result.all is undefined unless opts.all is true (1.3s)
  ✔ stream › stdout/stderr/all are undefined if ignored (1.3s)
  ✔ stream › you can write to child.stdin (1s)
  ✔ stream › input can be a Stream (1s)
  ✔ stream › input option can be a String (1.1s)
  ✔ stream › input option can be a Buffer (1.1s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (667ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (739ms)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (762ms)
  ✔ stream › buffer: false > promise resolves (734ms)
  ✔ stream › do not buffer when streaming (783ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (819ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (751ms)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (850ms)
  ✔ stream › can use all: true with stdout: ignore (797ms)
  ✔ stream › can use all: true with stderr: ignore (796ms)
  ✔ stream › maxBuffer affects stderr (1s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (956ms)
  ✔ stream › maxBuffer affects stdout (1s)
  ✔ test › execaSync() (2.8s)
  ✔ test › execaSync() throws error if written to stderr (2.3s)
  ✔ test › skip throwing when using reject option in sync mode (2.3s)
  ✔ test › stripFinalNewline in sync mode (1.9s)
  ✔ test › stripFinalNewline in sync mode on failure (1.5s)
  ✔ test › execa() returns a promise with pid (652ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (641ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (605ms)
  ✔ test › child_process.spawn() errors are propagated (659ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (586ms)
  ✔ test › execa() rejects if running non-executable (607ms)
  ✔ test › preferLocal: undefined (908ms)
  ✔ test › preferLocal: false (935ms)
  ✔ test › child process errors rejects promise right away (815ms)
  ✔ test › child process errors are handled (829ms)
  ✔ test › stdin errors are handled (848ms)
  ✔ test › execa() (3.1s)
  ✔ test › skip throwing when using reject option (2.6s)
  ✔ test › stripFinalNewline: true (2.3s)
  ✔ test › stripFinalNewline: false (2.3s)
  ✔ test › stripFinalNewline on failure (2.2s)
  ✔ test › localDir option (1s)
  ✔ test › do not try to consume streams twice (897ms)
  ✔ test › use relative path with '..' chars (867ms)
  ✔ test › write to fast-exit process (766ms)
  ✔ test › localDir option can be a URL (567ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (380ms)
  ✔ test › can use `options.cwd` as a string (621ms)
  ✔ test › extend environment variables by default (730ms)
  ✔ test › do not extend environment with `extendEnv: false` (703ms)
  ✔ test › can use `options.cwd` as a URL (580ms)
  ✔ test › use environment variables by default (761ms)
  ✔ test › can use `options.shell: true` (570ms)
  ✔ test › can use `options.shell: string` (542ms)
  ✔ test › execPath option (1.2s)
  ✔ test › detach child process (619ms)
  ✔ test › preferLocal: true (1.6s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsDeps/execa/variant9/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (867ms)
  ✖ command › command is: " foo bar" Rejected promise returned by test
  ✖ command › command is: " baz quz" Rejected promise returned by test
  ✖ command › command is: "" Rejected promise returned by test
  ✖ command › escapedCommand is: "foo bar" Rejected promise returned by test
  ✖ command › escapedCommand is: "\"foo bar\"" Rejected promise returned by test
  ✖ command › escapedCommand is: "\"\\\"foo\\\"\"" Rejected promise returned by test
  ✖ command › escapedCommand is: "\"*\"" Rejected promise returned by test
  ✖ command › allow commands with spaces and no array arguments Rejected promise returned by test
  ✖ command › allow commands with spaces and array arguments Rejected promise returned by test
  ✖ command › execaCommand() Rejected promise returned by test
  ✖ command › execaCommand() ignores consecutive spaces Rejected promise returned by test
  ✖ command › execaCommand() allows escaping spaces in commands Rejected promise returned by test
  ✖ command › execaCommand() allows escaping spaces in arguments Rejected promise returned by test
  ✖ command › execaCommand() escapes other whitespaces Rejected promise returned by test
  ✖ command › execaCommand() trims Rejected promise returned by test
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.9s)
  ✔ error › result.killed is false if not killed, in sync mode (1.2s)
  ✔ error › result.killed is false on process error, in sync mode (222ms)
  ✖ error › stdout/stderr/all available on errors Rejected promise returned by test
  ✖ error › stdout/stderr/all on process errors Rejected promise returned by test
  ✖ error › exitCode is 0 on success Rejected promise returned by test
  ✖ error › exitCode is 2 Rejected promise returned by test
  ✖ error › exitCode is 3 Rejected promise returned by test
  ✖ error › exitCode is 4 Rejected promise returned by test
  ✖ error › error.message contains the command Rejected promise returned by test
  ✖ error › error.message contains stdout/stderr if available Rejected promise returned by test
  ✖ error › error.message does not contain stdout/stderr if not available Rejected promise returned by test
  ✖ error › error.shortMessage does not contain stdout/stderr Rejected promise returned by test
  ✖ error › failed is false on success Rejected promise returned by test
  ✖ error › failed is true on failure Rejected promise returned by test
  ✖ error › error.killed is true if process was killed directly Rejected promise returned by test
  ✖ error › error.killed is false if process was killed indirectly Rejected promise returned by test
  ✖ error › result.killed is false if not killed Rejected promise returned by test
  ✖ error › result.killed is false on process error Rejected promise returned by test
  ✖ error › error.signal is SIGINT Rejected promise returned by test
  ✖ error › error.signalDescription is defined Rejected promise returned by test
  ✖ error › error.signal is SIGTERM Rejected promise returned by test
  ✖ error › custom error.signal Rejected promise returned by test
  ✖ error › exitCode is undefined on signal termination Rejected promise returned by test
  ✖ error › result.signal is undefined for successful execution Rejected promise returned by test
  ✖ error › result.signal is undefined if process failed, but was not killed Rejected promise returned by test
  ✖ error › result.signalDescription is undefined for successful execution Rejected promise returned by test
  ✖ error › error.code is undefined on success Rejected promise returned by test
  ✔ error › Original error.message is kept (1.7s)
  ✔ error › error.code is defined on failure if applicable (137ms)

  Unhandled rejection in test/error.js

  Error: spawn wrong command ENOENT

  Unhandled rejection in test/error.js

  Error: spawn wrong command ENOENT

  ✖ node › node removes --inspect from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect=9222 from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect-brk from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node should not remove --inspect when passed through nodeOptions Rejected promise returned by test
  ✖ node › node() Rejected promise returned by test
  ✖ node › node pipe stdout Rejected promise returned by test
  ✖ node › node correctly use nodePath Rejected promise returned by test
  ✖ node › node pass on nodeOptions Rejected promise returned by test
  ✖ node › node's forked script has a communication channel Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout` should not be NaN 
  ✖ kill › `forceKillAfterTimeout` should not be negative 
  ✖ kill › execa() returns a promise with kill() Error thrown in test
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3.1s)
  ✖ kill › cancel method kills the subprocess Error thrown in test
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (975ms)
  ✖ kill › kill("SIGKILL") should terminate cleanly Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout: false` should not kill after a timeout Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout: number` should kill after a timeout Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout: true` should kill after a timeout Rejected promise returned by test
  ✖ kill › kill() with no arguments should kill after a timeout Rejected promise returned by test
  ✖ kill › timeout kills the process if it times out Rejected promise returned by test
  ✖ kill › timeout does not kill the process if it does not time out Rejected promise returned by test
  ✖ kill › timedOut is false if timeout is undefined Rejected promise returned by test
  ✖ kill › timedOut is false if timeout is 0 Rejected promise returned by test
  ✖ kill › spawnAndExit Rejected promise returned by test
  ✖ kill › spawnAndExit cleanup Rejected promise returned by test
  ✖ kill › spawnAndExit detached Rejected promise returned by test
  ✖ kill › spawnAndExit cleanup detached Rejected promise returned by test
  ✖ kill › spawnAndKill SIGTERM Rejected promise returned by test
  ✖ kill › spawnAndKill SIGKILL Rejected promise returned by test
  ✖ kill › spawnAndKill cleanup SIGTERM Rejected promise returned by test
  ✖ kill › spawnAndKill cleanup SIGKILL Rejected promise returned by test
  ✖ kill › spawnAndKill detached SIGTERM Rejected promise returned by test
  ✖ kill › spawnAndKill detached SIGKILL Rejected promise returned by test
  ✖ kill › spawnAndKill cleanup detached SIGTERM Rejected promise returned by test
  ✖ kill › spawnAndKill cleanup detached SIGKILL Rejected promise returned by test
  ✖ kill › removes exit handler on exit Rejected promise returned by test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called (success) Rejected promise returned by test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) Rejected promise returned by test
  ✖ kill › calling cancel method throws an error with message "Command was canceled" Rejected promise returned by test
  ✖ kill › error.isCanceled is true when cancel method is used Rejected promise returned by test
  ✖ kill › error.isCanceled is false when kill method is used Rejected promise returned by test
  ✖ kill › calling cancel method twice should show the same behaviour as calling it once Rejected promise returned by test
  ✖ kill › calling cancel method on a successfully completed process does not make result.isCanceled true Rejected promise returned by test
  ✖ kill › calling cancel method on a process which has been killed does not make error.isCanceled true Rejected promise returned by test
  ✖ kill › calling abort throws an error with message "Command was canceled" Rejected promise returned by test
  ✖ kill › calling abort twice should show the same behaviour as calling it once Rejected promise returned by test
  ✖ kill › calling abort on a successfully completed process does not make result.isCanceled true Rejected promise returned by test
  ✖ kill › calling cancel after abort should show the same behaviour as only calling cancel Rejected promise returned by test
  ✖ kill › calling abort after cancel should show the same behaviour as only calling cancel Rejected promise returned by test
  ✔ kill › timeout kills the process if it times out, in sync mode (3.3s)
  ✔ kill › timeout must not be negative (3.3s)
  ✔ kill › timeout must be an integer (3.3s)
  ✖ override-promise › should work with third-party Promise Rejected promise returned by test
  ✖ promise › promise methods are not enumerable Error thrown in test
  ✖ promise › finally function is executed on success Rejected promise returned by test
  ✖ promise › finally function is executed on failure Rejected promise returned by test
  ✖ promise › throw in finally function bubbles up on success Rejected promise returned by test
  ✖ promise › throw in finally bubbles up on error Rejected promise returned by test
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✖ stream › result.all shows both `stdout` and `stderr` intermixed Rejected promise returned by test
  ✖ stream › buffer: false > promise does not resolve when output is big and is not read Rejected promise returned by test
  ✖ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read Rejected promise returned by test
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.1s)
  ✔ stream › input option can be a String - sync (666ms)
  ✔ stream › input option can be a Buffer - sync (419ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (293ms)
  ✖ stream › buffer Rejected promise returned by test
  ✖ stream › pass `stdout` to a file descriptor Rejected promise returned by test
  ✖ stream › pass `stderr` to a file descriptor Rejected promise returned by test
  ✖ stream › result.all is undefined unless opts.all is true Rejected promise returned by test
  ✖ stream › stdout/stderr/all are undefined if ignored Rejected promise returned by test
  ✖ stream › input option can be a String Rejected promise returned by test
  ✖ stream › input option can be a Buffer Rejected promise returned by test
  ✖ stream › input can be a Stream Rejected promise returned by test
  ✖ stream › you can write to child.stdin Rejected promise returned by test
  ✖ stream › opts.stdout:ignore - stdout will not collect data Rejected promise returned by test
  ✖ stream › maxBuffer affects stdout Rejected promise returned by test
  ✖ stream › maxBuffer affects stderr Rejected promise returned by test
  ✖ stream › do not buffer stdout when `buffer` set to `false` Rejected promise returned by test
  ✖ stream › do not buffer stderr when `buffer` set to `false` Rejected promise returned by test
  ✖ stream › do not buffer when streaming Rejected promise returned by test
  ✖ stream › buffer: false > promise resolves Rejected promise returned by test
  ✖ stream › buffer: false > promise resolves when output is big but is not pipable Rejected promise returned by test
  ✖ stream › buffer: false > promise resolves when output is big and is read Rejected promise returned by test
  ✖ stream › buffer: false > promise resolves when output is big and "all" is used and is read Rejected promise returned by test
  ✖ stream › buffer: false > promise rejects when process returns non-zero Rejected promise returned by test
  ✖ stream › can use all: true with stdout: ignore Rejected promise returned by test
  ✖ stream › can use all: true with stderr: ignore Rejected promise returned by test
  ✔ test › execaSync() (1s)
  ✔ test › execaSync() throws error if written to stderr (942ms)
  ✔ test › skip throwing when using reject option in sync mode (928ms)
  ✔ test › stripFinalNewline in sync mode (804ms)
  ✔ test › stripFinalNewline in sync mode on failure (607ms)
  ✖ test › execa() returns a promise with pid Error thrown in test
  ✔ test › child_process.spawn() propagated errors have correct shape (481ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (443ms)
  ✖ test › execa() Rejected promise returned by test
  ✖ test › skip throwing when using reject option Rejected promise returned by test
  ✖ test › stripFinalNewline: true Rejected promise returned by test
  ✖ test › stripFinalNewline: false Rejected promise returned by test
  ✖ test › stripFinalNewline on failure Rejected promise returned by test
  ✖ test › preferLocal: true Rejected promise returned by test
  ✖ test › preferLocal: false Rejected promise returned by test
  ✖ test › preferLocal: undefined Rejected promise returned by test
  ✖ test › localDir option Rejected promise returned by test
  ✖ test › stdin errors are handled Rejected promise returned by test
  ✖ test › child process errors are handled Rejected promise returned by test
  ✖ test › child process errors rejects promise right away Rejected promise returned by test
  ✖ test › do not try to consume streams twice Rejected promise returned by test
  ✖ test › use relative path with '..' chars Rejected promise returned by test
  ✖ test › execa() rejects if running non-executable Rejected promise returned by test
  ✖ test › execa() rejects with correct error and doesn't throw if running non-executable with input Rejected promise returned by test
  ✖ test › write to fast-exit process 
  ✖ test › use environment variables by default Rejected promise returned by test
  ✖ test › extend environment variables by default Rejected promise returned by test
  ✖ test › do not extend environment with `extendEnv: false` Rejected promise returned by test
  ✖ test › can use `options.cwd` as a string Rejected promise returned by test
  ✖ test › localDir option can be a URL Rejected promise returned by test
  ✖ test › can use `options.cwd` as a URL Rejected promise returned by test
  ✖ test › can use `options.shell: true` Rejected promise returned by test
  ✖ test › can use `options.shell: string` Rejected promise returned by test
  ✖ test › use extend environment with `extendEnv: true` and `shell: true` Rejected promise returned by test
  ✖ test › detach child process Rejected promise returned by test
  ✔ test › child_process.spawn() errors are propagated (609ms)
  ✖ test › execPath option Rejected promise returned by test

  Unhandled rejection in test/test.js

  Error: spawn ava ENOENT

  Unhandled rejection in test/test.js

  Error: spawn ava ENOENT

  Unhandled rejection in test/test.js

  Error: spawn non-executable.js EACCES

  Unhandled rejection in test/test.js

  Error: spawn non-executable.js EACCES

  ─

  command › command is: " foo bar"

  test/command.js:8

   7: const command = async (t, expected, ...args) => {                         
   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › command (file://test/command.js:8:53)



  command › command is: " baz quz"

  test/command.js:8

   7: const command = async (t, expected, ...args) => {                         
   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › command (file://test/command.js:8:53)



  command › command is: ""

  test/command.js:8

   7: const command = async (t, expected, ...args) => {                         
   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › command (file://test/command.js:8:53)



  command › escapedCommand is: "foo bar"

  test/command.js:22

   21: const testEscapedCommand = async (t, expected, args) => {                
   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testEscapedCommand (file://test/command.js:22:67)



  command › escapedCommand is: "\"foo bar\""

  test/command.js:22

   21: const testEscapedCommand = async (t, expected, args) => {                
   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testEscapedCommand (file://test/command.js:22:67)



  command › escapedCommand is: "\"\\\"foo\\\"\""

  test/command.js:22

   21: const testEscapedCommand = async (t, expected, args) => {                
   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testEscapedCommand (file://test/command.js:22:67)



  command › escapedCommand is: "\"*\""

  test/command.js:22

   21: const testEscapedCommand = async (t, expected, args) => {                
   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testEscapedCommand (file://test/command.js:22:67)



  command › allow commands with spaces and no array arguments

  test/command.js:45

   44: test('allow commands with spaces and no array arguments', async t => {
   45:   const {stdout} = await execa('command with space.js');              
   46:   t.is(stdout, '');                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/command.js:45:25



  command › allow commands with spaces and array arguments

  test/command.js:50

   49: test('allow commands with spaces and array arguments', async t => {     
   50:   const {stdout} = await execa('command with space.js', ['foo', 'bar']);
   51:   t.is(stdout, 'foo\nbar');                                             

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/command.js:50:25



  command › execaCommand()

  test/command.js:55

   54: test('execaCommand()', async t => {                                      
   55:   const {stdout} = await execaCommand('node test/fixtures/echo.js foo ba…
   56:   t.is(stdout, 'foo\nbar');                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:55:25



  command › execaCommand() ignores consecutive spaces

  test/command.js:60

   59: test('execaCommand() ignores consecutive spaces', async t => {           
   60:   const {stdout} = await execaCommand('node test/fixtures/echo.js foo   …
   61:   t.is(stdout, 'foo\nbar');                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:60:25



  command › execaCommand() allows escaping spaces in commands

  test/command.js:65

   64: test('execaCommand() allows escaping spaces in commands', async t => {   
   65:   const {stdout} = await execaCommand('command\\ with\\ space.js foo bar…
   66:   t.is(stdout, 'foo\nbar');                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:65:25



  command › execaCommand() allows escaping spaces in arguments

  test/command.js:70

   69: test('execaCommand() allows escaping spaces in arguments', async t => {  
   70:   const {stdout} = await execaCommand('node test/fixtures/echo.js foo\\ …
   71:   t.is(stdout, 'foo bar');                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:70:25



  command › execaCommand() escapes other whitespaces

  test/command.js:75

   74: test('execaCommand() escapes other whitespaces', async t => {            
   75:   const {stdout} = await execaCommand('node test/fixtures/echo.js foo\tb…
   76:   t.is(stdout, 'foo\tbar');                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:75:25



  command › execaCommand() trims

  test/command.js:80

   79: test('execaCommand() trims', async t => {                                
   80:   const {stdout} = await execaCommand('  node test/fixtures/echo.js foo …
   81:   t.is(stdout, 'foo\nbar');                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:80:25



  error › stdout/stderr/all available on errors

  test/error.js:17

   16: test('stdout/stderr/all available on errors', async t => {               
   17:   const {stdout, stderr, all} = await t.throwsAsync(execa('exit.js', ['2…
   18:   t.is(typeof stdout, 'string');                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:17:52



  error › stdout/stderr/all on process errors

  test/error.js:28

   27: test('stdout/stderr/all on process errors', async t => {                 
   28:   const {stdout, stderr, all} = await t.throwsAsync(execa('wrong command…
   29:   t.is(stdout, '');                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:28:52



  error › exitCode is 0 on success

  test/error.js:44

   43: test('exitCode is 0 on success', async t => {        
   44:   const {exitCode} = await execa('noop.js', ['foo']);
   45:   t.is(exitCode, 0);                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:44:27



  error › exitCode is 2

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testExitCode (file://test/error.js:49:41)



  error › exitCode is 3

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testExitCode (file://test/error.js:49:41)



  error › exitCode is 4

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testExitCode (file://test/error.js:49:41)



  error › error.message contains the command

  test/error.js:58

   57: test('error.message contains the command', async t => {                  
   58:   await t.throwsAsync(execa('exit.js', ['2', 'foo', 'bar']), {message: /…
   59: });                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:58:22



  error › error.message contains stdout/stderr if available

  test/error.js:62

   61: test('error.message contains stdout/stderr if available', async t => {
   62:   const {message} = await t.throwsAsync(execa('echo-fail.js'));       
   63:   t.true(message.includes('stderr'));                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:62:40



  error › error.message does not contain stdout/stderr if not available

  test/error.js:68

   67: test('error.message does not contain stdout/stderr if not available', as…
   68:   const {message} = await t.throwsAsync(execa('echo-fail.js', {stdio: 'i…
   69:   t.false(message.includes('stderr'));                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:68:40



  error › error.shortMessage does not contain stdout/stderr

  test/error.js:74

   73: test('error.shortMessage does not contain stdout/stderr', async t => {
   74:   const {shortMessage} = await t.throwsAsync(execa('echo-fail.js'));  
   75:   t.false(shortMessage.includes('stderr'));                           

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:74:45



  error › failed is false on success

  test/error.js:85

   84: test('failed is false on success', async t => {    
   85:   const {failed} = await execa('noop.js', ['foo']);
   86:   t.false(failed);                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:85:25



  error › failed is true on failure

  test/error.js:90

   89: test('failed is true on failure', async t => {                  
   90:   const {failed} = await t.throwsAsync(execa('exit.js', ['2']));
   91:   t.true(failed);                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:90:39



  error › error.killed is true if process was killed directly

  test/error.js:95

   94: test('error.killed is true if process was killed directly', async t => {
   95:   const subprocess = execa('noop.js');                                  
   96:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:95:21



  error › error.killed is false if process was killed indirectly

  test/error.js:104

   103: test('error.killed is false if process was killed indirectly', async t …
   104:   const subprocess = execa('noop.js');                                  
   105:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:104:21



  error › result.killed is false if not killed

  test/error.js:115

   114: test('result.killed is false if not killed', async t => {
   115:   const {killed} = await execa('noop.js');               
   116:   t.false(killed);                                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:115:25



  error › result.killed is false on process error

  test/error.js:125

   124: test('result.killed is false on process error', async t => {   
   125:   const {killed} = await t.throwsAsync(execa('wrong command'));
   126:   t.false(killed);                                             

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:125:39



  error › error.signal is SIGINT

  test/error.js:150

   149:   test('error.signal is SIGINT', async t => {
   150:     const subprocess = execa('noop.js');     
   151:                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:150:22



  error › error.signalDescription is defined

  test/error.js:159

   158:   test('error.signalDescription is defined', async t => {
   159:     const subprocess = execa('noop.js');                 
   160:                                                          

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:159:22



  error › error.signal is SIGTERM

  test/error.js:168

   167:   test('error.signal is SIGTERM', async t => {
   168:     const subprocess = execa('noop.js');      
   169:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:168:22



  error › custom error.signal

  test/error.js:177

   176:   test('custom error.signal', async t => {                              
   177:     const {signal} = await t.throwsAsync(execa('noop.js', {killSignal: …
   178:     t.is(signal, 'SIGHUP');                                             

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:177:40



  error › exitCode is undefined on signal termination

  test/error.js:182

   181:   test('exitCode is undefined on signal termination', async t => {
   182:     const subprocess = execa('noop.js');                          
   183:                                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:182:22



  error › result.signal is undefined for successful execution

  test/error.js:192

   191: test('result.signal is undefined for successful execution', async t => {
   192:   const {signal} = await execa('noop.js');                              
   193:   t.is(signal, undefined);                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:192:25



  error › result.signal is undefined if process failed, but was not killed

  test/error.js:197

   196: test('result.signal is undefined if process failed, but was not killed'…
   197:   const {signal} = await t.throwsAsync(execa('exit.js', [2]), {message:…
   198:   t.is(signal, undefined);                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:197:39



  error › result.signalDescription is undefined for successful execution

  test/error.js:202

   201: test('result.signalDescription is undefined for successful execution', …
   202:   const {signalDescription} = await execa('noop.js');                   
   203:   t.is(signalDescription, undefined);                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:202:36



  error › error.code is undefined on success

  test/error.js:207

   206: test('error.code is undefined on success', async t => {
   207:   const {code} = await execa('noop.js');               
   208:   t.is(code, undefined);                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:207:23



  node › node removes --inspect from nodeOptions when defined by parent process

  test/node.js:13

   12:   try {                                                 
   13:     const subprocess = execaNode('console.log("foo")', {
   14:       reject: false,                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › inspectMacro (file://test/node.js:13:22)



  node › node removes --inspect=9222 from nodeOptions when defined by parent process

  test/node.js:13

   12:   try {                                                 
   13:     const subprocess = execaNode('console.log("foo")', {
   14:       reject: false,                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › inspectMacro (file://test/node.js:13:22)



  node › node removes --inspect-brk from nodeOptions when defined by parent process

  test/node.js:13

   12:   try {                                                 
   13:     const subprocess = execaNode('console.log("foo")', {
   14:       reject: false,                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › inspectMacro (file://test/node.js:13:22)



  node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process

  test/node.js:13

   12:   try {                                                 
   13:     const subprocess = execaNode('console.log("foo")', {
   14:       reject: false,                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › inspectMacro (file://test/node.js:13:22)



  node › node should not remove --inspect when passed through nodeOptions

  test/node.js:85

   84:   async t => {                                                      
   85:     const {stdout, stderr} = await execaNode('console.log("foo")', {
   86:       reject: false,                                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:85:34



  node › node()

  test/node.js:27

   26: test('node()', async t => {                                   
   27:   const {exitCode} = await execaNode('test/fixtures/noop.js');
   28:   t.is(exitCode, 0);                                          

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:27:27



  node › node pipe stdout

  test/node.js:32

   31: test('node pipe stdout', async t => {                                 
   32:   const {stdout} = await execaNode('test/fixtures/noop.js', ['foo'], {
   33:     stdout: 'pipe',                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:32:25



  node › node correctly use nodePath

  test/node.js:40

   39: test('node correctly use nodePath', async t => {                         
   40:   const {stdout} = await execaNode(process.platform === 'win32' ? 'hello…
   41:     stdout: 'pipe',                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:40:25



  node › node pass on nodeOptions

  test/node.js:50

   49: test('node pass on nodeOptions', async t => {             
   50:   const {stdout} = await execaNode('console.log("foo")', {
   51:     stdout: 'pipe',                                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:50:25



  node › node's forked script has a communication channel

  test/node.js:96

   95: test('node\'s forked script has a communication channel', async t => {
   96:   const subprocess = execaNode('test/fixtures/send.js');              
   97:   await pEvent(subprocess, 'message');                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:96:21



  kill › `forceKillAfterTimeout` should not be NaN

  test/kill.js:66

   65:   test('`forceKillAfterTimeout` should not be NaN', t => {               
   66:     t.throws(() => {                                                     
   67:       execa('noop.js').kill('SIGTERM', {forceKillAfterTimeout: Number.Na…

  Function threw unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected instance of:

  Function TypeError {}

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › t.throws.instanceOf (file://test/kill.js:67:4)
  › file://test/kill.js:66:5



  kill › `forceKillAfterTimeout` should not be negative

  test/kill.js:72

   71:   test('`forceKillAfterTimeout` should not be negative', t => {     
   72:     t.throws(() => {                                                
   73:       execa('noop.js').kill('SIGTERM', {forceKillAfterTimeout: -1});

  Function threw unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected instance of:

  Function TypeError {}

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › t.throws.instanceOf (file://test/kill.js:73:4)
  › file://test/kill.js:72:5



  kill › execa() returns a promise with kill()

  test/kill.js:79

   78: test('execa() returns a promise with kill()', t => {
   79:   const {kill} = execa('noop.js', ['foo']);         
   80:   t.is(typeof kill, 'function');                    

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:79:17



  kill › cancel method kills the subprocess

  test/kill.js:195

   194: test('cancel method kills the subprocess', t => {
   195:   const subprocess = execa('node');              
   196:   subprocess.cancel();                           

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:195:21



  kill › kill("SIGKILL") should terminate cleanly

  test/kill.js:13

   12: test('kill("SIGKILL") should terminate cleanly', async t => {            
   13:   const subprocess = execa('node', ['./test/fixtures/no-killable.js'], {…
   14:   await pEvent(subprocess, 'message');                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:13:21



  kill › `forceKillAfterTimeout: false` should not kill after a timeout

  test/kill.js:26

   25:   test('`forceKillAfterTimeout: false` should not kill after a timeout',…
   26:     const subprocess = execa('node', ['./test/fixtures/no-killable.js'],…
   27:     await pEvent(subprocess, 'message');                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:26:22



  kill › `forceKillAfterTimeout: number` should kill after a timeout

  test/kill.js:36

   35:   test('`forceKillAfterTimeout: number` should kill after a timeout', as…
   36:     const subprocess = execa('node', ['./test/fixtures/no-killable.js'],…
   37:     await pEvent(subprocess, 'message');                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:36:22



  kill › `forceKillAfterTimeout: true` should kill after a timeout

  test/kill.js:46

   45:   test('`forceKillAfterTimeout: true` should kill after a timeout', asyn…
   46:     const subprocess = execa('node', ['./test/fixtures/no-killable.js'],…
   47:     await pEvent(subprocess, 'message');                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:46:22



  kill › kill() with no arguments should kill after a timeout

  test/kill.js:56

   55:   test('kill() with no arguments should kill after a timeout', async t =…
   56:     const subprocess = execa('node', ['./test/fixtures/no-killable.js'],…
   57:     await pEvent(subprocess, 'message');                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:56:22



  kill › timeout kills the process if it times out

  test/kill.js:84

   83: test('timeout kills the process if it times out', async t => {           
   84:   const {killed, timedOut} = await t.throwsAsync(execa('noop.js', {timeo…
   85:   t.false(killed);                                                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:84:49



  kill › timeout does not kill the process if it does not time out

  test/kill.js:98

   97: test('timeout does not kill the process if it does not time out', async …
   98:   const {timedOut} = await execa('delay.js', ['500'], {timeout: 1e8});   
   99:   t.false(timedOut);                                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:98:27



  kill › timedOut is false if timeout is undefined

  test/kill.js:117

   116: test('timedOut is false if timeout is undefined', async t => {
   117:   const {timedOut} = await execa('noop.js');                  
   118:   t.false(timedOut);                                          

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:117:27



  kill › timedOut is false if timeout is 0

  test/kill.js:122

   121: test('timedOut is false if timeout is 0', async t => {    
   122:   const {timedOut} = await execa('noop.js', {timeout: 0});
   123:   t.false(timedOut);                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:122:27



  kill › spawnAndExit

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndExit (file://test/kill.js:133:25)



  kill › spawnAndExit cleanup

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndExit (file://test/kill.js:133:25)



  kill › spawnAndExit detached

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndExit (file://test/kill.js:133:25)



  kill › spawnAndExit cleanup detached

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndExit (file://test/kill.js:133:25)



  kill › spawnAndKill SIGTERM

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill SIGKILL

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill cleanup SIGTERM

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill cleanup SIGKILL

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill detached SIGTERM

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill detached SIGKILL

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill cleanup detached SIGTERM

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill cleanup detached SIGKILL

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › removes exit handler on exit

  test/kill.js:182

   181:                                                    
   182:   const subprocess = execa('noop.js');             
   183:   const listener = emitter.listeners('exit').pop();

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:182:21



  kill › result.isCanceled is false when spawned.cancel() isn't called (success)

  test/kill.js:201

   200: test('result.isCanceled is false when spawned.cancel() isn\'t called (s…
   201:   const {isCanceled} = await execa('noop.js');                          
   202:   t.false(isCanceled);                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:201:29



  kill › result.isCanceled is false when spawned.cancel() isn't called (failure)

  test/kill.js:206

   205: test('result.isCanceled is false when spawned.cancel() isn\'t called (f…
   206:   const {isCanceled} = await t.throwsAsync(execa('fail.js'));           
   207:   t.false(isCanceled);                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:206:43



  kill › calling cancel method throws an error with message "Command was canceled"

  test/kill.js:223

   222: test('calling cancel method throws an error with message "Command was c…
   223:   const subprocess = execa('noop.js');                                  
   224:   subprocess.cancel();                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:223:21



  kill › error.isCanceled is true when cancel method is used

  test/kill.js:229

   228: test('error.isCanceled is true when cancel method is used', async t => {
   229:   const subprocess = execa('noop.js');                                  
   230:   subprocess.cancel();                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:229:21



  kill › error.isCanceled is false when kill method is used

  test/kill.js:236

   235: test('error.isCanceled is false when kill method is used', async t => {
   236:   const subprocess = execa('noop.js');                                 
   237:   subprocess.kill();                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:236:21



  kill › calling cancel method twice should show the same behaviour as calling it once

  test/kill.js:243

   242: test('calling cancel method twice should show the same behaviour as cal…
   243:   const subprocess = execa('noop.js');                                  
   244:   subprocess.cancel();                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:243:21



  kill › calling cancel method on a successfully completed process does not make result.isCanceled true

  test/kill.js:252

   251: test('calling cancel method on a successfully completed process does no…
   252:   const subprocess = execa('noop.js');                                  
   253:   const {isCanceled} = await subprocess;                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:252:21



  kill › calling cancel method on a process which has been killed does not make error.isCanceled true

  test/kill.js:259

   258: test('calling cancel method on a process which has been killed does not…
   259:   const subprocess = execa('noop.js');                                  
   260:   subprocess.kill();                                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:259:21



  kill › calling abort throws an error with message "Command was canceled"

  test/kill.js:268

   267:     const abortController = new AbortController();                      
   268:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   269:     abortController.abort();                                            

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:268:22



  kill › calling abort twice should show the same behaviour as calling it once

  test/kill.js:275

   274:     const abortController = new AbortController();                      
   275:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   276:     abortController.abort();                                            

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:275:22



  kill › calling abort on a successfully completed process does not make result.isCanceled true

  test/kill.js:285

   284:     const abortController = new AbortController();                      
   285:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   286:     const {isCanceled} = await subprocess;                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:285:22



  kill › calling cancel after abort should show the same behaviour as only calling cancel

  test/kill.js:293

   292:     const abortController = new AbortController();                      
   293:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   294:     abortController.abort();                                            

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:293:22



  kill › calling abort after cancel should show the same behaviour as only calling cancel

  test/kill.js:303

   302:     const abortController = new AbortController();                      
   303:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   304:     subprocess.cancel();                                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:303:22



  override-promise › should work with third-party Promise

  test/override-promise.js:12

   11: test('should work with third-party Promise', async t => {
   12:   const {stdout} = await execa('noop.js', ['foo']);      
   13:   t.is(stdout, 'foo');                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/override-promise.js:12:25



  promise › promise methods are not enumerable

  test/promise.js:8

   7: test('promise methods are not enumerable', t => {                        
   8:   const descriptors = Object.getOwnPropertyDescriptors(execa('noop.js'));
   9:   t.false(descriptors.then.enumerable);                                  

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/promise.js:8:55



  promise › finally function is executed on success

  test/promise.js:16

   15:   let isCalled = false;                                           
   16:   const {stdout} = await execa('noop.js', ['foo']).finally(() => {
   17:     isCalled = true;                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/promise.js:16:25



  promise › finally function is executed on failure

  test/promise.js:25

   24:   let isError = false;                                                   
   25:   const {stdout, stderr} = await t.throwsAsync(execa('exit.js', ['2']).f…
   26:     isError = true;                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/promise.js:25:47



  promise › throw in finally function bubbles up on success

  test/promise.js:34

   33: test('throw in finally function bubbles up on success', async t => {     
   34:   const {message} = await t.throwsAsync(execa('noop.js', ['foo']).finall…
   35:     throw new Error('called');                                           

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/promise.js:34:40



  promise › throw in finally bubbles up on error

  test/promise.js:41

   40: test('throw in finally bubbles up on error', async t => {                
   41:   const {message} = await t.throwsAsync(execa('exit.js', ['2']).finally(…
   42:     throw new Error('called');                                           

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/promise.js:41:40



  stream › result.all shows both `stdout` and `stderr` intermixed

  test/stream.js:32

   31: test.serial('result.all shows both `stdout` and `stderr` intermixed', as…
   32:   const {all} = await execa('noop-132.js', {all: true});                 
   33:   t.is(all, '132');                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:32:22



  stream › buffer: false > promise does not resolve when output is big and is not read

  test/stream.js:189

   188:   test.serial('buffer: false > promise does not resolve when output is …
   189:     const {timedOut} = await t.throwsAsync(execa('max-buffer.js', {buff…
   190:     t.true(timedOut);                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:189:42



  stream › buffer: false > promise does not resolve when output is big and "all" is used but not read

  test/stream.js:194

   193:   test.serial('buffer: false > promise does not resolve when output is …
   194:     const subprocess = execa('max-buffer.js', {buffer: false, all: true…
   195:     subprocess.stdout.resume();                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:194:22



  stream › buffer

  test/stream.js:14

   13: test('buffer', async t => {                                          
   14:   const {stdout} = await execa('noop.js', ['foo'], {encoding: null});
   15:   t.true(Buffer.isBuffer(stdout));                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:14:25



  stream › pass `stdout` to a file descriptor

  test/stream.js:21

   20:   const file = tempfile('.txt');                                         
   21:   await execa('test/fixtures/noop.js', ['foo bar'], {stdout: fs.openSync…
   22:   t.is(fs.readFileSync(file, 'utf8'), 'foo bar\n');                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:21:8



  stream › pass `stderr` to a file descriptor

  test/stream.js:27

   26:   const file = tempfile('.txt');                                         
   27:   await execa('test/fixtures/noop-err.js', ['foo bar'], {stderr: fs.open…
   28:   t.is(fs.readFileSync(file, 'utf8'), 'foo bar\n');                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:27:8



  stream › result.all is undefined unless opts.all is true

  test/stream.js:37

   36: test('result.all is undefined unless opts.all is true', async t => {
   37:   const {all} = await execa('noop.js');                             
   38:   t.is(all, undefined);                                             

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:37:22



  stream › stdout/stderr/all are undefined if ignored

  test/stream.js:42

   41: test('stdout/stderr/all are undefined if ignored', async t => {          
   42:   const {stdout, stderr, all} = await execa('noop.js', {stdio: 'ignore',…
   43:   t.is(stdout, undefined);                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:42:38



  stream › input option can be a String

  test/stream.js:56

   55: test('input option can be a String', async t => {             
   56:   const {stdout} = await execa('stdin.js', {input: 'foobar'});
   57:   t.is(stdout, 'foobar');                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:56:25



  stream › input option can be a Buffer

  test/stream.js:61

   60: test('input option can be a Buffer', async t => {                
   61:   const {stdout} = await execa('stdin.js', {input: 'testing12'});
   62:   t.is(stdout, 'testing12');                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:61:25



  stream › input can be a Stream

  test/stream.js:69

   68:   stream.end();                                             
   69:   const {stdout} = await execa('stdin.js', {input: stream});
   70:   t.is(stdout, 'howdy');                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:69:25



  stream › you can write to child.stdin

  test/stream.js:74

   73: test('you can write to child.stdin', async t => {
   74:   const subprocess = execa('stdin.js');          
   75:   subprocess.stdin.end('unicorns');              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:74:21



  stream › opts.stdout:ignore - stdout will not collect data

  test/stream.js:91

   90: test('opts.stdout:ignore - stdout will not collect data', async t => {
   91:   const {stdout} = await execa('stdin.js', {                          
   92:     input: 'hello',                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:91:25



  stream › maxBuffer affects stdout

  test/stream.js:108

   107: test('maxBuffer affects stdout', async t => {                           
   108:   await t.notThrowsAsync(execa('max-buffer.js', ['stdout', '10'], {maxB…
   109:   const {stdout, all} = await t.throwsAsync(execa('max-buffer.js', ['st…

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:108:25



  stream › maxBuffer affects stderr

  test/stream.js:115

   114: test('maxBuffer affects stderr', async t => {                           
   115:   await t.notThrowsAsync(execa('max-buffer.js', ['stderr', '10'], {maxB…
   116:   const {stderr, all} = await t.throwsAsync(execa('max-buffer.js', ['st…

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:115:25



  stream › do not buffer stdout when `buffer` set to `false`

  test/stream.js:122

   121: test('do not buffer stdout when `buffer` set to `false`', async t => {  
   122:   const promise = execa('max-buffer.js', ['stdout', '10'], {buffer: fal…
   123:   const [result, stdout] = await Promise.all([                          

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:122:18



  stream › do not buffer stderr when `buffer` set to `false`

  test/stream.js:133

   132: test('do not buffer stderr when `buffer` set to `false`', async t => {  
   133:   const promise = execa('max-buffer.js', ['stderr', '10'], {buffer: fal…
   134:   const [result, stderr] = await Promise.all([                          

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:133:18



  stream › do not buffer when streaming

  test/stream.js:144

   143: test('do not buffer when streaming', async t => {                       
   144:   const {stdout} = execa('max-buffer.js', ['stdout', '21'], {maxBuffer:…
   145:   const result = await getStream(stdout);                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:144:19



  stream › buffer: false > promise resolves

  test/stream.js:150

   149: test('buffer: false > promise resolves', async t => {       
   150:   await t.notThrowsAsync(execa('noop.js', {buffer: false}));
   151: });                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:150:25



  stream › buffer: false > promise resolves when output is big but is not pipable

  test/stream.js:154

   153: test('buffer: false > promise resolves when output is big but is not pi…
   154:   await t.notThrowsAsync(execa('max-buffer.js', {buffer: false, stdout:…
   155: });                                                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:154:25



  stream › buffer: false > promise resolves when output is big and is read

  test/stream.js:158

   157: test('buffer: false > promise resolves when output is big and is read',…
   158:   const subprocess = execa('max-buffer.js', {buffer: false});           
   159:   subprocess.stdout.resume();                                           

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:158:21



  stream › buffer: false > promise resolves when output is big and "all" is used and is read

  test/stream.js:165

   164: test('buffer: false > promise resolves when output is big and "all" is …
   165:   const subprocess = execa('max-buffer.js', {buffer: false, all: true});
   166:   subprocess.all.resume();                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:165:21



  stream › buffer: false > promise rejects when process returns non-zero

  test/stream.js:171

   170: test('buffer: false > promise rejects when process returns non-zero', a…
   171:   const subprocess = execa('fail.js', {buffer: false});                 
   172:   const {exitCode} = await t.throwsAsync(subprocess);                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:171:21



  stream › can use all: true with stdout: ignore

  test/stream.js:177

   176: test('can use all: true with stdout: ignore', async t => {              
   177:   await t.notThrowsAsync(execa('max-buffer.js', {buffer: false, stdout:…
   178: });                                                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:177:25



  stream › can use all: true with stderr: ignore

  test/stream.js:181

   180: test('can use all: true with stderr: ignore', async t => {              
   181:   await t.notThrowsAsync(execa('max-buffer.js', ['stderr'], {buffer: fa…
   182: });                                                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:181:25



  test › execa() returns a promise with pid

  test/test.js:131

   130: test('execa() returns a promise with pid', t => {
   131:   const {pid} = execa('noop.js', ['foo']);       
   132:   t.is(typeof pid, 'number');                    

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:131:16



  test › execa()

  test/test.js:16

   15: test('execa()', async t => {                       
   16:   const {stdout} = await execa('noop.js', ['foo']);
   17:   t.is(stdout, 'foo');                             

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:16:25



  test › skip throwing when using reject option

  test/test.js:44

   43: test('skip throwing when using reject option', async t => {  
   44:   const {exitCode} = await execa('fail.js', {reject: false});
   45:   t.is(exitCode, 2);                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:44:27



  test › stripFinalNewline: true

  test/test.js:54

   53: test('stripFinalNewline: true', async t => {       
   54:   const {stdout} = await execa('noop.js', ['foo']);
   55:   t.is(stdout, 'foo');                             

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:54:25



  test › stripFinalNewline: false

  test/test.js:59

   58: test('stripFinalNewline: false', async t => {                            
   59:   const {stdout} = await execa('noop.js', ['foo'], {stripFinalNewline: f…
   60:   t.is(stdout, 'foo\n');                                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:59:25



  test › stripFinalNewline on failure

  test/test.js:64

   63: test('stripFinalNewline on failure', async t => {                        
   64:   const {stderr} = await t.throwsAsync(execa('noop-throw.js', ['foo'], {…
   65:   t.is(stderr, 'foo');                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:64:39



  test › preferLocal: true

  test/test.js:88

   87: test('preferLocal: true', async t => {                                   
   88:   await t.notThrowsAsync(execa('ava', ['--version'], {preferLocal: true,…
   89: });                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:88:25



  test › preferLocal: false

  test/test.js:92

   91: test('preferLocal: false', async t => {                                  
   92:   await t.throwsAsync(execa('ava', ['--version'], {preferLocal: false, e…
   93: });                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:92:22



  test › preferLocal: undefined

  test/test.js:96

   95: test('preferLocal: undefined', async t => {                              
   96:   await t.throwsAsync(execa('ava', ['--version'], {env: getPathWithoutLo…
   97: });                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:96:22



  test › localDir option

  test/test.js:101

   100:   const command = process.platform === 'win32' ? 'echo %PATH%' : 'echo …
   101:   const {stdout} = await execa(command, {shell: true, preferLocal: true…
   102:   const envPaths = stdout.split(path.delimiter);                        

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:101:25



  test › stdin errors are handled

  test/test.js:113

   112: test('stdin errors are handled', async t => {       
   113:   const subprocess = execa('noop.js');              
   114:   subprocess.stdin.emit('error', new Error('test'));

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:113:21



  test › child process errors are handled

  test/test.js:119

   118: test('child process errors are handled', async t => {
   119:   const subprocess = execa('noop.js');               
   120:   subprocess.emit('error', new Error('test'));       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:119:21



  test › child process errors rejects promise right away

  test/test.js:125

   124: test('child process errors rejects promise right away', async t => {
   125:   const subprocess = execa('noop.js');                              
   126:   subprocess.emit('error', new Error('test'));                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:125:21



  test › do not try to consume streams twice

  test/test.js:157

   156: test('do not try to consume streams twice', async t => {
   157:   const subprocess = execa('noop.js', ['foo']);         
   158:   const {stdout} = await subprocess;                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:157:21



  test › use relative path with '..' chars

  test/test.js:166

   165:   const pathViaParentDir = path.join('..', path.basename(fileURLToPath(…
   166:   const {stdout} = await execa(pathViaParentDir, ['foo']);              
   167:   t.is(stdout, 'foo');                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:166:25



  test › execa() rejects if running non-executable

  test/test.js:172

   171:   test('execa() rejects if running non-executable', async t => {
   172:     const subprocess = execa('non-executable.js');              
   173:     await t.throwsAsync(subprocess);                            

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:172:22



  test › execa() rejects with correct error and doesn't throw if running non-executable with input

  test/test.js:177

   176:   test('execa() rejects with correct error and doesn\'t throw if runnin…
   177:     await t.throwsAsync(execa('non-executable.js', {input: 'Hey!'}), {m…
   178:   });                                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:177:23



  test › write to fast-exit process

  test/test.js:189

   188:     } catch (error) {           
   189:       t.is(error.code, 'EPIPE');
   190:     }                           

  Difference:

  - undefined
  + 'EPIPE'

  › file://test/test.js:189:6



  test › use environment variables by default

  test/test.js:195

   194: test('use environment variables by default', async t => {
   195:   const {stdout} = await execa('environment.js');        
   196:   t.deepEqual(stdout.split('\n'), ['foo', 'undefined']); 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:195:25



  test › extend environment variables by default

  test/test.js:200

   199: test('extend environment variables by default', async t => {            
   200:   const {stdout} = await execa('environment.js', [], {env: {BAR: 'bar',…
   201:   t.deepEqual(stdout.split('\n'), ['foo', 'bar']);                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:200:25



  test › do not extend environment with `extendEnv: false`

  test/test.js:205

   204: test('do not extend environment with `extendEnv: false`', async t => {  
   205:   const {stdout} = await execa('environment.js', [], {env: {BAR: 'bar',…
   206:   t.deepEqual(stdout.split('\n'), ['undefined', 'bar']);                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:205:25



  test › can use `options.cwd` as a string

  test/test.js:211

   210:   const cwd = '/';                                                     
   211:   const {stdout} = await execa('node', ['-p', 'process.cwd()'], {cwd});
   212:   t.is(path.toNamespacedPath(stdout), path.toNamespacedPath(cwd));     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:211:25



  test › localDir option can be a URL

  test/test.js:217

   216:   const command = process.platform === 'win32' ? 'echo %PATH%' : 'echo …
   217:   const {stdout} = await execa(command, {shell: true, preferLocal: true…
   218:   const envPaths = stdout.split(path.delimiter);                        

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:217:25



  test › can use `options.cwd` as a URL

  test/test.js:225

   224:   const cwdUrl = pathToFileURL(cwd);                                    
   225:   const {stdout} = await execa('node', ['-p', 'process.cwd()'], {cwd: c…
   226:   t.is(path.toNamespacedPath(stdout), path.toNamespacedPath(cwd));      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:225:25



  test › can use `options.shell: true`

  test/test.js:230

   229: test('can use `options.shell: true`', async t => {                      
   230:   const {stdout} = await execa('node test/fixtures/noop.js foo', {shell…
   231:   t.is(stdout, 'foo');                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:230:25



  test › can use `options.shell: string`

  test/test.js:236

   235:   const shell = process.platform === 'win32' ? 'cmd.exe' : '/bin/bash'; 
   236:   const {stdout} = await execa('node test/fixtures/noop.js foo', {shell…
   237:   t.is(stdout, 'foo');                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:236:25



  test › use extend environment with `extendEnv: true` and `shell: true`

  test/test.js:243

   242:   const command = process.platform === 'win32' ? 'echo %TEST%' : 'echo …
   243:   const {stdout} = await execa(command, {shell: true, env: {}, extendEn…
   244:   t.is(stdout, 'test');                                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:243:25



  test › detach child process

  test/test.js:249

   248: test('detach child process', async t => {   
   249:   const {stdout} = await execa('detach.js');
   250:   const pid = Number(stdout);               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:249:25



  test › execPath option

  test/test.js:108

   107:   const {path: execPath} = await getNode('6.0.0');                      
   108:   const {stdout} = await execa('node', ['-p', 'process.env.Path || proc…
   109:   t.true(stdout.includes('6.0.0'));                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:108:25

  ─

  149 tests failed
  6 unhandled rejections
-------------|---------|----------|---------|---------|------------------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s            
-------------|---------|----------|---------|---------|------------------------------
All files    |   81.53 |    93.67 |   81.08 |   81.53 |                              
 execa       |   83.14 |     92.5 |   88.88 |   83.14 |                              
  index.js   |   83.14 |     92.5 |   88.88 |   83.14 | 55-57,71-72,113-152          
 execa/lib   |   80.45 |    94.06 |   78.57 |   80.45 |                              
  command.js |     100 |      100 |     100 |     100 |                              
  error.js   |   90.58 |    85.18 |     100 |   90.58 | 9-10,17-18,23-24,76-77       
  kill.js    |   89.21 |    93.54 |      90 |   89.21 | 20,41,43-46,51-55            
  promise.js |   97.22 |     90.9 |     100 |   97.22 | 33                           
  stdio.js   |     100 |      100 |     100 |     100 |                              
  stream.js  |   32.55 |      100 |   16.66 |   32.55 | 7-15,20-34,39-49,53-61,66-79 
-------------|---------|----------|---------|---------|------------------------------
./VariantsDeps/execa/variant8/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (701ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.6s)
  ✔ error › result.killed is false if not killed, in sync mode (1.3s)
  ✔ error › result.killed is false on process error, in sync mode (188ms)
  ✔ error › Original error.message is kept (1.5s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (284ms)
  ✔ error › stdout/stderr/all on process errors (1.7s)
  ✔ error › stdout/stderr/all available on errors (1.8s)
  ✔ error › exitCode is 0 on success (1.7s)
  ✔ error › exitCode is 2 (1.7s)
  ✔ error › exitCode is 3 (1.7s)
  ✔ error › exitCode is 4 (1.7s)
  ✔ error › error.message contains the command (1.7s)
  ✔ error › error.message contains stdout/stderr if available (1.6s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.6s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.6s)
  ✔ error › failed is false on success (1.6s)
  ✔ error › failed is true on failure (1.5s)
  ✔ error › error.killed is true if process was killed directly (1.5s)
  ✔ error › error.killed is false if process was killed indirectly (1.5s)
  ✔ error › result.killed is false if not killed (1.4s)
  ✔ error › error.signal is SIGINT (262ms)
  ✔ error › error.signalDescription is defined (243ms)
  ✔ error › error.signal is SIGTERM (237ms)
  ✔ error › exitCode is undefined on signal termination (211ms)
  ✔ error › custom error.signal (269ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (369ms)
  ✔ error › result.signalDescription is undefined for successful execution (369ms)
  ✔ error › error.code is undefined on success (414ms)
  ✔ error › result.signal is undefined for successful execution (457ms)
  ✔ command › allow commands with spaces and no array arguments (2.2s)
  ✔ command › allow commands with spaces and array arguments (2.2s)
  ✔ command › execaCommand() (2.1s)
  ✔ command › execaCommand() ignores consecutive spaces (2s)
  ✔ command › execaCommand() allows escaping spaces in commands (2s)
  ✔ command › execaCommand() allows escaping spaces in arguments (1.9s)
  ✔ command › execaCommand() escapes other whitespaces (1.8s)
  ✔ command › execaCommand() trims (1.7s)
  ✔ command › command is: " foo bar" (2.5s)
  ✔ command › command is: " baz quz" (2.5s)
  ✔ command › command is: "" (2.4s)
  ✔ command › escapedCommand is: "foo bar" (2.6s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.7s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (2.7s)
  ✔ command › escapedCommand is: "\"*\"" (3s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (2.8s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.8s)
  ✔ kill › execa() returns a promise with kill() (2.7s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.6s)
  ✔ kill › cancel method kills the subprocess (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (1.9s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (1.1s)
  ✔ kill › timeout kills the process if it times out, in sync mode (2.7s)
  ✔ kill › timeout must not be negative (2.7s)
  ✔ kill › timeout must be an integer (2.7s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel (103ms)
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (122ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (157ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (170ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3s)
  ✔ kill › timeout does not kill the process if it does not time out (2.8s)
  ✔ kill › timedOut is false if timeout is undefined (2.8s)
  ✔ kill › timedOut is false if timeout is 0 (2.7s)
  ✔ kill › spawnAndExit (2.3s)
  ✔ kill › spawnAndExit cleanup (2.3s)
  ✔ kill › spawnAndExit detached (2.3s)
  ✔ kill › spawnAndExit cleanup detached (2.3s)
  ✔ kill › spawnAndKill SIGTERM (2.3s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.2s)
  ✔ kill › removes exit handler on exit (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (370ms)
  ✔ kill › error.isCanceled is true when cancel method is used (352ms)
  ✔ kill › error.isCanceled is false when kill method is used (331ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (293ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (234ms)
  ✔ kill › spawnAndKill detached SIGKILL (2.2s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.1s)
  ✔ kill › timeout kills the process if it times out (2.8s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (261ms)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (200ms)
  ✔ kill › spawnAndKill SIGKILL (2.3s)
  ✔ kill › spawnAndKill detached SIGTERM (2.2s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.2s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.3s)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (154ms)
  ✔ node › node's forked script has a communication channel (173ms)
  ✔ node › node pipe stdout (210ms)
  ✔ node › node pass on nodeOptions (195ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on failure (255ms)
  ✔ promise › finally function is executed on success (269ms)
  ✔ promise › throw in finally bubbles up on error (222ms)
  ✔ promise › throw in finally function bubbles up on success (245ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (7.9s)
  ✔ kill › kill() with no arguments should kill after a timeout (7.9s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.2s)
  ✔ stream › input option can be a String - sync (820ms)
  ✔ stream › input option can be a Buffer - sync (435ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (286ms)
  ✔ stream › buffer (1.4s)
  ✔ stream › pass `stdout` to a file descriptor (1.4s)
  ✔ stream › pass `stderr` to a file descriptor (1.4s)
  ✔ stream › result.all is undefined unless opts.all is true (1.4s)
  ✔ stream › stdout/stderr/all are undefined if ignored (1.4s)
  ✔ stream › input can be a Stream (1.1s)
  ✔ stream › input option can be a String (1.1s)
  ✔ stream › you can write to child.stdin (1.1s)
  ✔ stream › input option can be a Buffer (1.1s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (662ms)
  ✔ stream › do not buffer when streaming (650ms)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (703ms)
  ✔ stream › buffer: false > promise resolves (739ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (736ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (863ms)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (762ms)
  ✔ stream › can use all: true with stdout: ignore (758ms)
  ✔ stream › buffer: false > promise resolves when output is big and is read (868ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (836ms)
  ✔ stream › maxBuffer affects stdout (1s)
  ✔ stream › can use all: true with stderr: ignore (831ms)
  ✔ stream › maxBuffer affects stderr (1.1s)
  ✔ test › execaSync() (2.8s)
  ✔ test › execaSync() throws error if written to stderr (2.4s)
  ✔ test › skip throwing when using reject option in sync mode (2.4s)
  ✔ test › stripFinalNewline in sync mode (2s)
  ✔ test › stripFinalNewline in sync mode on failure (1.7s)
  ✔ test › execa() returns a promise with pid (751ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (730ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (704ms)
  ✔ test › child_process.spawn() errors are propagated (766ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (719ms)
  ✔ test › execa() rejects if running non-executable (765ms)
  ✔ test › preferLocal: undefined (994ms)
  ✔ test › preferLocal: false (1s)
  ✔ test › child process errors rejects promise right away (913ms)
  ✔ test › child process errors are handled (938ms)
  ✔ test › stdin errors are handled (978ms)
  ✔ test › execa() (3.1s)
  ✔ test › skip throwing when using reject option (2.6s)
  ✔ test › stripFinalNewline: true (2.3s)
  ✔ test › stripFinalNewline: false (2.3s)
  ✔ test › stripFinalNewline on failure (2.3s)
  ✔ test › localDir option (1s)
  ✔ test › do not try to consume streams twice (918ms)
  ✔ test › use relative path with '..' chars (883ms)
  ✔ test › write to fast-exit process (777ms)
  ✔ test › use environment variables by default (763ms)
  ✔ test › can use `options.cwd` as a string (680ms)
  ✔ test › localDir option can be a URL (643ms)
  ✔ test › can use `options.cwd` as a URL (621ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (402ms)
  ✔ test › extend environment variables by default (751ms)
  ✔ test › do not extend environment with `extendEnv: false` (730ms)
  ✔ test › can use `options.shell: true` (595ms)
  ✔ test › can use `options.shell: string` (545ms)
  ✔ test › execPath option (1.2s)
  ✔ test › detach child process (537ms)
  ✔ test › preferLocal: true (1.6s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsDeps/execa/variant7/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✖ command › execaCommandSync() Error thrown in test
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.4s)
  ✖ error › result.killed is false if not killed, in sync mode Error thrown in test
  ✔ error › result.killed is false on process error, in sync mode (189ms)
  ✔ error › Original error.message is kept (1s)
  ✔ error › error.code is defined on failure if applicable
  ✖ error › result.killed is false on process error 
  ✖ error › stdout/stderr/all on process errors 
  ✖ error › stdout/stderr/all available on errors 
  ✖ error › exitCode is 0 on success Rejected promise returned by test
  ✖ error › exitCode is 2 
  ✖ error › exitCode is 3 
  ✖ error › exitCode is 4 
  ✖ error › error.message contains the command 
  ✖ error › error.message contains stdout/stderr if available 
  ✔ error › error.message does not contain stdout/stderr if not available (1.3s)
  ✖ error › error.shortMessage does not contain stdout/stderr Rejected promise returned by test
  ✖ error › failed is false on success Rejected promise returned by test
  ✖ error › failed is true on failure 
  ✖ error › error.killed is true if process was killed directly 
  ✖ error › error.killed is false if process was killed indirectly 
  ✖ error › result.killed is false if not killed Rejected promise returned by test
  ✖ error › error.signal is SIGINT 
  ✖ error › error.signalDescription is defined 
  ✖ error › error.signal is SIGTERM 
  ✔ error › exitCode is undefined on signal termination (350ms)
  ✖ error › custom error.signal 
  ✖ error › result.signal is undefined if process failed, but was not killed 
  ✖ error › error.code is undefined on success Rejected promise returned by test
  ✖ error › result.signalDescription is undefined for successful execution Rejected promise returned by test
  ✖ error › result.signal is undefined for successful execution Rejected promise returned by test
  ✖ command › allow commands with spaces and no array arguments Rejected promise returned by test
  ✖ command › allow commands with spaces and array arguments Rejected promise returned by test
  ✖ command › execaCommand() Rejected promise returned by test
  ✖ command › execaCommand() ignores consecutive spaces Rejected promise returned by test
  ✖ command › execaCommand() allows escaping spaces in commands Rejected promise returned by test
  ✖ command › execaCommand() allows escaping spaces in arguments Rejected promise returned by test
  ✖ command › execaCommand() escapes other whitespaces Rejected promise returned by test
  ✖ command › execaCommand() trims Rejected promise returned by test
  ✖ command › command is: " foo bar" 
  ✖ command › command is: " baz quz" 
  ✖ command › command is: "" 
  ✖ command › escapedCommand is: "foo bar" 
  ✖ command › escapedCommand is: "\"foo bar\"" 
  ✖ command › escapedCommand is: "\"\\\"foo\\\"\"" 
  ✖ command › escapedCommand is: "\"*\"" 
  ✖ node › node removes --inspect from nodeOptions when defined by parent process Rejected promise returned by test
  ✔ kill › `forceKillAfterTimeout` should not be NaN (2.8s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.8s)
  ✔ kill › execa() returns a promise with kill() (2.7s)
  ✖ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode Error thrown in test
  ✔ kill › cancel method kills the subprocess (1.9s)
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) Error thrown in test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) 
  ✖ kill › timeout kills the process if it times out, in sync mode 
  ✔ kill › timeout must not be negative (2.7s)
  ✔ kill › timeout must be an integer (2.7s)
  ✖ kill › calling abort after cancel should show the same behaviour as only calling cancel 
  ✖ kill › calling cancel after abort should show the same behaviour as only calling cancel 
  ✖ kill › calling abort twice should show the same behaviour as calling it once 
  ✖ kill › calling abort throws an error with message "Command was canceled" 
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (2.9s)
  ✖ kill › timeout does not kill the process if it does not time out Rejected promise returned by test
  ✖ kill › timedOut is false if timeout is undefined Rejected promise returned by test
  ✖ kill › timedOut is false if timeout is 0 Rejected promise returned by test
  ✖ kill › spawnAndExit 
  ✖ kill › spawnAndExit cleanup 
  ✖ kill › spawnAndExit detached 
  ✖ kill › spawnAndExit cleanup detached 
  ✔ kill › spawnAndKill SIGTERM (2.3s)
  ✔ kill › spawnAndKill SIGKILL (2.3s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.2s)
  ✔ kill › spawnAndKill detached SIGTERM (2.2s)
  ✔ kill › spawnAndKill detached SIGKILL (2.2s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.2s)
  ✔ kill › removes exit handler on exit (2.1s)
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called (success) Rejected promise returned by test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) 
  ✖ kill › calling cancel method throws an error with message "Command was canceled" 
  ✖ kill › error.isCanceled is true when cancel method is used 
  ✖ kill › error.isCanceled is false when kill method is used 
  ✖ kill › calling cancel method twice should show the same behaviour as calling it once 
  ✖ kill › calling cancel method on a process which has been killed does not make error.isCanceled true 
  ✔ kill › spawnAndKill cleanup SIGTERM (2.3s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.2s)
  ✖ kill › timeout kills the process if it times out 
  ✖ kill › kill("SIGKILL") should terminate cleanly 
  ✖ kill › calling cancel method on a successfully completed process does not make result.isCanceled true Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout: number` should kill after a timeout 
  ✖ kill › calling abort on a successfully completed process does not make result.isCanceled true Rejected promise returned by test
  ✖ node › node removes --inspect=9222 from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect-brk from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node should not remove --inspect when passed through nodeOptions Rejected promise returned by test
  ✖ node › node correctly use nodePath Rejected promise returned by test
  ✖ node › node() Rejected promise returned by test
  ✖ node › node pass on nodeOptions Rejected promise returned by test
  ✖ node › node pipe stdout Rejected promise returned by test
  ✔ node › node's forked script has a communication channel (182ms)
  ✖ override-promise › should work with third-party Promise Rejected promise returned by test
  ✔ promise › promise methods are not enumerable (102ms)
  ✖ promise › finally function is executed on success Rejected promise returned by test
  ✖ promise › finally function is executed on failure 
  ✔ promise › throw in finally function bubbles up on success (284ms)
  ✔ promise › throw in finally bubbles up on error (244ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✖ stream › result.all shows both `stdout` and `stderr` intermixed Rejected promise returned by test
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✖ kill › `forceKillAfterTimeout: true` should kill after a timeout 
  ✖ kill › kill() with no arguments should kill after a timeout 
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.2s)
  ✖ stream › input option can be a String - sync Error thrown in test
  ✖ stream › input option can be a Buffer - sync Error thrown in test
  ✔ stream › helpful error trying to provide an input stream in sync mode (411ms)
  ✖ stream › buffer Rejected promise returned by test
  ✖ stream › pass `stdout` to a file descriptor Rejected promise returned by test
  ✖ stream › pass `stderr` to a file descriptor Rejected promise returned by test
  ✖ stream › result.all is undefined unless opts.all is true Rejected promise returned by test
  ✔ stream › stdout/stderr/all are undefined if ignored (1.4s)
  ✖ stream › input option can be a String Rejected promise returned by test
  ✖ stream › you can write to child.stdin Rejected promise returned by test
  ✖ stream › input option can be a Buffer Rejected promise returned by test
  ✖ stream › input can be a Stream Rejected promise returned by test
  ✖ stream › opts.stdout:ignore - stdout will not collect data Rejected promise returned by test
  ✔ stream › do not buffer stdout when `buffer` set to `false` (879ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (881ms)
  ✔ stream › do not buffer when streaming (877ms)
  ✔ stream › buffer: false > promise resolves (859ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (840ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (984ms)
  ✔ stream › buffer: false > promise resolves when output is big and is read (994ms)
  ✔ stream › can use all: true with stdout: ignore (910ms)
  ✖ stream › maxBuffer affects stdout 
  ✖ stream › maxBuffer affects stderr 
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1s)
  ✔ stream › can use all: true with stderr: ignore (899ms)
  ✖ test › execaSync() Error thrown in test
  ✔ test › execaSync() throws error if written to stderr (2s)
  ✖ test › skip throwing when using reject option in sync mode Error thrown in test
  ✖ test › stripFinalNewline in sync mode Error thrown in test
  ✖ test › stripFinalNewline in sync mode on failure 
  ✔ test › execa() returns a promise with pid (536ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (512ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (466ms)
  ✔ test › child_process.spawn() errors are propagated (609ms)
  ✖ test › execa() rejects with correct error and doesn't throw if running non-executable with input 
  ✔ test › execa() rejects if running non-executable (595ms)
  ✖ test › preferLocal: undefined 
  ✖ test › preferLocal: false 
  ✖ test › child process errors rejects promise right away 
  ✖ test › child process errors are handled 
  ✖ test › stdin errors are handled 
  ✖ test › execa() Rejected promise returned by test
  ✖ test › skip throwing when using reject option Rejected promise returned by test
  ✖ test › stripFinalNewline: true Rejected promise returned by test
  ✔ test › stripFinalNewline: false (2.2s)
  ✖ test › stripFinalNewline on failure 
  ✖ test › localDir option Rejected promise returned by test
  ✖ test › do not try to consume streams twice Rejected promise returned by test
  ✖ test › use relative path with '..' chars Rejected promise returned by test
  ✖ test › write to fast-exit process 
  ✖ test › localDir option can be a URL Rejected promise returned by test
  ✖ test › use extend environment with `extendEnv: true` and `shell: true` Rejected promise returned by test
  ✖ test › can use `options.cwd` as a string Rejected promise returned by test
  ✖ test › extend environment variables by default Rejected promise returned by test
  ✖ test › use environment variables by default Rejected promise returned by test
  ✖ test › can use `options.cwd` as a URL Rejected promise returned by test
  ✖ test › do not extend environment with `extendEnv: false` Rejected promise returned by test
  ✖ test › can use `options.shell: true` Rejected promise returned by test
  ✖ test › can use `options.shell: string` Rejected promise returned by test
  ✖ test › execPath option Rejected promise returned by test
  ✖ test › detach child process Rejected promise returned by test
  ✖ test › preferLocal: true 
  ─

  command › execaCommandSync()

  test/command.js:85

   84: test('execaCommandSync()', t => {                                        
   85:   const {stdout} = execaCommandSync('node test/fixtures/echo.js foo bar'…
   86:   t.is(stdout, 'foo\nbar');                                              

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › execaCommandSync (file://index.js:234:9)
  › file://test/command.js:85:19



  error › result.killed is false if not killed, in sync mode

  test/error.js:120

   119: test('result.killed is false if not killed, in sync mode', t => {
   120:   const {killed} = execaSync('noop.js');                         
   121:   t.false(killed);                                               

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/error.js:120:19



  error › result.killed is false on process error

  test/error.js:126

   125:   const {killed} = await t.throwsAsync(execa('wrong command'));
   126:   t.false(killed);                                             
   127: });                                                            

  Value is not `false`:

  undefined

  › file://test/error.js:126:9



  error › stdout/stderr/all on process errors

  test/error.js:29

   28:   const {stdout, stderr, all} = await t.throwsAsync(execa('wrong command…
   29:   t.is(stdout, '');                                                      
   30:   t.is(stderr, WRONG_COMMAND);                                           

  Difference:

  - undefined
  + ''

  › file://test/error.js:29:4



  error › stdout/stderr/all available on errors

  test/error.js:17

   16: test('stdout/stderr/all available on errors', async t => {               
   17:   const {stdout, stderr, all} = await t.throwsAsync(execa('exit.js', ['2…
   18:   t.is(typeof stdout, 'string');                                         

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 2/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › exitCode is 0 on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:44:21



  error › exitCode is 2

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 2/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › exitCode is 3

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 3/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › exitCode is 4

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 4/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.message contains the command

  test/error.js:58

   57: test('error.message contains the command', async t => {                  
   58:   await t.throwsAsync(execa('exit.js', ['2', 'foo', 'bar']), {message: /…
   59: });                                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /exit.js 2 foo bar/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.message contains stdout/stderr if available

  test/error.js:63

   62:   const {message} = await t.throwsAsync(execa('echo-fail.js'));
   63:   t.true(message.includes('stderr'));                          
   64:   t.true(message.includes('stdout'));                          

  Value is not `true`:

  false

  › file://test/error.js:63:8



  error › error.shortMessage does not contain stdout/stderr

  test/error.js:75

   74:   const {shortMessage} = await t.throwsAsync(execa('echo-fail.js'));
   75:   t.false(shortMessage.includes('stderr'));                         
   76:   t.false(shortMessage.includes('stdout'));                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'Cannot read properties of undefined (reading \'includes\')',
  }

  › file://test/error.js:75:23



  error › failed is false on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:85:19



  error › failed is true on failure

  test/error.js:91

   90:   const {failed} = await t.throwsAsync(execa('exit.js', ['2']));
   91:   t.true(failed);                                               
   92: });                                                             

  Value is not `true`:

  undefined

  › file://test/error.js:91:8



  error › error.killed is true if process was killed directly

  test/error.js:99

   98:                                                                          
   99:   const {killed} = await t.throwsAsync(subprocess, {message: /was killed…
   100:   t.true(killed);                                                        

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGTERM/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.killed is false if process was killed indirectly

  test/error.js:110

   109:   const message = process.platform === 'win32' ? /failed with exit code…
   110:   const {killed} = await t.throwsAsync(subprocess, {message});          
   111:   t.false(killed);                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGINT/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › result.killed is false if not killed

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:115:19



  error › error.signal is SIGINT

  test/error.js:154

   153:                                                                         
   154:     const {signal} = await t.throwsAsync(subprocess, {message: /was kil…
   155:     t.is(signal, 'SIGINT');                                             

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGINT/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.signalDescription is defined

  test/error.js:163

   162:                                                                         
   163:     const {signalDescription} = await t.throwsAsync(subprocess, {messag…
   164:     t.is(signalDescription, 'User interruption with CTRL-C');           

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /User interruption with CTRL-C/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.signal is SIGTERM

  test/error.js:172

   171:                                                                         
   172:     const {signal} = await t.throwsAsync(subprocess, {message: /was kil…
   173:     t.is(signal, 'SIGTERM');                                            

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGTERM/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › custom error.signal

  test/error.js:178

   177:     const {signal} = await t.throwsAsync(execa('noop.js', {killSignal: …
   178:     t.is(signal, 'SIGHUP');                                             
   179:   });                                                                   

  Difference:

  - undefined
  + 'SIGHUP'

  › file://test/error.js:178:5



  error › result.signal is undefined if process failed, but was not killed

  test/error.js:197

   196: test('result.signal is undefined if process failed, but was not killed'…
   197:   const {signal} = await t.throwsAsync(execa('exit.js', [2]), {message:…
   198:   t.is(signal, undefined);                                              

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 2/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.code is undefined on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:207:17



  error › result.signalDescription is undefined for successful execution

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:202:30



  error › result.signal is undefined for successful execution

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:192:19



  command › allow commands with spaces and no array arguments

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:45:19



  command › allow commands with spaces and array arguments

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:50:19



  command › execaCommand()

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:55:19



  command › execaCommand() ignores consecutive spaces

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:60:19



  command › execaCommand() allows escaping spaces in commands

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:65:19



  command › execaCommand() allows escaping spaces in arguments

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:70:19



  command › execaCommand() escapes other whitespaces

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:75:19



  command › execaCommand() trims

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:80:19



  command › command is: " foo bar"

  test/command.js:9

   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                
   10:                                                                           

  Difference:

  - undefined
  + 'fail.js foo bar'

  › command (file://test/command.js:9:4)



  command › command is: " baz quz"

  test/command.js:9

   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                
   10:                                                                           

  Difference:

  - undefined
  + 'fail.js baz quz'

  › command (file://test/command.js:9:4)



  command › command is: ""

  test/command.js:9

   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                
   10:                                                                           

  Difference:

  - undefined
  + 'fail.js'

  › command (file://test/command.js:9:4)



  command › escapedCommand is: "foo bar"

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js foo bar'

  › testEscapedCommand (file://test/command.js:23:4)



  command › escapedCommand is: "\"foo bar\""

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js "foo bar"'

  › testEscapedCommand (file://test/command.js:23:4)



  command › escapedCommand is: "\"\\\"foo\\\"\""

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js "\\"foo\\""'

  › testEscapedCommand (file://test/command.js:23:4)



  command › escapedCommand is: "\"*\""

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js "*"'

  › testEscapedCommand (file://test/command.js:23:4)



  node › node removes --inspect from nodeOptions when defined by parent process

  test/node.js:17

   16:                                               
   17:     const {stdout, stderr} = await subprocess;
   18:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async inspectMacro (file://test/node.js:17:28)



  kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode

  test/kill.js:127

   126: test('timedOut is false if timeout is undefined and exit code is 0 in s…
   127:   const {timedOut} = execaSync('noop.js');                              
   128:   t.false(timedOut);                                                    

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/kill.js:127:21



  kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success)

  test/kill.js:211

   210: test('result.isCanceled is false when spawned.cancel() isn\'t called in…
   211:   const {isCanceled} = execaSync('noop.js');                            
   212:   t.false(isCanceled);                                                  

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/kill.js:211:23



  kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure)

  test/kill.js:219

   218:   });                 
   219:   t.false(isCanceled);
   220: });                   

  Value is not `false`:

  undefined

  › file://test/kill.js:219:9



  kill › timeout kills the process if it times out, in sync mode

  test/kill.js:93

   92:   });              
   93:   t.false(killed); 
   94:   t.true(timedOut);

  Value is not `false`:

  undefined

  › file://test/kill.js:93:9



  kill › calling abort after cancel should show the same behaviour as only calling cancel

  test/kill.js:307

   306:     const {isCanceled} = await t.throwsAsync(subprocess);
   307:     t.true(isCanceled);                                  
   308:     t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:307:9



  kill › calling cancel after abort should show the same behaviour as only calling cancel

  test/kill.js:297

   296:     const {isCanceled} = await t.throwsAsync(subprocess);
   297:     t.true(isCanceled);                                  
   298:     t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:297:9



  kill › calling abort twice should show the same behaviour as calling it once

  test/kill.js:279

   278:     const {isCanceled} = await t.throwsAsync(subprocess);
   279:     t.true(isCanceled);                                  
   280:     t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:279:9



  kill › calling abort throws an error with message "Command was canceled"

  test/kill.js:270

   269:     abortController.abort();                                           
   270:     await t.throwsAsync(subprocess, {message: /Command was canceled/});
   271:   });                                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /Command was canceled/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  kill › timeout does not kill the process if it does not time out

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:98:21



  kill › timedOut is false if timeout is undefined

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:117:21



  kill › timedOut is false if timeout is 0

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:122:21



  kill › spawnAndExit

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › spawnAndExit cleanup

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › spawnAndExit detached

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › spawnAndExit cleanup detached

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › result.isCanceled is false when spawned.cancel() isn't called (success)

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:201:23



  kill › result.isCanceled is false when spawned.cancel() isn't called (failure)

  test/kill.js:207

   206:   const {isCanceled} = await t.throwsAsync(execa('fail.js'));
   207:   t.false(isCanceled);                                       
   208: });                                                          

  Value is not `false`:

  undefined

  › file://test/kill.js:207:9



  kill › calling cancel method throws an error with message "Command was canceled"

  test/kill.js:225

   224:   subprocess.cancel();                                               
   225:   await t.throwsAsync(subprocess, {message: /Command was canceled/});
   226: });                                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /Command was canceled/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  kill › error.isCanceled is true when cancel method is used

  test/kill.js:232

   231:   const {isCanceled} = await t.throwsAsync(subprocess);
   232:   t.true(isCanceled);                                  
   233: });                                                    

  Value is not `true`:

  undefined

  › file://test/kill.js:232:8



  kill › error.isCanceled is false when kill method is used

  test/kill.js:239

   238:   const {isCanceled} = await t.throwsAsync(subprocess);
   239:   t.false(isCanceled);                                 
   240: });                                                    

  Value is not `false`:

  undefined

  › file://test/kill.js:239:9



  kill › calling cancel method twice should show the same behaviour as calling it once

  test/kill.js:247

   246:   const {isCanceled} = await t.throwsAsync(subprocess);
   247:   t.true(isCanceled);                                  
   248:   t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:247:8



  kill › calling cancel method on a process which has been killed does not make error.isCanceled true

  test/kill.js:262

   261:   const {isCanceled} = await t.throwsAsync(subprocess);
   262:   t.false(isCanceled);                                 
   263: });                                                    

  Value is not `false`:

  undefined

  › file://test/kill.js:262:9



  kill › timeout kills the process if it times out

  test/kill.js:84

   83: test('timeout kills the process if it times out', async t => {           
   84:   const {killed, timedOut} = await t.throwsAsync(execa('noop.js', {timeo…
   85:   t.false(killed);                                                       

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /timed out after/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  kill › kill("SIGKILL") should terminate cleanly

  test/kill.js:19

   18:   const {signal} = await t.throwsAsync(subprocess);
   19:   t.is(signal, 'SIGKILL');                         
   20: });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:19:4



  kill › calling cancel method on a successfully completed process does not make result.isCanceled true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:253:23



  kill › `forceKillAfterTimeout: number` should kill after a timeout

  test/kill.js:42

   41:     const {signal} = await t.throwsAsync(subprocess);
   42:     t.is(signal, 'SIGKILL');                         
   43:   });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:42:5



  kill › calling abort on a successfully completed process does not make result.isCanceled true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:286:24



  node › node removes --inspect=9222 from nodeOptions when defined by parent process

  test/node.js:17

   16:                                               
   17:     const {stdout, stderr} = await subprocess;
   18:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async inspectMacro (file://test/node.js:17:28)



  node › node removes --inspect-brk from nodeOptions when defined by parent process

  test/node.js:17

   16:                                               
   17:     const {stdout, stderr} = await subprocess;
   18:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async inspectMacro (file://test/node.js:17:28)



  node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process

  test/node.js:17

   16:                                               
   17:     const {stdout, stderr} = await subprocess;
   18:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async inspectMacro (file://test/node.js:17:28)



  node › node should not remove --inspect when passed through nodeOptions

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:85:28



  node › node correctly use nodePath

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:40:19



  node › node()

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:27:21



  node › node pass on nodeOptions

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:50:19



  node › node pipe stdout

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:32:19



  override-promise › should work with third-party Promise

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/override-promise.js:12:19



  promise › finally function is executed on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/promise.js:16:19



  promise › finally function is executed on failure

  test/promise.js:29

   28:   t.is(isError, true);          
   29:   t.is(typeof stdout, 'string');
   30:   t.is(typeof stderr, 'string');

  Difference:

  - 'undefined'
  + 'string'

  › file://test/promise.js:29:4



  stream › result.all shows both `stdout` and `stderr` intermixed

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:32:16



  kill › `forceKillAfterTimeout: true` should kill after a timeout

  test/kill.js:52

   51:     const {signal} = await t.throwsAsync(subprocess);
   52:     t.is(signal, 'SIGKILL');                         
   53:   });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:52:5



  kill › kill() with no arguments should kill after a timeout

  test/kill.js:62

   61:     const {signal} = await t.throwsAsync(subprocess);
   62:     t.is(signal, 'SIGKILL');                         
   63:   });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:62:5



  stream › input option can be a String - sync

  test/stream.js:81

   80: test('input option can be a String - sync', t => {          
   81:   const {stdout} = execaSync('stdin.js', {input: 'foobar'});
   82:   t.is(stdout, 'foobar');                                   

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/stream.js:81:19



  stream › input option can be a Buffer - sync

  test/stream.js:86

   85: test('input option can be a Buffer - sync', t => {                       
   86:   const {stdout} = execaSync('stdin.js', {input: Buffer.from('testing12'…
   87:   t.is(stdout, 'testing12');                                             

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/stream.js:86:19



  stream › buffer

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:14:19



  stream › pass `stdout` to a file descriptor

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:115:18)
  › async file://test/stream.js:21:2



  stream › pass `stderr` to a file descriptor

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:27:2



  stream › result.all is undefined unless opts.all is true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:37:16



  stream › input option can be a String

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:56:19



  stream › you can write to child.stdin

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:76:19



  stream › input option can be a Buffer

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:61:19



  stream › input can be a Stream

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:69:19



  stream › opts.stdout:ignore - stdout will not collect data

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:115:18)
  › async file://test/stream.js:91:19



  stream › maxBuffer affects stdout

  test/stream.js:108

   107: test('maxBuffer affects stdout', async t => {                           
   108:   await t.notThrowsAsync(execa('max-buffer.js', ['stdout', '10'], {maxB…
   109:   const {stdout, all} = await t.throwsAsync(execa('max-buffer.js', ['st…

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/stream.js:108:10



  stream › maxBuffer affects stderr

  test/stream.js:115

   114: test('maxBuffer affects stderr', async t => {                           
   115:   await t.notThrowsAsync(execa('max-buffer.js', ['stderr', '10'], {maxB…
   116:   const {stderr, all} = await t.throwsAsync(execa('max-buffer.js', ['st…

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/stream.js:115:10



  test › execaSync()

  test/test.js:33

   32: test('execaSync()', t => {                       
   33:   const {stdout} = execaSync('noop.js', ['foo']);
   34:   t.is(stdout, 'foo');                           

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/test.js:33:19



  test › skip throwing when using reject option in sync mode

  test/test.js:49

   48: test('skip throwing when using reject option in sync mode', t => {
   49:   const {exitCode} = execaSync('fail.js', {reject: false});       
   50:   t.is(exitCode, 2);                                              

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/test.js:49:21



  test › stripFinalNewline in sync mode

  test/test.js:69

   68: test('stripFinalNewline in sync mode', t => {                            
   69:   const {stdout} = execaSync('noop.js', ['foo'], {stripFinalNewline: tru…
   70:   t.is(stdout, 'foo');                                                   

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/test.js:69:19



  test › stripFinalNewline in sync mode on failure

  test/test.js:77

   76:   });                 
   77:   t.is(stderr, 'foo');
   78: });                   

  Difference:

  - undefined
  + 'foo'

  › file://test/test.js:77:4



  test › execa() rejects with correct error and doesn't throw if running non-executable with input

  test/test.js:177

   176:   test('execa() rejects with correct error and doesn\'t throw if runnin…
   177:     await t.throwsAsync(execa('non-executable.js', {input: 'Hey!'}), {m…
   178:   });                                                                   

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /EACCES/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › preferLocal: undefined

  test/test.js:96

   95: test('preferLocal: undefined', async t => {                              
   96:   await t.throwsAsync(execa('ava', ['--version'], {env: getPathWithoutLo…
   97: });                                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /spawn.* ENOENT/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › preferLocal: false

  test/test.js:92

   91: test('preferLocal: false', async t => {                                  
   92:   await t.throwsAsync(execa('ava', ['--version'], {preferLocal: false, e…
   93: });                                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /spawn.* ENOENT/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › child process errors rejects promise right away

  test/test.js:127

   126:   subprocess.emit('error', new Error('test'));       
   127:   await t.throwsAsync(subprocess, {message: /test/});
   128: });                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /test/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › child process errors are handled

  test/test.js:121

   120:   subprocess.emit('error', new Error('test'));       
   121:   await t.throwsAsync(subprocess, {message: /test/});
   122: });                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /test/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › stdin errors are handled

  test/test.js:115

   114:   subprocess.stdin.emit('error', new Error('test')); 
   115:   await t.throwsAsync(subprocess, {message: /test/});
   116: });                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /test/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › execa()

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:16:19



  test › skip throwing when using reject option

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:44:21



  test › stripFinalNewline: true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:54:19



  test › stripFinalNewline on failure

  test/test.js:65

   64:   const {stderr} = await t.throwsAsync(execa('noop-throw.js', ['foo'], {…
   65:   t.is(stderr, 'foo');                                                   
   66: });                                                                      

  Difference:

  - undefined
  + 'foo'

  › file://test/test.js:65:4



  test › localDir option

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:101:19



  test › do not try to consume streams twice

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:158:19



  test › use relative path with '..' chars

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:166:19



  test › write to fast-exit process

  test/test.js:189

   188:     } catch (error) {           
   189:       t.is(error.code, 'EPIPE');
   190:     }                           

  Difference:

  - undefined
  + 'EPIPE'

  › file://test/test.js:189:6



  test › localDir option can be a URL

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:217:19



  test › use extend environment with `extendEnv: true` and `shell: true`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:243:19



  test › can use `options.cwd` as a string

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:211:19



  test › extend environment variables by default

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:200:19



  test › use environment variables by default

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:195:19



  test › can use `options.cwd` as a URL

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:225:19



  test › do not extend environment with `extendEnv: false`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:205:19



  test › can use `options.shell: true`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:230:19



  test › can use `options.shell: string`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:236:19



  test › execPath option

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:108:19



  test › detach child process

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:249:19



  test › preferLocal: true

  test/test.js:88

   87: test('preferLocal: true', async t => {                                   
   88:   await t.notThrowsAsync(execa('ava', ['--version'], {preferLocal: true,…
   89: });                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/test.js:88:10

  ─

  125 tests failed
-------------|---------|----------|---------|---------|-----------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s     
-------------|---------|----------|---------|---------|-----------------------
All files    |   98.04 |    96.13 |     100 |   98.04 |                       
 execa       |   97.37 |    89.58 |     100 |   97.37 |                       
  index.js   |   97.37 |    89.58 |     100 |   97.37 | 55-57,135-136,208-209 
 execa/lib   |   98.49 |    98.11 |     100 |   98.49 |                       
  command.js |     100 |      100 |     100 |     100 |                       
  error.js   |   92.94 |    88.46 |     100 |   92.94 | 9-10,23-24,76-77      
  kill.js    |     100 |      100 |     100 |     100 |                       
  promise.js |     100 |      100 |     100 |     100 |                       
  stdio.js   |     100 |      100 |     100 |     100 |                       
  stream.js  |     100 |      100 |     100 |     100 |                       
-------------|---------|----------|---------|---------|-----------------------
./VariantsDeps/execa/variant6/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (885ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.7s)
  ✔ error › result.killed is false if not killed, in sync mode (932ms)
  ✔ error › result.killed is false on process error, in sync mode (130ms)
  ✔ error › Original error.message is kept (1.4s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (223ms)
  ✔ error › stdout/stderr/all on process errors (1.8s)
  ✔ error › stdout/stderr/all available on errors (1.9s)
  ✔ error › exitCode is 0 on success (1.8s)
  ✔ error › exitCode is 2 (1.8s)
  ✔ error › exitCode is 3 (1.8s)
  ✔ error › exitCode is 4 (1.8s)
  ✔ error › error.message contains the command (1.7s)
  ✔ error › error.message contains stdout/stderr if available (1.7s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.7s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.6s)
  ✔ error › failed is false on success (1.5s)
  ✔ error › failed is true on failure (1.4s)
  ✔ error › error.killed is true if process was killed directly (1.3s)
  ✔ error › error.killed is false if process was killed indirectly (1.2s)
  ✔ error › result.killed is false if not killed (1.1s)
  ✔ error › error.signal is SIGINT (295ms)
  ✔ error › error.signalDescription is defined (290ms)
  ✔ error › error.signal is SIGTERM (285ms)
  ✔ error › exitCode is undefined on signal termination (271ms)
  ✔ error › custom error.signal (297ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (458ms)
  ✔ error › result.signalDescription is undefined for successful execution (453ms)
  ✔ error › result.signal is undefined for successful execution (501ms)
  ✔ error › error.code is undefined on success (471ms)
  ✔ command › allow commands with spaces and no array arguments (2.4s)
  ✔ command › allow commands with spaces and array arguments (2.4s)
  ✔ command › execaCommand() (2.3s)
  ✔ command › execaCommand() ignores consecutive spaces (2.3s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.2s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.2s)
  ✔ command › execaCommand() escapes other whitespaces (2.1s)
  ✔ command › execaCommand() trims (1.9s)
  ✔ command › command is: " foo bar" (2.6s)
  ✔ command › command is: " baz quz" (2.6s)
  ✔ command › command is: "" (2.6s)
  ✔ command › escapedCommand is: "foo bar" (2.7s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.8s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (2.9s)
  ✔ command › escapedCommand is: "\"*\"" (3.2s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (2.7s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.7s)
  ✔ kill › execa() returns a promise with kill() (2.7s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.5s)
  ✔ kill › cancel method kills the subprocess (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (1.9s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (885ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (2.7s)
  ✔ kill › timeout must not be negative (2.6s)
  ✔ kill › timeout must be an integer (2.6s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel
  ✔ kill › calling abort twice should show the same behaviour as calling it once (107ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (146ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (2.9s)
  ✔ kill › timeout does not kill the process if it does not time out (2.7s)
  ✔ kill › timedOut is false if timeout is undefined (2.7s)
  ✔ kill › timedOut is false if timeout is 0 (2.7s)
  ✔ kill › spawnAndExit (2.3s)
  ✔ kill › spawnAndExit cleanup (2.3s)
  ✔ kill › spawnAndExit detached (2.3s)
  ✔ kill › spawnAndExit cleanup detached (2.3s)
  ✔ kill › spawnAndKill SIGTERM (2.3s)
  ✔ kill › spawnAndKill SIGKILL (2.3s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.2s)
  ✔ kill › spawnAndKill detached SIGTERM (2.2s)
  ✔ kill › spawnAndKill detached SIGKILL (2.2s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.2s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.2s)
  ✔ kill › removes exit handler on exit (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.1s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (323ms)
  ✔ kill › error.isCanceled is true when cancel method is used (303ms)
  ✔ kill › error.isCanceled is false when kill method is used (289ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (264ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (240ms)
  ✔ kill › timeout kills the process if it times out (2.8s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (264ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (2.9s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (226ms)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.3s)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (170ms)
  ✔ node › node's forked script has a communication channel (168ms)
  ✔ node › node pipe stdout (222ms)
  ✔ node › node pass on nodeOptions (205ms)
  ✔ override-promise › should work with third-party Promise (104ms)
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on failure (170ms)
  ✔ promise › throw in finally function bubbles up on success (210ms)
  ✔ promise › throw in finally bubbles up on error (214ms)
  ✔ promise › finally function is executed on success (275ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (7.9s)
  ✔ kill › kill() with no arguments should kill after a timeout (7.9s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.3s)
  ✔ stream › input option can be a String - sync (916ms)
  ✔ stream › input option can be a Buffer - sync (601ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (383ms)
  ✔ stream › buffer (1.6s)
  ✔ stream › pass `stdout` to a file descriptor (1.6s)
  ✔ stream › pass `stderr` to a file descriptor (1.6s)
  ✔ stream › result.all is undefined unless opts.all is true (1.6s)
  ✔ stream › stdout/stderr/all are undefined if ignored (1.6s)
  ✔ stream › input option can be a String (1.3s)
  ✔ stream › input can be a Stream (1.3s)
  ✔ stream › input option can be a Buffer (1.3s)
  ✔ stream › you can write to child.stdin (1.3s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (1s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (1.1s)
  ✔ stream › buffer: false > promise resolves (1s)
  ✔ stream › do not buffer when streaming (1.1s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1.2s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (1.1s)
  ✔ stream › can use all: true with stderr: ignore (1.3s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.4s)
  ✔ stream › can use all: true with stdout: ignore (1.4s)
  ✔ test › execaSync() (2.7s)
  ✔ test › execaSync() throws error if written to stderr (2.4s)
  ✔ test › skip throwing when using reject option in sync mode (2.3s)
  ✔ test › stripFinalNewline in sync mode (2s)
  ✔ test › stripFinalNewline in sync mode on failure (1.7s)
  ✔ test › execa() returns a promise with pid (1.3s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1.2s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (1.1s)
  ✔ test › child_process.spawn() errors are propagated (1.3s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (1.1s)
  ✔ test › execa() rejects if running non-executable (1.1s)
  ✔ test › preferLocal: undefined (1.7s)
  ✔ test › preferLocal: false (1.7s)
  ✔ stream › maxBuffer affects stdout (1.7s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.6s)
  ✔ test › child process errors rejects promise right away (1.5s)
  ✔ test › child process errors are handled (1.6s)
  ✔ test › stdin errors are handled (1.6s)
  ✔ stream › maxBuffer affects stderr (1.9s)
  ✔ test › execa() (3s)
  ✔ test › skip throwing when using reject option (2.7s)
  ✔ test › stripFinalNewline: true (2.4s)
  ✔ test › stripFinalNewline: false (2.4s)
  ✔ test › stripFinalNewline on failure (2.4s)
  ✔ test › localDir option (1.8s)
  ✔ test › do not try to consume streams twice (1.4s)
  ✔ test › use relative path with '..' chars (1.4s)
  ✔ test › write to fast-exit process (1.2s)
  ✔ test › localDir option can be a URL (817ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (571ms)
  ✔ test › can use `options.cwd` as a string (890ms)
  ✔ test › do not extend environment with `extendEnv: false` (1s)
  ✔ test › extend environment variables by default (1s)
  ✔ test › use environment variables by default (1.1s)
  ✔ test › can use `options.cwd` as a URL (754ms)
  ✔ test › can use `options.shell: true` (762ms)
  ✔ test › can use `options.shell: string` (735ms)
  ✔ test › execPath option (2s)
  ✔ test › detach child process (791ms)
  ✔ test › preferLocal: true (2.5s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsDeps/execa/variant5/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ error › stdout/stderr/all on process errors, in sync mode (1.6s)
  ✔ error › result.killed is false if not killed, in sync mode (1.2s)
  ✔ error › result.killed is false on process error, in sync mode (235ms)
  ✔ error › Original error.message is kept (1.5s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (423ms)
  ✔ error › stdout/stderr/all on process errors (1.8s)
  ✔ command › execaCommandSync() (872ms)
  ✔ error › stdout/stderr/all available on errors (1.9s)
  ✔ error › exitCode is 0 on success (1.8s)
  ✔ error › exitCode is 2 (1.8s)
  ✔ error › exitCode is 3 (1.8s)
  ✔ error › exitCode is 4 (1.8s)
  ✔ error › error.message contains the command (1.8s)
  ✔ error › error.message contains stdout/stderr if available (1.8s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.8s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.7s)
  ✔ error › failed is false on success (1.7s)
  ✔ error › failed is true on failure (1.6s)
  ✔ error › error.killed is true if process was killed directly (1.6s)
  ✔ error › error.killed is false if process was killed indirectly (1.6s)
  ✔ error › result.killed is false if not killed (1.5s)
  ✔ error › error.signal is SIGINT (441ms)
  ✔ error › error.signalDescription is defined (428ms)
  ✔ error › error.signal is SIGTERM (406ms)
  ✔ error › exitCode is undefined on signal termination (354ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (327ms)
  ✔ error › custom error.signal (391ms)
  ✔ error › result.signalDescription is undefined for successful execution (364ms)
  ✔ error › error.code is undefined on success (351ms)
  ✔ error › result.signal is undefined for successful execution (409ms)
  ✔ command › allow commands with spaces and no array arguments (2.1s)
  ✔ command › allow commands with spaces and array arguments (2.1s)
  ✔ command › execaCommand() (2.1s)
  ✔ command › execaCommand() ignores consecutive spaces (2s)
  ✔ command › execaCommand() allows escaping spaces in commands (1.9s)
  ✔ command › execaCommand() allows escaping spaces in arguments (1.9s)
  ✔ command › execaCommand() escapes other whitespaces (1.8s)
  ✔ command › execaCommand() trims (1.7s)
  ✔ command › command is: " foo bar" (2.5s)
  ✔ command › command is: " baz quz" (2.4s)
  ✔ command › command is: "" (2.4s)
  ✔ command › escapedCommand is: "foo bar" (2.5s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.6s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (2.8s)
  ✔ command › escapedCommand is: "\"*\"" (3.2s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (2.7s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.7s)
  ✔ kill › execa() returns a promise with kill() (2.7s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.5s)
  ✔ kill › cancel method kills the subprocess (1.9s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (1.8s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (779ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (2.7s)
  ✔ kill › timeout must not be negative (2.6s)
  ✔ kill › timeout must be an integer (2.6s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel
  ✔ kill › calling abort twice should show the same behaviour as calling it once (114ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (135ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (2.9s)
  ✔ kill › timeout does not kill the process if it does not time out (2.7s)
  ✔ kill › timedOut is false if timeout is undefined (2.7s)
  ✔ kill › timedOut is false if timeout is 0 (2.7s)
  ✔ kill › spawnAndExit (2.3s)
  ✔ kill › spawnAndExit cleanup (2.3s)
  ✔ kill › spawnAndExit detached (2.3s)
  ✔ kill › spawnAndExit cleanup detached (2.3s)
  ✔ kill › spawnAndKill SIGTERM (2.3s)
  ✔ kill › spawnAndKill SIGKILL (2.3s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.2s)
  ✔ kill › spawnAndKill detached SIGTERM (2.2s)
  ✔ kill › spawnAndKill detached SIGKILL (2.2s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.2s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.1s)
  ✔ kill › removes exit handler on exit (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (1.9s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (297ms)
  ✔ kill › error.isCanceled is true when cancel method is used (278ms)
  ✔ kill › error.isCanceled is false when kill method is used (272ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (267ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (256ms)
  ✔ kill › timeout kills the process if it times out (2.9s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (283ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.3s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (263ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (155ms)
  ✔ node › node's forked script has a communication channel (161ms)
  ✔ node › node pipe stdout (213ms)
  ✔ node › node pass on nodeOptions (193ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on success (261ms)
  ✔ promise › throw in finally bubbles up on error (250ms)
  ✔ promise › finally function is executed on failure (284ms)
  ✔ promise › throw in finally function bubbles up on success (267ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (7.9s)
  ✔ kill › kill() with no arguments should kill after a timeout (7.9s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.5s)
  ✔ stream › input option can be a String - sync (1.1s)
  ✔ stream › input option can be a Buffer - sync (755ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (627ms)
  ✔ stream › buffer (1.8s)
  ✔ stream › pass `stdout` to a file descriptor (1.7s)
  ✔ stream › pass `stderr` to a file descriptor (1.7s)
  ✔ stream › result.all is undefined unless opts.all is true (1.7s)
  ✔ stream › stdout/stderr/all are undefined if ignored (1.7s)
  ✔ stream › input can be a Stream (1.5s)
  ✔ stream › input option can be a String (1.6s)
  ✔ stream › you can write to child.stdin (1.5s)
  ✔ stream › input option can be a Buffer (1.7s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (1.2s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (1.1s)
  ✔ stream › do not buffer when streaming (1.1s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (1.1s)
  ✔ stream › buffer: false > promise resolves (1.1s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1.4s)
  ✔ stream › can use all: true with stdout: ignore (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.4s)
  ✔ stream › can use all: true with stderr: ignore (1.2s)
  ✔ test › execaSync() (2.7s)
  ✔ test › execaSync() throws error if written to stderr (2.6s)
  ✔ test › skip throwing when using reject option in sync mode (2.6s)
  ✔ test › stripFinalNewline in sync mode (2.2s)
  ✔ test › stripFinalNewline in sync mode on failure (1.7s)
  ✔ test › execa() returns a promise with pid (1.5s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1.4s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (1.3s)
  ✔ test › child_process.spawn() errors are propagated (1.4s)
  ✔ stream › maxBuffer affects stdout (1.7s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (1.2s)
  ✔ test › execa() rejects if running non-executable (1.3s)
  ✔ test › preferLocal: undefined (1.8s)
  ✔ test › preferLocal: false (1.8s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.6s)
  ✔ stream › maxBuffer affects stderr (1.8s)
  ✔ test › child process errors rejects promise right away (1.7s)
  ✔ test › child process errors are handled (1.8s)
  ✔ test › stdin errors are handled (1.8s)
  ✔ test › execa() (3.1s)
  ✔ test › skip throwing when using reject option (3s)
  ✔ test › stripFinalNewline: true (2.6s)
  ✔ test › stripFinalNewline: false (2.6s)
  ✔ test › stripFinalNewline on failure (2.6s)
  ✔ test › localDir option (1.9s)
  ✔ test › do not try to consume streams twice (1.6s)
  ✔ test › use relative path with '..' chars (1.6s)
  ✔ test › write to fast-exit process (1.3s)
  ✔ test › localDir option can be a URL (848ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (516ms)
  ✔ test › can use `options.cwd` as a string (879ms)
  ✔ test › do not extend environment with `extendEnv: false` (1s)
  ✔ test › use environment variables by default (1.3s)
  ✔ test › extend environment variables by default (1s)
  ✔ test › can use `options.cwd` as a URL (776ms)
  ✔ test › can use `options.shell: true` (779ms)
  ✔ test › can use `options.shell: string` (724ms)
  ✔ test › execPath option (2.1s)
  ✔ test › detach child process (734ms)
  ✔ test › preferLocal: true (2.5s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsDeps/execa/variant4/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/error.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  Uncaught exception in test/command.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/error.js exited with a non-zero exit code: 1
  ✖ test/command.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  Uncaught exception in test/node.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/kill.js exited with a non-zero exit code: 1
  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  Uncaught exception in test/promise.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/promise.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }

  Uncaught exception in test/stream.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › <anonymous> (node_modules/get-node/src/archive/p7z.js:93:18)

  ✖ test/test.js exited with a non-zero exit code: 1

  ✖ Timed out while running tests

  ─

  36 tests passed
  8 uncaught exceptions
-------------|---------|----------|---------|---------|---------------------------------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                           
-------------|---------|----------|---------|---------|---------------------------------------------
All files    |   27.62 |      100 |    8.33 |   27.62 |                                             
 execa       |    13.1 |      100 |       0 |    13.1 |                                             
  index.js   |    13.1 |      100 |       0 |    13.1 | ...2,76-162,165-225,228-230,233-235,238-267 
 execa/lib   |   37.34 |      100 |   10.71 |   37.34 |                                             
  command.js |    43.9 |      100 |       0 |    43.9 | 2-6,13-17,28-40                             
  error.js   |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                  
  kill.js    |   36.27 |      100 |       0 |   36.27 | ...-29,38-46,51-55,59-60,65-80,84-86,91-101 
  promise.js |   36.11 |      100 |       0 |   36.11 | 9-18,23-35                                  
  stdio.js   |     100 |      100 |     100 |     100 |                                             
  stream.js  |   29.06 |      100 |       0 |   29.06 | 7-15,20-34,39-49,53-61,66-79,83-85          
-------------|---------|----------|---------|---------|---------------------------------------------
./VariantsDeps/execa/variant3/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ error › stdout/stderr/all on process errors, in sync mode (1.6s)
  ✔ error › result.killed is false if not killed, in sync mode (1.2s)
  ✔ error › result.killed is false on process error, in sync mode (241ms)
  ✔ error › Original error.message is kept (1.5s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (350ms)
  ✔ error › stdout/stderr/all on process errors (1.8s)
  ✔ command › execaCommandSync() (732ms)
  ✔ error › stdout/stderr/all available on errors (1.8s)
  ✔ error › exitCode is 0 on success (1.8s)
  ✔ error › exitCode is 2 (1.8s)
  ✔ error › exitCode is 3 (1.7s)
  ✔ error › exitCode is 4 (1.7s)
  ✔ error › error.message contains the command (1.7s)
  ✔ error › error.message contains stdout/stderr if available (1.7s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.6s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.6s)
  ✔ error › failed is false on success (1.6s)
  ✔ error › failed is true on failure (1.6s)
  ✔ error › error.killed is true if process was killed directly (1.5s)
  ✔ error › error.killed is false if process was killed indirectly (1.5s)
  ✔ error › result.killed is false if not killed (1.4s)
  ✔ error › error.signal is SIGINT (371ms)
  ✔ error › error.signalDescription is defined (352ms)
  ✔ error › error.signal is SIGTERM (338ms)
  ✔ error › exitCode is undefined on signal termination (299ms)
  ✔ error › custom error.signal (336ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (352ms)
  ✔ error › error.code is undefined on success (339ms)
  ✔ error › result.signalDescription is undefined for successful execution (391ms)
  ✔ error › result.signal is undefined for successful execution (453ms)
  ✔ command › allow commands with spaces and no array arguments (2.2s)
  ✔ command › allow commands with spaces and array arguments (2.2s)
  ✔ command › execaCommand() (2.2s)
  ✔ command › execaCommand() ignores consecutive spaces (2.1s)
  ✔ command › execaCommand() allows escaping spaces in commands (2s)
  ✔ command › execaCommand() allows escaping spaces in arguments (1.9s)
  ✔ command › execaCommand() escapes other whitespaces (1.8s)
  ✔ command › execaCommand() trims (1.8s)
  ✔ command › command is: " foo bar" (2.6s)
  ✔ command › command is: " baz quz" (2.5s)
  ✔ command › command is: "" (2.5s)
  ✔ command › escapedCommand is: "foo bar" (2.6s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.7s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3.1s)
  ✔ command › escapedCommand is: "\"*\"" (3.4s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (2.7s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.7s)
  ✔ kill › execa() returns a promise with kill() (2.7s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.5s)
  ✔ kill › cancel method kills the subprocess (1.9s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (1.8s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (747ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (2.7s)
  ✔ kill › timeout must not be negative (2.6s)
  ✔ kill › timeout must be an integer (2.6s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel
  ✔ kill › calling abort twice should show the same behaviour as calling it once
  ✔ kill › calling abort throws an error with message "Command was canceled" (110ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (2.9s)
  ✔ kill › timeout does not kill the process if it does not time out (2.7s)
  ✔ kill › timedOut is false if timeout is undefined (2.6s)
  ✔ kill › timedOut is false if timeout is 0 (2.6s)
  ✔ kill › spawnAndExit (2.3s)
  ✔ kill › spawnAndExit cleanup (2.2s)
  ✔ kill › spawnAndExit detached (2.2s)
  ✔ kill › spawnAndExit cleanup detached (2.2s)
  ✔ kill › spawnAndKill SIGTERM (2.2s)
  ✔ kill › spawnAndKill SIGKILL (2.2s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.2s)
  ✔ kill › spawnAndKill detached SIGTERM (2.1s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.1s)
  ✔ kill › removes exit handler on exit (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (1.9s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (232ms)
  ✔ kill › error.isCanceled is true when cancel method is used (219ms)
  ✔ kill › error.isCanceled is false when kill method is used (194ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (188ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (181ms)
  ✔ kill › spawnAndKill detached SIGKILL (2.1s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.1s)
  ✔ kill › timeout kills the process if it times out (2.8s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (2.9s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (2.9s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (213ms)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.2s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (232ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (196ms)
  ✔ node › node pipe stdout (209ms)
  ✔ node › node's forked script has a communication channel (179ms)
  ✔ node › node pass on nodeOptions (193ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on failure (246ms)
  ✔ promise › throw in finally function bubbles up on success (249ms)
  ✔ promise › finally function is executed on success (282ms)
  ✔ promise › throw in finally bubbles up on error (253ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › kill() with no arguments should kill after a timeout (7.8s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (7.8s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.8s)
  ✔ stream › input option can be a String - sync (1.2s)
  ✔ stream › input option can be a Buffer - sync (1s)
  ✔ stream › helpful error trying to provide an input stream in sync mode (827ms)
  ✔ stream › buffer (2s)
  ✔ stream › pass `stdout` to a file descriptor (2s)
  ✔ stream › pass `stderr` to a file descriptor (2s)
  ✔ stream › result.all is undefined unless opts.all is true (2s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2s)
  ✔ stream › input can be a Stream (1.5s)
  ✔ stream › you can write to child.stdin (1.5s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (1.1s)
  ✔ stream › input option can be a Buffer (1.6s)
  ✔ stream › input option can be a String (1.6s)
  ✔ test › execaSync() (2.3s)
  ✔ test › execaSync() throws error if written to stderr (2.1s)
  ✔ test › skip throwing when using reject option in sync mode (2.2s)
  ✔ test › stripFinalNewline in sync mode (1.8s)
  ✔ test › stripFinalNewline in sync mode on failure (1.4s)
  ✔ test › execa() returns a promise with pid (1.1s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1.1s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (1.1s)
  ✔ test › child_process.spawn() errors are propagated (1.3s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (1.2s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (1.2s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (1.3s)
  ✔ test › execa() rejects if running non-executable (1.3s)
  ✔ test › preferLocal: undefined (1.6s)
  ✔ stream › do not buffer when streaming (1.2s)
  ✔ test › preferLocal: false (1.6s)
  ✔ test › child process errors rejects promise right away (1.5s)
  ✔ test › child process errors are handled (1.6s)
  ✔ test › stdin errors are handled (1.6s)
  ✔ stream › buffer: false > promise resolves (1.3s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (1.1s)
  ✔ test › execa() (3s)
  ✔ test › skip throwing when using reject option (2.9s)
  ✔ test › stripFinalNewline: true (2.6s)
  ✔ test › stripFinalNewline: false (2.6s)
  ✔ test › stripFinalNewline on failure (2.5s)
  ✔ test › localDir option (1.9s)
  ✔ test › do not try to consume streams twice (1.7s)
  ✔ test › use relative path with '..' chars (1.7s)
  ✔ test › write to fast-exit process (1.6s)
  ✔ test › localDir option can be a URL (1.2s)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (1s)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1.5s)
  ✔ test › extend environment variables by default (1.5s)
  ✔ test › use environment variables by default (1.5s)
  ✔ test › can use `options.cwd` as a string (1.4s)
  ✔ test › do not extend environment with `extendEnv: false` (1.5s)
  ✔ test › can use `options.cwd` as a URL (1.3s)
  ✔ test › can use `options.shell: true` (1.2s)
  ✔ stream › maxBuffer affects stdout (1.8s)
  ✔ stream › maxBuffer affects stderr (1.8s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.4s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.5s)
  ✔ test › can use `options.shell: string` (1.2s)
  ✔ stream › can use all: true with stderr: ignore (1.2s)
  ✔ stream › can use all: true with stdout: ignore (1.3s)
  ✔ test › detach child process (1.2s)
  ✔ test › execPath option (2.2s)
  ✔ test › preferLocal: true (2.5s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsDeps/execa/variant2/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (732ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.7s)
  ✔ error › result.killed is false if not killed, in sync mode (1.3s)
  ✔ error › result.killed is false on process error, in sync mode (287ms)
  ✔ error › Original error.message is kept (1.5s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (444ms)
  ✔ error › stdout/stderr/all on process errors (1.8s)
  ✔ error › stdout/stderr/all available on errors (1.9s)
  ✔ error › exitCode is 0 on success (1.9s)
  ✔ error › exitCode is 2 (1.9s)
  ✔ error › exitCode is 3 (1.9s)
  ✔ error › exitCode is 4 (1.9s)
  ✔ error › error.message contains the command (1.9s)
  ✔ error › error.message contains stdout/stderr if available (1.8s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.8s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.8s)
  ✔ error › failed is false on success (1.7s)
  ✔ error › failed is true on failure (1.7s)
  ✔ error › error.killed is true if process was killed directly (1.7s)
  ✔ error › error.killed is false if process was killed indirectly (1.6s)
  ✔ error › result.killed is false if not killed (1.6s)
  ✔ error › error.signal is SIGINT (515ms)
  ✔ error › error.signalDescription is defined (493ms)
  ✔ error › error.signal is SIGTERM (463ms)
  ✔ error › exitCode is undefined on signal termination (409ms)
  ✔ error › custom error.signal (464ms)
  ✔ error › result.signal is undefined for successful execution (419ms)
  ✔ error › result.signalDescription is undefined for successful execution (385ms)
  ✔ error › error.code is undefined on success (397ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (465ms)
  ✔ command › allow commands with spaces and no array arguments (2s)
  ✔ command › allow commands with spaces and array arguments (2s)
  ✔ command › execaCommand() (2s)
  ✔ command › execaCommand() ignores consecutive spaces (1.9s)
  ✔ command › execaCommand() allows escaping spaces in commands (1.8s)
  ✔ command › execaCommand() allows escaping spaces in arguments (1.8s)
  ✔ command › execaCommand() escapes other whitespaces (1.8s)
  ✔ command › execaCommand() trims (1.7s)
  ✔ command › command is: " foo bar" (2.4s)
  ✔ command › command is: " baz quz" (2.3s)
  ✔ command › command is: "" (2.3s)
  ✔ command › escapedCommand is: "foo bar" (2.4s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.5s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (2.6s)
  ✔ command › escapedCommand is: "\"*\"" (3s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (2.8s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.8s)
  ✔ kill › execa() returns a promise with kill() (2.8s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.6s)
  ✔ kill › cancel method kills the subprocess (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (1.9s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (896ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (2.8s)
  ✔ kill › timeout must not be negative (2.6s)
  ✔ kill › timeout must be an integer (2.6s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (154ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (179ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (188ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3s)
  ✔ kill › timeout does not kill the process if it does not time out (2.9s)
  ✔ kill › timedOut is false if timeout is undefined (2.8s)
  ✔ kill › timedOut is false if timeout is 0 (2.8s)
  ✔ kill › spawnAndExit (2.4s)
  ✔ kill › spawnAndExit cleanup (2.4s)
  ✔ kill › spawnAndExit detached (2.4s)
  ✔ kill › spawnAndExit cleanup detached (2.4s)
  ✔ kill › spawnAndKill SIGTERM (2.4s)
  ✔ kill › spawnAndKill SIGKILL (2.4s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.3s)
  ✔ kill › spawnAndKill detached SIGKILL (2.3s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.3s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.2s)
  ✔ kill › removes exit handler on exit (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.1s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (379ms)
  ✔ kill › error.isCanceled is true when cancel method is used (365ms)
  ✔ kill › error.isCanceled is false when kill method is used (351ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (343ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (309ms)
  ✔ kill › spawnAndKill detached SIGTERM (2.3s)
  ✔ kill › timeout kills the process if it times out (3s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.1s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (347ms)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (301ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.1s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.4s)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (187ms)
  ✔ node › node pipe stdout (206ms)
  ✔ node › node pass on nodeOptions (188ms)
  ✔ node › node's forked script has a communication channel (176ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on success (238ms)
  ✔ promise › finally function is executed on failure (258ms)
  ✔ promise › throw in finally function bubbles up on success (244ms)
  ✔ promise › throw in finally bubbles up on error (220ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8s)
  ✔ kill › kill() with no arguments should kill after a timeout (8s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.6s)
  ✔ stream › input option can be a String - sync (1.2s)
  ✔ stream › input option can be a Buffer - sync (837ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (682ms)
  ✔ stream › buffer (1.9s)
  ✔ stream › pass `stdout` to a file descriptor (1.8s)
  ✔ stream › pass `stderr` to a file descriptor (1.8s)
  ✔ stream › result.all is undefined unless opts.all is true (1.8s)
  ✔ stream › stdout/stderr/all are undefined if ignored (1.8s)
  ✔ stream › input option can be a String (1.5s)
  ✔ stream › input can be a Stream (1.6s)
  ✔ stream › you can write to child.stdin (1.6s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (1.1s)
  ✔ stream › input option can be a Buffer (1.6s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (1.1s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (1.2s)
  ✔ test › execaSync() (2.4s)
  ✔ test › execaSync() throws error if written to stderr (2.1s)
  ✔ test › skip throwing when using reject option in sync mode (2.1s)
  ✔ test › stripFinalNewline in sync mode (1.8s)
  ✔ test › stripFinalNewline in sync mode on failure (1.4s)
  ✔ test › execa() returns a promise with pid (1.2s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1.2s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (1.1s)
  ✔ test › child_process.spawn() errors are propagated (1.3s)
  ✔ stream › do not buffer when streaming (1.3s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (1.1s)
  ✔ test › execa() rejects if running non-executable (1.2s)
  ✔ test › preferLocal: undefined (1.5s)
  ✔ stream › buffer: false > promise resolves (1.2s)
  ✔ test › preferLocal: false (1.6s)
  ✔ test › child process errors rejects promise right away (1.5s)
  ✔ test › child process errors are handled (1.5s)
  ✔ test › stdin errors are handled (1.6s)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1.5s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (1.3s)
  ✔ test › execa() (3s)
  ✔ test › skip throwing when using reject option (2.7s)
  ✔ test › stripFinalNewline: true (2.4s)
  ✔ test › stripFinalNewline: false (2.4s)
  ✔ test › stripFinalNewline on failure (2.3s)
  ✔ test › localDir option (1.8s)
  ✔ test › do not try to consume streams twice (1.6s)
  ✔ test › use relative path with '..' chars (1.6s)
  ✔ test › write to fast-exit process (1.4s)
  ✔ test › localDir option can be a URL (1s)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (772ms)
  ✔ test › can use `options.cwd` as a string (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.5s)
  ✔ test › use environment variables by default (1.3s)
  ✔ test › do not extend environment with `extendEnv: false` (1.2s)
  ✔ stream › maxBuffer affects stdout (1.9s)
  ✔ stream › can use all: true with stdout: ignore (1.4s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.5s)
  ✔ stream › can use all: true with stderr: ignore (1.4s)
  ✔ stream › maxBuffer affects stderr (1.9s)
  ✔ test › extend environment variables by default (1.4s)
  ✔ test › can use `options.cwd` as a URL (1.1s)
  ✔ test › can use `options.shell: string` (1s)
  ✔ test › can use `options.shell: true` (1s)
  ✔ test › execPath option (2.1s)
  ✔ test › detach child process (1s)
  ✔ test › preferLocal: true (2.5s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsDeps/execa/variant1/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (932ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.3s)
  ✔ error › result.killed is false if not killed, in sync mode (853ms)
  ✔ error › result.killed is false on process error, in sync mode (256ms)
  ✔ error › Original error.message is kept (1s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (338ms)
  ✔ error › stdout/stderr/all on process errors (1.5s)
  ✔ error › stdout/stderr/all available on errors (1.7s)
  ✔ error › exitCode is 0 on success (1.5s)
  ✔ error › exitCode is 2 (1.4s)
  ✔ error › exitCode is 3 (1.4s)
  ✔ error › exitCode is 4 (1.3s)
  ✔ error › error.message contains the command (1.3s)
  ✔ error › error.message contains stdout/stderr if available (1.3s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.2s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.2s)
  ✔ error › failed is false on success (1.2s)
  ✔ error › failed is true on failure (1.1s)
  ✔ error › error.killed is true if process was killed directly (1.1s)
  ✔ error › error.killed is false if process was killed indirectly (1.1s)
  ✔ error › result.killed is false if not killed (1s)
  ✔ error › error.signal is SIGINT (416ms)
  ✔ error › error.signalDescription is defined (402ms)
  ✔ error › error.signal is SIGTERM (393ms)
  ✔ error › exitCode is undefined on signal termination (358ms)
  ✔ error › custom error.signal (378ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (375ms)
  ✔ error › error.code is undefined on success (424ms)
  ✔ error › result.signal is undefined for successful execution (492ms)
  ✔ error › result.signalDescription is undefined for successful execution (465ms)
  ✔ command › allow commands with spaces and no array arguments (2.5s)
  ✔ command › allow commands with spaces and array arguments (2.5s)
  ✔ command › execaCommand() (2.5s)
  ✔ command › execaCommand() ignores consecutive spaces (2.4s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.4s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.3s)
  ✔ command › execaCommand() escapes other whitespaces (2.3s)
  ✔ command › execaCommand() trims (2.3s)
  ✔ command › command is: " foo bar" (2.6s)
  ✔ command › command is: " baz quz" (2.6s)
  ✔ command › command is: "" (2.6s)
  ✔ command › escapedCommand is: "foo bar" (2.8s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.9s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3s)
  ✔ command › escapedCommand is: "\"*\"" (3.1s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (2.8s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.7s)
  ✔ kill › execa() returns a promise with kill() (2.7s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.6s)
  ✔ kill › cancel method kills the subprocess (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (1.9s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (859ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (2.7s)
  ✔ kill › timeout must not be negative (2.7s)
  ✔ kill › timeout must be an integer (2.7s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel
  ✔ kill › calling abort twice should show the same behaviour as calling it once (159ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (178ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3s)
  ✔ kill › timeout does not kill the process if it does not time out (2.8s)
  ✔ kill › timedOut is false if timeout is undefined (2.8s)
  ✔ kill › timedOut is false if timeout is 0 (2.8s)
  ✔ kill › spawnAndExit (2.4s)
  ✔ kill › spawnAndExit cleanup (2.4s)
  ✔ kill › spawnAndExit detached (2.4s)
  ✔ kill › spawnAndExit cleanup detached (2.3s)
  ✔ kill › spawnAndKill SIGTERM (2.3s)
  ✔ kill › spawnAndKill SIGKILL (2.3s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.3s)
  ✔ kill › spawnAndKill detached SIGTERM (2.3s)
  ✔ kill › spawnAndKill detached SIGKILL (2.2s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.2s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.2s)
  ✔ kill › removes exit handler on exit (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.1s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (347ms)
  ✔ kill › error.isCanceled is true when cancel method is used (324ms)
  ✔ kill › error.isCanceled is false when kill method is used (307ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (293ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (287ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (282ms)
  ✔ kill › timeout kills the process if it times out (2.9s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.1s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.1s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.3s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (275ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (135ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (152ms)
  ✔ node › node pipe stdout (196ms)
  ✔ node › node's forked script has a communication channel (179ms)
  ✔ node › node pass on nodeOptions (195ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on success (223ms)
  ✔ promise › finally function is executed on failure (255ms)
  ✔ promise › throw in finally function bubbles up on success (241ms)
  ✔ promise › throw in finally bubbles up on error (225ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8s)
  ✔ kill › kill() with no arguments should kill after a timeout (7.9s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.3s)
  ✔ stream › input option can be a String - sync (896ms)
  ✔ stream › input option can be a Buffer - sync (581ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (317ms)
  ✔ stream › buffer (1.5s)
  ✔ stream › pass `stdout` to a file descriptor (1.5s)
  ✔ stream › pass `stderr` to a file descriptor (1.5s)
  ✔ stream › result.all is undefined unless opts.all is true (1.5s)
  ✔ stream › stdout/stderr/all are undefined if ignored (1.4s)
  ✔ stream › input option can be a String (1.2s)
  ✔ stream › input option can be a Buffer (1.2s)
  ✔ stream › input can be a Stream (1.2s)
  ✔ stream › you can write to child.stdin (1.2s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (646ms)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (582ms)
  ✔ stream › do not buffer when streaming (919ms)
  ✔ stream › buffer: false > promise resolves (905ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (879ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (1s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (925ms)
  ✔ stream › can use all: true with stdout: ignore (856ms)
  ✔ stream › can use all: true with stderr: ignore (842ms)
  ✔ stream › maxBuffer affects stdout (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1s)
  ✔ stream › maxBuffer affects stderr (1.3s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.2s)
  ✔ test › execaSync() (2.7s)
  ✔ test › execaSync() throws error if written to stderr (2.3s)
  ✔ test › skip throwing when using reject option in sync mode (2.3s)
  ✔ test › stripFinalNewline in sync mode (1.9s)
  ✔ test › stripFinalNewline in sync mode on failure (1.7s)
  ✔ test › execa() returns a promise with pid (822ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (750ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (658ms)
  ✔ test › child_process.spawn() errors are propagated (792ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (708ms)
  ✔ test › execa() rejects if running non-executable (741ms)
  ✔ test › preferLocal: undefined (1.3s)
  ✔ test › preferLocal: false (1.4s)
  ✔ test › child process errors rejects promise right away (1.1s)
  ✔ test › child process errors are handled (1.1s)
  ✔ test › stdin errors are handled (1.2s)
  ✔ test › execa() (3.2s)
  ✔ test › skip throwing when using reject option (2.7s)
  ✔ test › stripFinalNewline: true (2.4s)
  ✔ test › stripFinalNewline: false (2.3s)
  ✔ test › stripFinalNewline on failure (2.3s)
  ✔ test › localDir option (1.3s)
  ✔ test › do not try to consume streams twice (956ms)
  ✔ test › use relative path with '..' chars (913ms)
  ✔ test › write to fast-exit process (812ms)
  ✔ test › localDir option can be a URL (596ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (479ms)
  ✔ test › can use `options.cwd` as a string (643ms)
  ✔ test › can use `options.cwd` as a URL (575ms)
  ✔ test › do not extend environment with `extendEnv: false` (738ms)
  ✔ test › use environment variables by default (824ms)
  ✔ test › extend environment variables by default (768ms)
  ✔ test › can use `options.shell: true` (670ms)
  ✔ test › can use `options.shell: string` (637ms)
  ✔ test › execPath option (1.5s)
  ✔ test › detach child process (698ms)
  ✔ test › preferLocal: true (2.1s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------

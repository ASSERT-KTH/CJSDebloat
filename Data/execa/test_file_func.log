22
./VariantsFile/execa/variant22/execa

> execa@6.1.0 test
> xo && c8 ava && tsd

./VariantsFile/execa/variant21/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (1s)
  ✔ error › stdout/stderr/all on process errors, in sync mode (2s)
  ✔ error › result.killed is false if not killed, in sync mode (965ms)
  ✔ error › result.killed is false on process error, in sync mode (266ms)
  ✔ error › Original error.message is kept (1.4s)
  ✔ error › error.code is defined on failure if applicable (130ms)
  ✔ error › result.killed is false on process error (397ms)
  ✔ error › stdout/stderr/all on process errors (2.2s)
  ✔ error › stdout/stderr/all available on errors (2.3s)
  ✔ error › exitCode is 0 on success (2.2s)
  ✔ error › exitCode is 2 (2.1s)
  ✔ error › exitCode is 3 (2.1s)
  ✔ error › exitCode is 4 (2s)
  ✔ error › error.message contains the command (1.9s)
  ✔ error › error.message contains stdout/stderr if available (1.8s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.7s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.7s)
  ✔ error › failed is false on success (1.6s)
  ✔ error › failed is true on failure (1.5s)
  ✔ error › error.killed is true if process was killed directly (1.4s)
  ✔ error › error.killed is false if process was killed indirectly (1.3s)
  ✔ error › result.killed is false if not killed (1.3s)
  ✔ error › error.signal is SIGINT (499ms)
  ✔ error › error.signalDescription is defined (465ms)
  ✔ error › error.signal is SIGTERM (447ms)
  ✔ error › exitCode is undefined on signal termination (414ms)
  ✔ error › custom error.signal (457ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (420ms)
  ✔ error › result.signalDescription is undefined for successful execution (432ms)
  ✔ error › error.code is undefined on success (446ms)
  ✔ error › result.signal is undefined for successful execution (557ms)
  ✔ command › allow commands with spaces and no array arguments (3s)
  ✔ command › allow commands with spaces and array arguments (3s)
  ✔ command › execaCommand() (3s)
  ✔ command › execaCommand() ignores consecutive spaces (2.9s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.9s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.8s)
  ✔ command › execaCommand() escapes other whitespaces (2.7s)
  ✔ command › execaCommand() trims (2.7s)
  ✔ command › command is: " foo bar" (3.2s)
  ✔ command › command is: " baz quz" (3.2s)
  ✔ command › command is: "" (3.1s)
  ✔ command › escapedCommand is: "foo bar" (3.5s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.6s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3.9s)
  ✔ command › escapedCommand is: "\"*\"" (4.4s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.5s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.5s)
  ✔ kill › execa() returns a promise with kill() (3.5s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3.3s)
  ✔ kill › cancel method kills the subprocess (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (881ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (3.4s)
  ✔ kill › timeout must not be negative (3.4s)
  ✔ kill › timeout must be an integer (3.4s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (106ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (133ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (176ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.7s)
  ✔ kill › timeout does not kill the process if it does not time out (3.5s)
  ✔ kill › timedOut is false if timeout is undefined (3.5s)
  ✔ kill › timedOut is false if timeout is 0 (3.5s)
  ✔ kill › spawnAndExit (2.9s)
  ✔ kill › spawnAndExit cleanup (2.9s)
  ✔ kill › spawnAndExit detached (2.9s)
  ✔ kill › spawnAndExit cleanup detached (2.9s)
  ✔ kill › spawnAndKill SIGTERM (2.8s)
  ✔ kill › spawnAndKill SIGKILL (2.8s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.7s)
  ✔ kill › spawnAndKill detached SIGTERM (2.7s)
  ✔ kill › spawnAndKill detached SIGKILL (2.6s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.6s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.6s)
  ✔ kill › removes exit handler on exit (2.5s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.3s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (401ms)
  ✔ kill › error.isCanceled is true when cancel method is used (375ms)
  ✔ kill › error.isCanceled is false when kill method is used (370ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (340ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (332ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (311ms)
  ✔ kill › timeout kills the process if it times out (3.6s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.9s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.8s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.8s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (291ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (122ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process (110ms)
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process (109ms)
  ✔ node › node should not remove --inspect when passed through nodeOptions (120ms)
  ✔ node › node correctly use nodePath
  ✔ node › node pipe stdout (273ms)
  ✔ node › node pass on nodeOptions (270ms)
  ✔ node › node() (332ms)
  ✔ node › node's forked script has a communication channel (280ms)
  ✔ override-promise › should work with third-party Promise (133ms)
  ✔ promise › promise methods are not enumerable (126ms)
  ✔ promise › finally function is executed on failure (345ms)
  ✔ promise › finally function is executed on success (390ms)
  ✔ promise › throw in finally bubbles up on error (307ms)
  ✔ promise › throw in finally function bubbles up on success (361ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.7s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.6s)
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.2s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (2.1s)
  ✔ stream › input option can be a String - sync (1.5s)
  ✔ stream › input option can be a Buffer - sync (1.2s)
  ✔ stream › helpful error trying to provide an input stream in sync mode (973ms)
  ✔ stream › buffer (2.4s)
  ✔ stream › pass `stdout` to a file descriptor (2.4s)
  ✔ stream › pass `stderr` to a file descriptor (2.4s)
  ✔ stream › result.all is undefined unless opts.all is true (2.3s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.3s)
  ✔ stream › input option can be a String (2s)
  ✔ stream › input option can be a Buffer (2s)
  ✔ stream › input can be a Stream (2s)
  ✔ stream › you can write to child.stdin (1.9s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (1.3s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (1.3s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (1.3s)
  ✔ test › execaSync() (3.4s)
  ✔ test › execaSync() throws error if written to stderr (3.1s)
  ✔ test › skip throwing when using reject option in sync mode (3.1s)
  ✔ test › stripFinalNewline in sync mode (2.7s)
  ✔ test › stripFinalNewline in sync mode on failure (2.1s)
  ✔ test › execa() returns a promise with pid (1.6s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1.6s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (1.5s)
  ✔ test › child_process.spawn() errors are propagated (1.7s)
  ✔ stream › do not buffer when streaming (1.3s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (1s)
  ✔ stream › buffer: false > promise resolves (1.3s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (1.5s)
  ✔ test › execa() rejects if running non-executable (1.6s)
  ✔ test › preferLocal: undefined (2s)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1.3s)
  ✔ test › preferLocal: false (2.1s)
  ✔ test › child process errors rejects promise right away (2s)
  ✔ test › child process errors are handled (2s)
  ✔ test › stdin errors are handled (2s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.5s)
  ✔ stream › can use all: true with stderr: ignore (1.2s)
  ✔ stream › maxBuffer affects stdout (2s)
  ✔ test › execa() (4s)
  ✔ test › skip throwing when using reject option (3.6s)
  ✔ test › stripFinalNewline: true (3.4s)
  ✔ test › stripFinalNewline: false (3.4s)
  ✔ test › stripFinalNewline on failure (3.3s)
  ✔ test › localDir option (2.2s)
  ✔ test › do not try to consume streams twice (2s)
  ✔ test › use relative path with '..' chars (1.9s)
  ✔ test › write to fast-exit process (1.7s)
  ✔ test › use environment variables by default (1.6s)
  ✔ test › extend environment variables by default (1.6s)
  ✔ test › do not extend environment with `extendEnv: false` (1.5s)
  ✔ test › can use `options.cwd` as a string (1.4s)
  ✔ test › localDir option can be a URL (1.3s)
  ✔ test › can use `options.cwd` as a URL (1.2s)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (865ms)
  ✔ stream › can use all: true with stdout: ignore (1.3s)
  ✔ test › can use `options.shell: true` (1.2s)
  ✔ stream › maxBuffer affects stderr (2s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.6s)
  ✔ test › can use `options.shell: string` (1.1s)
  ✔ test › detach child process (1.1s)
  ✔ test › execPath option (2.8s)
  ✔ test › preferLocal: true (3.2s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsFile/execa/variant20/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (919ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (2s)
  ✔ error › result.killed is false if not killed, in sync mode (1s)
  ✔ error › result.killed is false on process error, in sync mode (368ms)
  ✔ error › Original error.message is kept (1.7s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (520ms)
  ✔ error › stdout/stderr/all on process errors (2.2s)
  ✔ error › stdout/stderr/all available on errors (2.4s)
  ✔ error › exitCode is 0 on success (2.3s)
  ✔ error › exitCode is 2 (2.3s)
  ✔ error › exitCode is 3 (2.2s)
  ✔ error › exitCode is 4 (2.2s)
  ✔ error › error.message contains the command (2.1s)
  ✔ error › error.message contains stdout/stderr if available (2.1s)
  ✔ error › error.message does not contain stdout/stderr if not available (2s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.9s)
  ✔ error › failed is false on success (1.9s)
  ✔ error › failed is true on failure (1.8s)
  ✔ error › error.killed is true if process was killed directly (1.7s)
  ✔ error › error.killed is false if process was killed indirectly (1.6s)
  ✔ error › result.killed is false if not killed (1.4s)
  ✔ error › error.signal is SIGINT (628ms)
  ✔ error › error.signalDescription is defined (575ms)
  ✔ error › error.signal is SIGTERM (550ms)
  ✔ error › exitCode is undefined on signal termination (510ms)
  ✔ error › custom error.signal (553ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (450ms)
  ✔ error › result.signal is undefined for successful execution (589ms)
  ✔ error › result.signalDescription is undefined for successful execution (557ms)
  ✔ error › error.code is undefined on success (536ms)
  ✔ command › allow commands with spaces and no array arguments (2.9s)
  ✔ command › allow commands with spaces and array arguments (2.9s)
  ✔ command › execaCommand() (2.8s)
  ✔ command › execaCommand() ignores consecutive spaces (2.8s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.7s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.6s)
  ✔ command › execaCommand() escapes other whitespaces (2.5s)
  ✔ command › execaCommand() trims (2.5s)
  ✔ command › command is: " foo bar" (3.2s)
  ✔ command › command is: " baz quz" (3.1s)
  ✔ command › command is: "" (3.1s)
  ✔ command › escapedCommand is: "foo bar" (3.3s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.4s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3.6s)
  ✔ command › escapedCommand is: "\"*\"" (3.8s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.6s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.5s)
  ✔ kill › execa() returns a promise with kill() (3.5s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3.2s)
  ✔ kill › cancel method kills the subprocess (2.5s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (954ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (3.4s)
  ✔ kill › timeout must not be negative (3.3s)
  ✔ kill › timeout must be an integer (3.3s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (114ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (138ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (170ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.8s)
  ✔ kill › timeout does not kill the process if it does not time out (3.5s)
  ✔ kill › timedOut is false if timeout is undefined (3.4s)
  ✔ kill › timedOut is false if timeout is 0 (3.4s)
  ✔ kill › spawnAndExit (3s)
  ✔ kill › spawnAndExit cleanup (3s)
  ✔ kill › spawnAndExit detached (2.9s)
  ✔ kill › spawnAndExit cleanup detached (2.9s)
  ✔ kill › spawnAndKill SIGTERM (2.9s)
  ✔ kill › spawnAndKill SIGKILL (2.8s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.8s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.7s)
  ✔ kill › removes exit handler on exit (2.7s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.5s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.5s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (387ms)
  ✔ kill › error.isCanceled is true when cancel method is used (346ms)
  ✔ kill › error.isCanceled is false when kill method is used (313ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (301ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (274ms)
  ✔ kill › spawnAndKill detached SIGTERM (2.8s)
  ✔ kill › spawnAndKill detached SIGKILL (2.8s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.7s)
  ✔ kill › timeout kills the process if it times out (3.6s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (4s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.9s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.9s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (349ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (410ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (107ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process (102ms)
  ✔ node › node should not remove --inspect when passed through nodeOptions (105ms)
  ✔ node › node correctly use nodePath
  ✔ node › node pass on nodeOptions (246ms)
  ✔ node › node pipe stdout (301ms)
  ✔ node › node() (328ms)
  ✔ node › node's forked script has a communication channel (269ms)
  ✔ override-promise › should work with third-party Promise (129ms)
  ✔ promise › promise methods are not enumerable (144ms)
  ✔ promise › finally function is executed on success (276ms)
  ✔ promise › finally function is executed on failure (287ms)
  ✔ promise › throw in finally function bubbles up on success (311ms)
  ✔ promise › throw in finally bubbles up on error (322ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.7s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.7s)
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ test › execaSync() (2s)
  ✔ test › execaSync() throws error if written to stderr (1.8s)
  ✔ test › skip throwing when using reject option in sync mode (1.8s)
  ✔ test › stripFinalNewline in sync mode (1.6s)
  ✔ test › stripFinalNewline in sync mode on failure (1.4s)
  ✔ test › execa() returns a promise with pid (1s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (908ms)
  ✔ test › child_process.spawn() errors are propagated (1s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (865ms)
  ✔ test › execa() rejects if running non-executable (973ms)
  ✔ test › preferLocal: undefined (1.4s)
  ✔ test › preferLocal: false (1.5s)
  ✔ test › child process errors rejects promise right away (1.3s)
  ✔ test › child process errors are handled (1.4s)
  ✔ test › stdin errors are handled (1.4s)
  ✔ test › execa() (2.4s)
  ✔ test › skip throwing when using reject option (2.2s)
  ✔ test › stripFinalNewline: true (2s)
  ✔ test › stripFinalNewline: false (2s)
  ✔ test › stripFinalNewline on failure (2s)
  ✔ test › localDir option (1.6s)
  ✔ test › do not try to consume streams twice (1.2s)
  ✔ test › use relative path with '..' chars (1.2s)
  ✔ test › write to fast-exit process (1s)
  ✔ test › use environment variables by default (1s)
  ✔ test › extend environment variables by default (995ms)
  ✔ test › localDir option can be a URL (831ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (610ms)
  ✔ test › can use `options.cwd` as a string (901ms)
  ✔ test › do not extend environment with `extendEnv: false` (968ms)
  ✔ test › can use `options.cwd` as a URL (803ms)
  ✔ test › can use `options.shell: true` (815ms)
  ✔ test › can use `options.shell: string` (776ms)
  ✔ test › detach child process (948ms)
  ✔ test › execPath option (2s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (2.5s)
  ✔ stream › input option can be a String - sync (1.4s)
  ✔ stream › input option can be a Buffer - sync (781ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (477ms)
  ✔ stream › buffer (2.8s)
  ✔ stream › pass `stdout` to a file descriptor (2.8s)
  ✔ stream › pass `stderr` to a file descriptor (2.8s)
  ✔ stream › result.all is undefined unless opts.all is true (2.7s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.7s)
  ✔ stream › input option can be a String (1.9s)
  ✔ stream › input option can be a Buffer (1.8s)
  ✔ stream › you can write to child.stdin (1.7s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (750ms)
  ✔ stream › input can be a Stream (1.9s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (773ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (762ms)
  ✔ stream › do not buffer when streaming (754ms)
  ✔ stream › buffer: false > promise resolves (823ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (955ms)
  ✔ stream › buffer: false > promise resolves when output is big and is read (927ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (829ms)
  ✔ stream › maxBuffer affects stdout (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (924ms)
  ✔ stream › can use all: true with stderr: ignore (855ms)
  ✔ stream › maxBuffer affects stderr (1.2s)
  ✔ stream › can use all: true with stdout: ignore (936ms)
  ✔ test › preferLocal: true (3.8s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsFile/execa/variant19/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/command.js

  ReferenceError: lyx is not defined

  › getSignals (file://node_modules/human-signals/build/src/signals.js:9:3)
  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:15)
  › file://node_modules/human-signals/build/src/main.js:28:28

  Uncaught exception in test/error.js

  ReferenceError: lyx is not defined

  › getSignals (file://node_modules/human-signals/build/src/signals.js:9:3)
  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:15)
  › file://node_modules/human-signals/build/src/main.js:28:28

  ✖ test/error.js exited with a non-zero exit code: 1
  ✖ test/command.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  ReferenceError: lyx is not defined

  › getSignals (file://node_modules/human-signals/build/src/signals.js:9:3)
  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:15)
  › file://node_modules/human-signals/build/src/main.js:28:28

  ✖ test/kill.js exited with a non-zero exit code: 1

  Uncaught exception in test/node.js

  ReferenceError: lyx is not defined

  › getSignals (file://node_modules/human-signals/build/src/signals.js:9:3)
  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:15)
  › file://node_modules/human-signals/build/src/main.js:28:28

  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  ReferenceError: lyx is not defined

  › getSignals (file://node_modules/human-signals/build/src/signals.js:9:3)
  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:15)
  › file://node_modules/human-signals/build/src/main.js:28:28

  Uncaught exception in test/promise.js

  ReferenceError: lyx is not defined

  › getSignals (file://node_modules/human-signals/build/src/signals.js:9:3)
  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:15)
  › file://node_modules/human-signals/build/src/main.js:28:28

  ✖ test/promise.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }

  Uncaught exception in test/stream.js

  ReferenceError: lyx is not defined

  › getSignals (file://node_modules/human-signals/build/src/signals.js:9:3)
  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:15)
  › file://node_modules/human-signals/build/src/main.js:28:28

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  ReferenceError: lyx is not defined

  › getSignals (file://node_modules/human-signals/build/src/signals.js:9:3)
  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:15)
  › file://node_modules/human-signals/build/src/main.js:28:28

  ✖ test/test.js exited with a non-zero exit code: 1

  ✖ Timed out while running tests

  ─

  36 tests passed
  8 uncaught exceptions
-------------|---------|----------|---------|---------|---------------------------------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                           
-------------|---------|----------|---------|---------|---------------------------------------------
All files    |   27.32 |      100 |    8.33 |   27.32 |                                             
 execa       |    13.1 |      100 |       0 |    13.1 |                                             
  index.js   |    13.1 |      100 |       0 |    13.1 | ...2,76-162,165-225,228-230,233-235,238-267 
 execa/lib   |   36.84 |      100 |   10.71 |   36.84 |                                             
  command.js |    43.9 |      100 |       0 |    43.9 | 2-6,13-17,28-40                             
  error.js   |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                  
  kill.js    |   36.27 |      100 |       0 |   36.27 | ...-29,38-46,51-55,59-60,65-80,84-86,91-101 
  promise.js |   30.55 |      100 |       0 |   30.55 | 3-4,9-18,23-35                              
  stdio.js   |     100 |      100 |     100 |     100 |                                             
  stream.js  |   29.06 |      100 |       0 |   29.06 | 7-15,20-34,39-49,53-61,66-79,83-85          
-------------|---------|----------|---------|---------|---------------------------------------------
./VariantsFile/execa/variant18/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/error.js

  ReferenceError: lyx is not defined

  › getRealtimeSignals (file://node_modules/human-signals/build/src/realtime.js:3:3)
  › getSignals (file://node_modules/human-signals/build/src/signals.js:9:23)
  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:15)
  › file://node_modules/human-signals/build/src/main.js:28:28

  Uncaught exception in test/command.js

  ReferenceError: lyx is not defined

  › getRealtimeSignals (file://node_modules/human-signals/build/src/realtime.js:3:3)
  › getSignals (file://node_modules/human-signals/build/src/signals.js:9:23)
  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:15)
  › file://node_modules/human-signals/build/src/main.js:28:28

  ✖ test/error.js exited with a non-zero exit code: 1
  ✖ test/command.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  ReferenceError: lyx is not defined

  › getRealtimeSignals (file://node_modules/human-signals/build/src/realtime.js:3:3)
  › getSignals (file://node_modules/human-signals/build/src/signals.js:9:23)
  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:15)
  › file://node_modules/human-signals/build/src/main.js:28:28

  Uncaught exception in test/node.js

  ReferenceError: lyx is not defined

  › getRealtimeSignals (file://node_modules/human-signals/build/src/realtime.js:3:3)
  › getSignals (file://node_modules/human-signals/build/src/signals.js:9:23)
  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:15)
  › file://node_modules/human-signals/build/src/main.js:28:28

  ✖ test/kill.js exited with a non-zero exit code: 1
  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  ReferenceError: lyx is not defined

  › getRealtimeSignals (file://node_modules/human-signals/build/src/realtime.js:3:3)
  › getSignals (file://node_modules/human-signals/build/src/signals.js:9:23)
  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:15)
  › file://node_modules/human-signals/build/src/main.js:28:28

  Uncaught exception in test/promise.js

  ReferenceError: lyx is not defined

  › getRealtimeSignals (file://node_modules/human-signals/build/src/realtime.js:3:3)
  › getSignals (file://node_modules/human-signals/build/src/signals.js:9:23)
  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:15)
  › file://node_modules/human-signals/build/src/main.js:28:28

  ✖ test/promise.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }

  Uncaught exception in test/stream.js

  ReferenceError: lyx is not defined

  › getRealtimeSignals (file://node_modules/human-signals/build/src/realtime.js:3:3)
  › getSignals (file://node_modules/human-signals/build/src/signals.js:9:23)
  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:15)
  › file://node_modules/human-signals/build/src/main.js:28:28

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  ReferenceError: lyx is not defined

  › getRealtimeSignals (file://node_modules/human-signals/build/src/realtime.js:3:3)
  › getSignals (file://node_modules/human-signals/build/src/signals.js:9:23)
  › getSignalsByName (file://node_modules/human-signals/build/src/main.js:9:15)
  › file://node_modules/human-signals/build/src/main.js:28:28

  ✖ test/test.js exited with a non-zero exit code: 1

  ✖ Timed out while running tests

  ─

  36 tests passed
  8 uncaught exceptions
-------------|---------|----------|---------|---------|---------------------------------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                           
-------------|---------|----------|---------|---------|---------------------------------------------
All files    |   27.32 |      100 |    8.33 |   27.32 |                                             
 execa       |    13.1 |      100 |       0 |    13.1 |                                             
  index.js   |    13.1 |      100 |       0 |    13.1 | ...2,76-162,165-225,228-230,233-235,238-267 
 execa/lib   |   36.84 |      100 |   10.71 |   36.84 |                                             
  command.js |    43.9 |      100 |       0 |    43.9 | 2-6,13-17,28-40                             
  error.js   |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                  
  kill.js    |   36.27 |      100 |       0 |   36.27 | ...-29,38-46,51-55,59-60,65-80,84-86,91-101 
  promise.js |   30.55 |      100 |       0 |   30.55 | 3-4,9-18,23-35                              
  stdio.js   |     100 |      100 |     100 |     100 |                                             
  stream.js  |   29.06 |      100 |       0 |   29.06 | 7-15,20-34,39-49,53-61,66-79,83-85          
-------------|---------|----------|---------|---------|---------------------------------------------
./VariantsFile/execa/variant17/execa

> execa@6.1.0 test
> xo && c8 ava && tsd

./VariantsFile/execa/variant16/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (754ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (2s)
  ✔ error › result.killed is false if not killed, in sync mode (921ms)
  ✔ error › result.killed is false on process error, in sync mode (239ms)
  ✔ error › Original error.message is kept (1.5s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (309ms)
  ✔ error › stdout/stderr/all on process errors (2.1s)
  ✔ error › stdout/stderr/all available on errors (2.2s)
  ✔ error › exitCode is 0 on success (2.1s)
  ✔ error › exitCode is 2 (2s)
  ✔ error › exitCode is 3 (2s)
  ✔ error › exitCode is 4 (1.9s)
  ✔ error › error.message contains the command (1.9s)
  ✔ error › error.message contains stdout/stderr if available (1.8s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.7s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.7s)
  ✔ error › failed is false on success (1.6s)
  ✔ error › failed is true on failure (1.5s)
  ✔ error › error.killed is true if process was killed directly (1.3s)
  ✔ error › error.killed is false if process was killed indirectly (1.2s)
  ✔ error › result.killed is false if not killed (1.1s)
  ✔ error › error.signal is SIGINT (352ms)
  ✔ error › error.signalDescription is defined (333ms)
  ✔ error › error.signal is SIGTERM (315ms)
  ✔ error › exitCode is undefined on signal termination (310ms)
  ✔ error › custom error.signal (329ms)
  ✔ error › error.code is undefined on success (379ms)
  ✔ error › result.signal is undefined for successful execution (504ms)
  ✔ error › result.signalDescription is undefined for successful execution (476ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (549ms)
  ✔ command › allow commands with spaces and no array arguments (3s)
  ✔ command › allow commands with spaces and array arguments (2.8s)
  ✔ command › execaCommand() (2.8s)
  ✔ command › execaCommand() ignores consecutive spaces (2.7s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.6s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.5s)
  ✔ command › execaCommand() escapes other whitespaces (2.4s)
  ✔ command › execaCommand() trims (2.3s)
  ✔ command › command is: " foo bar" (3.3s)
  ✔ command › command is: " baz quz" (3.2s)
  ✔ command › command is: "" (3.2s)
  ✔ command › escapedCommand is: "foo bar" (3.4s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.6s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3.9s)
  ✔ command › escapedCommand is: "\"*\"" (4.2s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.6s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.6s)
  ✔ kill › execa() returns a promise with kill() (3.5s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3.3s)
  ✔ kill › cancel method kills the subprocess (2.5s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (1.1s)
  ✔ kill › timeout kills the process if it times out, in sync mode (3.5s)
  ✔ kill › timeout must not be negative (3.4s)
  ✔ kill › timeout must be an integer (3.4s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel (107ms)
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (136ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (211ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (253ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.8s)
  ✔ kill › timeout does not kill the process if it does not time out (3.6s)
  ✔ kill › timedOut is false if timeout is undefined (3.5s)
  ✔ kill › timedOut is false if timeout is 0 (3.5s)
  ✔ kill › spawnAndExit (3.1s)
  ✔ kill › spawnAndExit cleanup (3s)
  ✔ kill › spawnAndExit detached (3s)
  ✔ kill › spawnAndExit cleanup detached (3s)
  ✔ kill › spawnAndKill SIGTERM (2.9s)
  ✔ kill › spawnAndKill SIGKILL (2.9s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.9s)
  ✔ kill › spawnAndKill detached SIGTERM (2.8s)
  ✔ kill › spawnAndKill detached SIGKILL (2.8s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.8s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.8s)
  ✔ kill › removes exit handler on exit (2.7s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.6s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.5s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (599ms)
  ✔ kill › error.isCanceled is true when cancel method is used (554ms)
  ✔ kill › error.isCanceled is false when kill method is used (517ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (464ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (425ms)
  ✔ kill › timeout kills the process if it times out (3.7s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (4s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (476ms)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (273ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.9s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.9s)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (121ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process (103ms)
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process (102ms)
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process (107ms)
  ✔ node › node should not remove --inspect when passed through nodeOptions (111ms)
  ✔ node › node correctly use nodePath
  ✔ node › node() (165ms)
  ✔ node › node's forked script has a communication channel (226ms)
  ✔ node › node pass on nodeOptions (266ms)
  ✔ node › node pipe stdout (322ms)
  ✔ override-promise › should work with third-party Promise (151ms)
  ✔ promise › promise methods are not enumerable (108ms)
  ✔ promise › finally function is executed on failure (277ms)
  ✔ promise › throw in finally function bubbles up on success (329ms)
  ✔ promise › throw in finally bubbles up on error (328ms)
  ✔ promise › finally function is executed on success (383ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.8s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.8s)
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ test › execaSync() (2.3s)
  ✔ test › execaSync() throws error if written to stderr (2.1s)
  ✔ test › skip throwing when using reject option in sync mode (2.1s)
  ✔ test › stripFinalNewline in sync mode (2s)
  ✔ test › stripFinalNewline in sync mode on failure (1.7s)
  ✔ test › execa() returns a promise with pid (986ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (923ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (833ms)
  ✔ test › child_process.spawn() errors are propagated (947ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (764ms)
  ✔ test › execa() rejects if running non-executable (875ms)
  ✔ test › preferLocal: undefined (1.3s)
  ✔ test › preferLocal: false (1.4s)
  ✔ test › child process errors rejects promise right away (1.3s)
  ✔ test › child process errors are handled (1.3s)
  ✔ test › stdin errors are handled (1.4s)
  ✔ test › execa() (2.7s)
  ✔ test › skip throwing when using reject option (2.5s)
  ✔ test › stripFinalNewline: true (2.3s)
  ✔ test › stripFinalNewline: false (2.3s)
  ✔ test › stripFinalNewline on failure (2.3s)
  ✔ test › localDir option (1.5s)
  ✔ test › do not try to consume streams twice (1.1s)
  ✔ test › use relative path with '..' chars (1s)
  ✔ test › write to fast-exit process (870ms)
  ✔ test › can use `options.cwd` as a string (710ms)
  ✔ test › localDir option can be a URL (689ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (442ms)
  ✔ test › use environment variables by default (840ms)
  ✔ test › extend environment variables by default (785ms)
  ✔ test › do not extend environment with `extendEnv: false` (756ms)
  ✔ test › can use `options.cwd` as a URL (640ms)
  ✔ test › can use `options.shell: true` (724ms)
  ✔ test › execPath option (1.6s)
  ✔ test › can use `options.shell: string` (706ms)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (2.5s)
  ✔ stream › input option can be a String - sync (1.9s)
  ✔ stream › input option can be a Buffer - sync (1.2s)
  ✔ stream › helpful error trying to provide an input stream in sync mode (533ms)
  ✔ stream › buffer (2.8s)
  ✔ stream › pass `stdout` to a file descriptor (2.7s)
  ✔ stream › pass `stderr` to a file descriptor (2.7s)
  ✔ stream › result.all is undefined unless opts.all is true (2.6s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.6s)
  ✔ test › detach child process (1.1s)
  ✔ stream › input option can be a String (2.4s)
  ✔ stream › input option can be a Buffer (2.3s)
  ✔ stream › input can be a Stream (2.3s)
  ✔ stream › you can write to child.stdin (2.2s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (845ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (738ms)
  ✔ stream › do not buffer when streaming (749ms)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (1s)
  ✔ stream › buffer: false > promise resolves (924ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (852ms)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1s)
  ✔ stream › maxBuffer affects stdout (1.2s)
  ✔ stream › can use all: true with stdout: ignore (984ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1.1s)
  ✔ stream › can use all: true with stderr: ignore (934ms)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.1s)
  ✔ stream › maxBuffer affects stderr (1.4s)
  ✔ test › preferLocal: true (3.6s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsFile/execa/variant15/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (904ms)
  ✖ command › command is: " foo bar" Rejected promise returned by test
  ✖ command › command is: " baz quz" Rejected promise returned by test
  ✖ command › command is: "" Rejected promise returned by test
  ✖ command › escapedCommand is: "foo bar" Rejected promise returned by test
  ✖ command › escapedCommand is: "\"foo bar\"" Rejected promise returned by test
  ✖ command › escapedCommand is: "\"\\\"foo\\\"\"" Rejected promise returned by test
  ✖ command › escapedCommand is: "\"*\"" Rejected promise returned by test
  ✖ command › allow commands with spaces and no array arguments Rejected promise returned by test
  ✖ command › allow commands with spaces and array arguments Rejected promise returned by test
  ✖ command › execaCommand() Rejected promise returned by test
  ✖ command › execaCommand() ignores consecutive spaces Rejected promise returned by test
  ✖ command › execaCommand() allows escaping spaces in commands Rejected promise returned by test
  ✖ command › execaCommand() allows escaping spaces in arguments Rejected promise returned by test
  ✖ command › execaCommand() escapes other whitespaces Rejected promise returned by test
  ✖ command › execaCommand() trims Rejected promise returned by test
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.9s)
  ✔ error › result.killed is false if not killed, in sync mode (987ms)
  ✔ error › result.killed is false on process error, in sync mode (355ms)
  ✖ error › stdout/stderr/all available on errors Rejected promise returned by test
  ✖ error › stdout/stderr/all on process errors Rejected promise returned by test
  ✖ error › exitCode is 0 on success Rejected promise returned by test
  ✖ error › exitCode is 2 Rejected promise returned by test
  ✖ error › exitCode is 3 Rejected promise returned by test
  ✖ error › exitCode is 4 Rejected promise returned by test
  ✖ error › error.message contains the command Rejected promise returned by test
  ✖ error › error.message contains stdout/stderr if available Rejected promise returned by test
  ✖ error › error.message does not contain stdout/stderr if not available Rejected promise returned by test
  ✖ error › error.shortMessage does not contain stdout/stderr Rejected promise returned by test
  ✖ error › failed is false on success Rejected promise returned by test
  ✖ error › failed is true on failure Rejected promise returned by test
  ✖ error › error.killed is true if process was killed directly Rejected promise returned by test
  ✖ error › error.killed is false if process was killed indirectly Rejected promise returned by test
  ✖ error › result.killed is false if not killed Rejected promise returned by test
  ✖ error › result.killed is false on process error Rejected promise returned by test
  ✖ error › error.signal is SIGINT Rejected promise returned by test
  ✖ error › error.signalDescription is defined Rejected promise returned by test
  ✖ error › error.signal is SIGTERM Rejected promise returned by test
  ✖ error › custom error.signal Rejected promise returned by test
  ✖ error › exitCode is undefined on signal termination Rejected promise returned by test
  ✖ error › result.signal is undefined for successful execution Rejected promise returned by test
  ✖ error › result.signal is undefined if process failed, but was not killed Rejected promise returned by test
  ✖ error › result.signalDescription is undefined for successful execution Rejected promise returned by test
  ✖ error › error.code is undefined on success Rejected promise returned by test
  ✔ error › Original error.message is kept (1.4s)
  ✔ error › error.code is defined on failure if applicable (172ms)

  Unhandled rejection in test/error.js

  Error: spawn wrong command ENOENT

  Unhandled rejection in test/error.js

  Error: spawn wrong command ENOENT

  ✖ node › node removes --inspect from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect=9222 from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect-brk from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node should not remove --inspect when passed through nodeOptions Rejected promise returned by test
  ✖ node › node() Rejected promise returned by test
  ✖ node › node pipe stdout Rejected promise returned by test
  ✖ node › node correctly use nodePath Rejected promise returned by test
  ✖ node › node pass on nodeOptions Rejected promise returned by test
  ✖ node › node's forked script has a communication channel Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout` should not be NaN 
  ✖ kill › `forceKillAfterTimeout` should not be negative 
  ✖ kill › execa() returns a promise with kill() Error thrown in test
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3.6s)
  ✖ kill › cancel method kills the subprocess Error thrown in test
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2.5s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (1.1s)
  ✖ kill › kill("SIGKILL") should terminate cleanly Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout: false` should not kill after a timeout Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout: number` should kill after a timeout Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout: true` should kill after a timeout Rejected promise returned by test
  ✖ kill › kill() with no arguments should kill after a timeout Rejected promise returned by test
  ✖ kill › timeout kills the process if it times out Rejected promise returned by test
  ✖ kill › timeout does not kill the process if it does not time out Rejected promise returned by test
  ✖ kill › timedOut is false if timeout is undefined Rejected promise returned by test
  ✖ kill › timedOut is false if timeout is 0 Rejected promise returned by test
  ✖ kill › spawnAndExit Rejected promise returned by test
  ✖ kill › spawnAndExit cleanup Rejected promise returned by test
  ✖ kill › spawnAndExit detached Rejected promise returned by test
  ✖ kill › spawnAndExit cleanup detached Rejected promise returned by test
  ✖ kill › spawnAndKill SIGTERM Rejected promise returned by test
  ✖ kill › spawnAndKill SIGKILL Rejected promise returned by test
  ✖ kill › spawnAndKill cleanup SIGTERM Rejected promise returned by test
  ✖ kill › spawnAndKill cleanup SIGKILL Rejected promise returned by test
  ✖ kill › spawnAndKill detached SIGTERM Rejected promise returned by test
  ✖ kill › spawnAndKill detached SIGKILL Rejected promise returned by test
  ✖ kill › spawnAndKill cleanup detached SIGTERM Rejected promise returned by test
  ✖ kill › spawnAndKill cleanup detached SIGKILL Rejected promise returned by test
  ✖ kill › removes exit handler on exit Rejected promise returned by test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called (success) Rejected promise returned by test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) Rejected promise returned by test
  ✖ kill › calling cancel method throws an error with message "Command was canceled" Rejected promise returned by test
  ✖ kill › error.isCanceled is true when cancel method is used Rejected promise returned by test
  ✖ kill › error.isCanceled is false when kill method is used Rejected promise returned by test
  ✖ kill › calling cancel method twice should show the same behaviour as calling it once Rejected promise returned by test
  ✖ kill › calling cancel method on a successfully completed process does not make result.isCanceled true Rejected promise returned by test
  ✖ kill › calling cancel method on a process which has been killed does not make error.isCanceled true Rejected promise returned by test
  ✖ kill › calling abort throws an error with message "Command was canceled" Rejected promise returned by test
  ✖ kill › calling abort twice should show the same behaviour as calling it once Rejected promise returned by test
  ✖ kill › calling abort on a successfully completed process does not make result.isCanceled true Rejected promise returned by test
  ✖ kill › calling cancel after abort should show the same behaviour as only calling cancel Rejected promise returned by test
  ✖ kill › calling abort after cancel should show the same behaviour as only calling cancel Rejected promise returned by test
  ✔ kill › timeout kills the process if it times out, in sync mode (3.9s)
  ✔ kill › timeout must not be negative (3.8s)
  ✔ kill › timeout must be an integer (3.8s)
  ✖ override-promise › should work with third-party Promise Rejected promise returned by test
  ✖ promise › promise methods are not enumerable Error thrown in test
  ✖ promise › finally function is executed on success Rejected promise returned by test
  ✖ promise › finally function is executed on failure Rejected promise returned by test
  ✖ promise › throw in finally function bubbles up on success Rejected promise returned by test
  ✖ promise › throw in finally bubbles up on error Rejected promise returned by test
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✖ stream › result.all shows both `stdout` and `stderr` intermixed Rejected promise returned by test
  ✖ stream › buffer: false > promise does not resolve when output is big and is not read Rejected promise returned by test
  ✖ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read Rejected promise returned by test
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.3s)
  ✔ stream › input option can be a String - sync (897ms)
  ✔ stream › input option can be a Buffer - sync (601ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (471ms)
  ✖ stream › buffer Rejected promise returned by test
  ✖ stream › pass `stdout` to a file descriptor Rejected promise returned by test
  ✖ stream › pass `stderr` to a file descriptor Rejected promise returned by test
  ✖ stream › result.all is undefined unless opts.all is true Rejected promise returned by test
  ✖ stream › stdout/stderr/all are undefined if ignored Rejected promise returned by test
  ✖ stream › input option can be a String Rejected promise returned by test
  ✖ stream › input option can be a Buffer Rejected promise returned by test
  ✖ stream › input can be a Stream Rejected promise returned by test
  ✖ stream › you can write to child.stdin Rejected promise returned by test
  ✖ stream › opts.stdout:ignore - stdout will not collect data Rejected promise returned by test
  ✖ stream › maxBuffer affects stdout Rejected promise returned by test
  ✖ stream › maxBuffer affects stderr Rejected promise returned by test
  ✖ stream › do not buffer stdout when `buffer` set to `false` Rejected promise returned by test
  ✖ stream › do not buffer stderr when `buffer` set to `false` Rejected promise returned by test
  ✖ stream › do not buffer when streaming Rejected promise returned by test
  ✖ stream › buffer: false > promise resolves Rejected promise returned by test
  ✖ stream › buffer: false > promise resolves when output is big but is not pipable Rejected promise returned by test
  ✖ stream › buffer: false > promise resolves when output is big and is read Rejected promise returned by test
  ✖ stream › buffer: false > promise resolves when output is big and "all" is used and is read Rejected promise returned by test
  ✖ stream › buffer: false > promise rejects when process returns non-zero Rejected promise returned by test
  ✖ stream › can use all: true with stdout: ignore Rejected promise returned by test
  ✖ stream › can use all: true with stderr: ignore Rejected promise returned by test
  ✔ test › execaSync() (1.8s)
  ✔ test › execaSync() throws error if written to stderr (1.5s)
  ✔ test › skip throwing when using reject option in sync mode (1.5s)
  ✔ test › stripFinalNewline in sync mode (1.2s)
  ✔ test › stripFinalNewline in sync mode on failure (904ms)
  ✖ test › execa() returns a promise with pid Error thrown in test
  ✔ test › child_process.spawn() propagated errors have correct shape (673ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (587ms)
  ✖ test › execa() Rejected promise returned by test
  ✖ test › skip throwing when using reject option Rejected promise returned by test
  ✖ test › stripFinalNewline: true Rejected promise returned by test
  ✖ test › stripFinalNewline: false Rejected promise returned by test
  ✖ test › stripFinalNewline on failure Rejected promise returned by test
  ✖ test › preferLocal: true Rejected promise returned by test
  ✖ test › preferLocal: false Rejected promise returned by test
  ✖ test › preferLocal: undefined Rejected promise returned by test
  ✖ test › localDir option Rejected promise returned by test
  ✖ test › stdin errors are handled Rejected promise returned by test
  ✖ test › child process errors are handled Rejected promise returned by test
  ✖ test › child process errors rejects promise right away Rejected promise returned by test
  ✖ test › do not try to consume streams twice Rejected promise returned by test
  ✖ test › use relative path with '..' chars Rejected promise returned by test
  ✖ test › execa() rejects if running non-executable Rejected promise returned by test
  ✖ test › execa() rejects with correct error and doesn't throw if running non-executable with input Rejected promise returned by test
  ✖ test › write to fast-exit process 
  ✖ test › use environment variables by default Rejected promise returned by test
  ✖ test › extend environment variables by default Rejected promise returned by test
  ✖ test › do not extend environment with `extendEnv: false` Rejected promise returned by test
  ✖ test › can use `options.cwd` as a string Rejected promise returned by test
  ✖ test › localDir option can be a URL Rejected promise returned by test
  ✖ test › can use `options.cwd` as a URL Rejected promise returned by test
  ✖ test › can use `options.shell: true` Rejected promise returned by test
  ✖ test › can use `options.shell: string` Rejected promise returned by test
  ✖ test › use extend environment with `extendEnv: true` and `shell: true` Rejected promise returned by test
  ✖ test › detach child process Rejected promise returned by test
  ✔ test › child_process.spawn() errors are propagated (771ms)
  ✖ test › execPath option Rejected promise returned by test

  Unhandled rejection in test/test.js

  Error: spawn ava ENOENT

  Unhandled rejection in test/test.js

  Error: spawn ava ENOENT

  Unhandled rejection in test/test.js

  Error: spawn non-executable.js EACCES

  Unhandled rejection in test/test.js

  Error: spawn non-executable.js EACCES

  ─

  command › command is: " foo bar"

  test/command.js:8

   7: const command = async (t, expected, ...args) => {                         
   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › command (file://test/command.js:8:53)



  command › command is: " baz quz"

  test/command.js:8

   7: const command = async (t, expected, ...args) => {                         
   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › command (file://test/command.js:8:53)



  command › command is: ""

  test/command.js:8

   7: const command = async (t, expected, ...args) => {                         
   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › command (file://test/command.js:8:53)



  command › escapedCommand is: "foo bar"

  test/command.js:22

   21: const testEscapedCommand = async (t, expected, args) => {                
   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testEscapedCommand (file://test/command.js:22:67)



  command › escapedCommand is: "\"foo bar\""

  test/command.js:22

   21: const testEscapedCommand = async (t, expected, args) => {                
   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testEscapedCommand (file://test/command.js:22:67)



  command › escapedCommand is: "\"\\\"foo\\\"\""

  test/command.js:22

   21: const testEscapedCommand = async (t, expected, args) => {                
   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testEscapedCommand (file://test/command.js:22:67)



  command › escapedCommand is: "\"*\""

  test/command.js:22

   21: const testEscapedCommand = async (t, expected, args) => {                
   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testEscapedCommand (file://test/command.js:22:67)



  command › allow commands with spaces and no array arguments

  test/command.js:45

   44: test('allow commands with spaces and no array arguments', async t => {
   45:   const {stdout} = await execa('command with space.js');              
   46:   t.is(stdout, '');                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/command.js:45:25



  command › allow commands with spaces and array arguments

  test/command.js:50

   49: test('allow commands with spaces and array arguments', async t => {     
   50:   const {stdout} = await execa('command with space.js', ['foo', 'bar']);
   51:   t.is(stdout, 'foo\nbar');                                             

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/command.js:50:25



  command › execaCommand()

  test/command.js:55

   54: test('execaCommand()', async t => {                                      
   55:   const {stdout} = await execaCommand('node test/fixtures/echo.js foo ba…
   56:   t.is(stdout, 'foo\nbar');                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:55:25



  command › execaCommand() ignores consecutive spaces

  test/command.js:60

   59: test('execaCommand() ignores consecutive spaces', async t => {           
   60:   const {stdout} = await execaCommand('node test/fixtures/echo.js foo   …
   61:   t.is(stdout, 'foo\nbar');                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:60:25



  command › execaCommand() allows escaping spaces in commands

  test/command.js:65

   64: test('execaCommand() allows escaping spaces in commands', async t => {   
   65:   const {stdout} = await execaCommand('command\\ with\\ space.js foo bar…
   66:   t.is(stdout, 'foo\nbar');                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:65:25



  command › execaCommand() allows escaping spaces in arguments

  test/command.js:70

   69: test('execaCommand() allows escaping spaces in arguments', async t => {  
   70:   const {stdout} = await execaCommand('node test/fixtures/echo.js foo\\ …
   71:   t.is(stdout, 'foo bar');                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:70:25



  command › execaCommand() escapes other whitespaces

  test/command.js:75

   74: test('execaCommand() escapes other whitespaces', async t => {            
   75:   const {stdout} = await execaCommand('node test/fixtures/echo.js foo\tb…
   76:   t.is(stdout, 'foo\tbar');                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:75:25



  command › execaCommand() trims

  test/command.js:80

   79: test('execaCommand() trims', async t => {                                
   80:   const {stdout} = await execaCommand('  node test/fixtures/echo.js foo …
   81:   t.is(stdout, 'foo\nbar');                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:80:25



  error › stdout/stderr/all available on errors

  test/error.js:17

   16: test('stdout/stderr/all available on errors', async t => {               
   17:   const {stdout, stderr, all} = await t.throwsAsync(execa('exit.js', ['2…
   18:   t.is(typeof stdout, 'string');                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:17:52



  error › stdout/stderr/all on process errors

  test/error.js:28

   27: test('stdout/stderr/all on process errors', async t => {                 
   28:   const {stdout, stderr, all} = await t.throwsAsync(execa('wrong command…
   29:   t.is(stdout, '');                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:28:52



  error › exitCode is 0 on success

  test/error.js:44

   43: test('exitCode is 0 on success', async t => {        
   44:   const {exitCode} = await execa('noop.js', ['foo']);
   45:   t.is(exitCode, 0);                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:44:27



  error › exitCode is 2

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testExitCode (file://test/error.js:49:41)



  error › exitCode is 3

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testExitCode (file://test/error.js:49:41)



  error › exitCode is 4

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › testExitCode (file://test/error.js:49:41)



  error › error.message contains the command

  test/error.js:58

   57: test('error.message contains the command', async t => {                  
   58:   await t.throwsAsync(execa('exit.js', ['2', 'foo', 'bar']), {message: /…
   59: });                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:58:22



  error › error.message contains stdout/stderr if available

  test/error.js:62

   61: test('error.message contains stdout/stderr if available', async t => {
   62:   const {message} = await t.throwsAsync(execa('echo-fail.js'));       
   63:   t.true(message.includes('stderr'));                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:62:40



  error › error.message does not contain stdout/stderr if not available

  test/error.js:68

   67: test('error.message does not contain stdout/stderr if not available', as…
   68:   const {message} = await t.throwsAsync(execa('echo-fail.js', {stdio: 'i…
   69:   t.false(message.includes('stderr'));                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:68:40



  error › error.shortMessage does not contain stdout/stderr

  test/error.js:74

   73: test('error.shortMessage does not contain stdout/stderr', async t => {
   74:   const {shortMessage} = await t.throwsAsync(execa('echo-fail.js'));  
   75:   t.false(shortMessage.includes('stderr'));                           

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:74:45



  error › failed is false on success

  test/error.js:85

   84: test('failed is false on success', async t => {    
   85:   const {failed} = await execa('noop.js', ['foo']);
   86:   t.false(failed);                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:85:25



  error › failed is true on failure

  test/error.js:90

   89: test('failed is true on failure', async t => {                  
   90:   const {failed} = await t.throwsAsync(execa('exit.js', ['2']));
   91:   t.true(failed);                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:90:39



  error › error.killed is true if process was killed directly

  test/error.js:95

   94: test('error.killed is true if process was killed directly', async t => {
   95:   const subprocess = execa('noop.js');                                  
   96:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:95:21



  error › error.killed is false if process was killed indirectly

  test/error.js:104

   103: test('error.killed is false if process was killed indirectly', async t …
   104:   const subprocess = execa('noop.js');                                  
   105:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:104:21



  error › result.killed is false if not killed

  test/error.js:115

   114: test('result.killed is false if not killed', async t => {
   115:   const {killed} = await execa('noop.js');               
   116:   t.false(killed);                                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:115:25



  error › result.killed is false on process error

  test/error.js:125

   124: test('result.killed is false on process error', async t => {   
   125:   const {killed} = await t.throwsAsync(execa('wrong command'));
   126:   t.false(killed);                                             

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:125:39



  error › error.signal is SIGINT

  test/error.js:150

   149:   test('error.signal is SIGINT', async t => {
   150:     const subprocess = execa('noop.js');     
   151:                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:150:22



  error › error.signalDescription is defined

  test/error.js:159

   158:   test('error.signalDescription is defined', async t => {
   159:     const subprocess = execa('noop.js');                 
   160:                                                          

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:159:22



  error › error.signal is SIGTERM

  test/error.js:168

   167:   test('error.signal is SIGTERM', async t => {
   168:     const subprocess = execa('noop.js');      
   169:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:168:22



  error › custom error.signal

  test/error.js:177

   176:   test('custom error.signal', async t => {                              
   177:     const {signal} = await t.throwsAsync(execa('noop.js', {killSignal: …
   178:     t.is(signal, 'SIGHUP');                                             

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:177:40



  error › exitCode is undefined on signal termination

  test/error.js:182

   181:   test('exitCode is undefined on signal termination', async t => {
   182:     const subprocess = execa('noop.js');                          
   183:                                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:182:22



  error › result.signal is undefined for successful execution

  test/error.js:192

   191: test('result.signal is undefined for successful execution', async t => {
   192:   const {signal} = await execa('noop.js');                              
   193:   t.is(signal, undefined);                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:192:25



  error › result.signal is undefined if process failed, but was not killed

  test/error.js:197

   196: test('result.signal is undefined if process failed, but was not killed'…
   197:   const {signal} = await t.throwsAsync(execa('exit.js', [2]), {message:…
   198:   t.is(signal, undefined);                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:197:39



  error › result.signalDescription is undefined for successful execution

  test/error.js:202

   201: test('result.signalDescription is undefined for successful execution', …
   202:   const {signalDescription} = await execa('noop.js');                   
   203:   t.is(signalDescription, undefined);                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:202:36



  error › error.code is undefined on success

  test/error.js:207

   206: test('error.code is undefined on success', async t => {
   207:   const {code} = await execa('noop.js');               
   208:   t.is(code, undefined);                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/error.js:207:23



  node › node removes --inspect from nodeOptions when defined by parent process

  test/node.js:13

   12:   try {                                                 
   13:     const subprocess = execaNode('console.log("foo")', {
   14:       reject: false,                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › inspectMacro (file://test/node.js:13:22)



  node › node removes --inspect=9222 from nodeOptions when defined by parent process

  test/node.js:13

   12:   try {                                                 
   13:     const subprocess = execaNode('console.log("foo")', {
   14:       reject: false,                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › inspectMacro (file://test/node.js:13:22)



  node › node removes --inspect-brk from nodeOptions when defined by parent process

  test/node.js:13

   12:   try {                                                 
   13:     const subprocess = execaNode('console.log("foo")', {
   14:       reject: false,                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › inspectMacro (file://test/node.js:13:22)



  node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process

  test/node.js:13

   12:   try {                                                 
   13:     const subprocess = execaNode('console.log("foo")', {
   14:       reject: false,                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › inspectMacro (file://test/node.js:13:22)



  node › node should not remove --inspect when passed through nodeOptions

  test/node.js:85

   84:   async t => {                                                      
   85:     const {stdout, stderr} = await execaNode('console.log("foo")', {
   86:       reject: false,                                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:85:34



  node › node()

  test/node.js:27

   26: test('node()', async t => {                                   
   27:   const {exitCode} = await execaNode('test/fixtures/noop.js');
   28:   t.is(exitCode, 0);                                          

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:27:27



  node › node pipe stdout

  test/node.js:32

   31: test('node pipe stdout', async t => {                                 
   32:   const {stdout} = await execaNode('test/fixtures/noop.js', ['foo'], {
   33:     stdout: 'pipe',                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:32:25



  node › node correctly use nodePath

  test/node.js:40

   39: test('node correctly use nodePath', async t => {                         
   40:   const {stdout} = await execaNode(process.platform === 'win32' ? 'hello…
   41:     stdout: 'pipe',                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:40:25



  node › node pass on nodeOptions

  test/node.js:50

   49: test('node pass on nodeOptions', async t => {             
   50:   const {stdout} = await execaNode('console.log("foo")', {
   51:     stdout: 'pipe',                                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:50:25



  node › node's forked script has a communication channel

  test/node.js:96

   95: test('node\'s forked script has a communication channel', async t => {
   96:   const subprocess = execaNode('test/fixtures/send.js');              
   97:   await pEvent(subprocess, 'message');                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:96:21



  kill › `forceKillAfterTimeout` should not be NaN

  test/kill.js:66

   65:   test('`forceKillAfterTimeout` should not be NaN', t => {               
   66:     t.throws(() => {                                                     
   67:       execa('noop.js').kill('SIGTERM', {forceKillAfterTimeout: Number.Na…

  Function threw unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected instance of:

  Function TypeError {}

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › t.throws.instanceOf (file://test/kill.js:67:4)
  › file://test/kill.js:66:5



  kill › `forceKillAfterTimeout` should not be negative

  test/kill.js:72

   71:   test('`forceKillAfterTimeout` should not be negative', t => {     
   72:     t.throws(() => {                                                
   73:       execa('noop.js').kill('SIGTERM', {forceKillAfterTimeout: -1});

  Function threw unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected instance of:

  Function TypeError {}

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › t.throws.instanceOf (file://test/kill.js:73:4)
  › file://test/kill.js:72:5



  kill › execa() returns a promise with kill()

  test/kill.js:79

   78: test('execa() returns a promise with kill()', t => {
   79:   const {kill} = execa('noop.js', ['foo']);         
   80:   t.is(typeof kill, 'function');                    

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:79:17



  kill › cancel method kills the subprocess

  test/kill.js:195

   194: test('cancel method kills the subprocess', t => {
   195:   const subprocess = execa('node');              
   196:   subprocess.cancel();                           

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:195:21



  kill › kill("SIGKILL") should terminate cleanly

  test/kill.js:13

   12: test('kill("SIGKILL") should terminate cleanly', async t => {            
   13:   const subprocess = execa('node', ['./test/fixtures/no-killable.js'], {…
   14:   await pEvent(subprocess, 'message');                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:13:21



  kill › `forceKillAfterTimeout: false` should not kill after a timeout

  test/kill.js:26

   25:   test('`forceKillAfterTimeout: false` should not kill after a timeout',…
   26:     const subprocess = execa('node', ['./test/fixtures/no-killable.js'],…
   27:     await pEvent(subprocess, 'message');                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:26:22



  kill › `forceKillAfterTimeout: number` should kill after a timeout

  test/kill.js:36

   35:   test('`forceKillAfterTimeout: number` should kill after a timeout', as…
   36:     const subprocess = execa('node', ['./test/fixtures/no-killable.js'],…
   37:     await pEvent(subprocess, 'message');                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:36:22



  kill › `forceKillAfterTimeout: true` should kill after a timeout

  test/kill.js:46

   45:   test('`forceKillAfterTimeout: true` should kill after a timeout', asyn…
   46:     const subprocess = execa('node', ['./test/fixtures/no-killable.js'],…
   47:     await pEvent(subprocess, 'message');                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:46:22



  kill › kill() with no arguments should kill after a timeout

  test/kill.js:56

   55:   test('kill() with no arguments should kill after a timeout', async t =…
   56:     const subprocess = execa('node', ['./test/fixtures/no-killable.js'],…
   57:     await pEvent(subprocess, 'message');                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:56:22



  kill › timeout kills the process if it times out

  test/kill.js:84

   83: test('timeout kills the process if it times out', async t => {           
   84:   const {killed, timedOut} = await t.throwsAsync(execa('noop.js', {timeo…
   85:   t.false(killed);                                                       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:84:49



  kill › timeout does not kill the process if it does not time out

  test/kill.js:98

   97: test('timeout does not kill the process if it does not time out', async …
   98:   const {timedOut} = await execa('delay.js', ['500'], {timeout: 1e8});   
   99:   t.false(timedOut);                                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:98:27



  kill › timedOut is false if timeout is undefined

  test/kill.js:117

   116: test('timedOut is false if timeout is undefined', async t => {
   117:   const {timedOut} = await execa('noop.js');                  
   118:   t.false(timedOut);                                          

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:117:27



  kill › timedOut is false if timeout is 0

  test/kill.js:122

   121: test('timedOut is false if timeout is 0', async t => {    
   122:   const {timedOut} = await execa('noop.js', {timeout: 0});
   123:   t.false(timedOut);                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:122:27



  kill › spawnAndExit

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndExit (file://test/kill.js:133:25)



  kill › spawnAndExit cleanup

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndExit (file://test/kill.js:133:25)



  kill › spawnAndExit detached

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndExit (file://test/kill.js:133:25)



  kill › spawnAndExit cleanup detached

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndExit (file://test/kill.js:133:25)



  kill › spawnAndKill SIGTERM

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill SIGKILL

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill cleanup SIGTERM

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill cleanup SIGKILL

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill detached SIGTERM

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill detached SIGKILL

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill cleanup detached SIGTERM

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill cleanup detached SIGKILL

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › removes exit handler on exit

  test/kill.js:182

   181:                                                    
   182:   const subprocess = execa('noop.js');             
   183:   const listener = emitter.listeners('exit').pop();

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:182:21



  kill › result.isCanceled is false when spawned.cancel() isn't called (success)

  test/kill.js:201

   200: test('result.isCanceled is false when spawned.cancel() isn\'t called (s…
   201:   const {isCanceled} = await execa('noop.js');                          
   202:   t.false(isCanceled);                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:201:29



  kill › result.isCanceled is false when spawned.cancel() isn't called (failure)

  test/kill.js:206

   205: test('result.isCanceled is false when spawned.cancel() isn\'t called (f…
   206:   const {isCanceled} = await t.throwsAsync(execa('fail.js'));           
   207:   t.false(isCanceled);                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:206:43



  kill › calling cancel method throws an error with message "Command was canceled"

  test/kill.js:223

   222: test('calling cancel method throws an error with message "Command was c…
   223:   const subprocess = execa('noop.js');                                  
   224:   subprocess.cancel();                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:223:21



  kill › error.isCanceled is true when cancel method is used

  test/kill.js:229

   228: test('error.isCanceled is true when cancel method is used', async t => {
   229:   const subprocess = execa('noop.js');                                  
   230:   subprocess.cancel();                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:229:21



  kill › error.isCanceled is false when kill method is used

  test/kill.js:236

   235: test('error.isCanceled is false when kill method is used', async t => {
   236:   const subprocess = execa('noop.js');                                 
   237:   subprocess.kill();                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:236:21



  kill › calling cancel method twice should show the same behaviour as calling it once

  test/kill.js:243

   242: test('calling cancel method twice should show the same behaviour as cal…
   243:   const subprocess = execa('noop.js');                                  
   244:   subprocess.cancel();                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:243:21



  kill › calling cancel method on a successfully completed process does not make result.isCanceled true

  test/kill.js:252

   251: test('calling cancel method on a successfully completed process does no…
   252:   const subprocess = execa('noop.js');                                  
   253:   const {isCanceled} = await subprocess;                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:252:21



  kill › calling cancel method on a process which has been killed does not make error.isCanceled true

  test/kill.js:259

   258: test('calling cancel method on a process which has been killed does not…
   259:   const subprocess = execa('noop.js');                                  
   260:   subprocess.kill();                                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:259:21



  kill › calling abort throws an error with message "Command was canceled"

  test/kill.js:268

   267:     const abortController = new AbortController();                      
   268:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   269:     abortController.abort();                                            

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:268:22



  kill › calling abort twice should show the same behaviour as calling it once

  test/kill.js:275

   274:     const abortController = new AbortController();                      
   275:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   276:     abortController.abort();                                            

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:275:22



  kill › calling abort on a successfully completed process does not make result.isCanceled true

  test/kill.js:285

   284:     const abortController = new AbortController();                      
   285:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   286:     const {isCanceled} = await subprocess;                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:285:22



  kill › calling cancel after abort should show the same behaviour as only calling cancel

  test/kill.js:293

   292:     const abortController = new AbortController();                      
   293:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   294:     abortController.abort();                                            

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:293:22



  kill › calling abort after cancel should show the same behaviour as only calling cancel

  test/kill.js:303

   302:     const abortController = new AbortController();                      
   303:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   304:     subprocess.cancel();                                                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/kill.js:303:22



  override-promise › should work with third-party Promise

  test/override-promise.js:12

   11: test('should work with third-party Promise', async t => {
   12:   const {stdout} = await execa('noop.js', ['foo']);      
   13:   t.is(stdout, 'foo');                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/override-promise.js:12:25



  promise › promise methods are not enumerable

  test/promise.js:8

   7: test('promise methods are not enumerable', t => {                        
   8:   const descriptors = Object.getOwnPropertyDescriptors(execa('noop.js'));
   9:   t.false(descriptors.then.enumerable);                                  

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/promise.js:8:55



  promise › finally function is executed on success

  test/promise.js:16

   15:   let isCalled = false;                                           
   16:   const {stdout} = await execa('noop.js', ['foo']).finally(() => {
   17:     isCalled = true;                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/promise.js:16:25



  promise › finally function is executed on failure

  test/promise.js:25

   24:   let isError = false;                                                   
   25:   const {stdout, stderr} = await t.throwsAsync(execa('exit.js', ['2']).f…
   26:     isError = true;                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/promise.js:25:47



  promise › throw in finally function bubbles up on success

  test/promise.js:34

   33: test('throw in finally function bubbles up on success', async t => {     
   34:   const {message} = await t.throwsAsync(execa('noop.js', ['foo']).finall…
   35:     throw new Error('called');                                           

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/promise.js:34:40



  promise › throw in finally bubbles up on error

  test/promise.js:41

   40: test('throw in finally bubbles up on error', async t => {                
   41:   const {message} = await t.throwsAsync(execa('exit.js', ['2']).finally(…
   42:     throw new Error('called');                                           

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/promise.js:41:40



  stream › result.all shows both `stdout` and `stderr` intermixed

  test/stream.js:32

   31: test.serial('result.all shows both `stdout` and `stderr` intermixed', as…
   32:   const {all} = await execa('noop-132.js', {all: true});                 
   33:   t.is(all, '132');                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:32:22



  stream › buffer: false > promise does not resolve when output is big and is not read

  test/stream.js:189

   188:   test.serial('buffer: false > promise does not resolve when output is …
   189:     const {timedOut} = await t.throwsAsync(execa('max-buffer.js', {buff…
   190:     t.true(timedOut);                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:189:42



  stream › buffer: false > promise does not resolve when output is big and "all" is used but not read

  test/stream.js:194

   193:   test.serial('buffer: false > promise does not resolve when output is …
   194:     const subprocess = execa('max-buffer.js', {buffer: false, all: true…
   195:     subprocess.stdout.resume();                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:194:22



  stream › buffer

  test/stream.js:14

   13: test('buffer', async t => {                                          
   14:   const {stdout} = await execa('noop.js', ['foo'], {encoding: null});
   15:   t.true(Buffer.isBuffer(stdout));                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:14:25



  stream › pass `stdout` to a file descriptor

  test/stream.js:21

   20:   const file = tempfile('.txt');                                         
   21:   await execa('test/fixtures/noop.js', ['foo bar'], {stdout: fs.openSync…
   22:   t.is(fs.readFileSync(file, 'utf8'), 'foo bar\n');                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:21:8



  stream › pass `stderr` to a file descriptor

  test/stream.js:27

   26:   const file = tempfile('.txt');                                         
   27:   await execa('test/fixtures/noop-err.js', ['foo bar'], {stderr: fs.open…
   28:   t.is(fs.readFileSync(file, 'utf8'), 'foo bar\n');                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:27:8



  stream › result.all is undefined unless opts.all is true

  test/stream.js:37

   36: test('result.all is undefined unless opts.all is true', async t => {
   37:   const {all} = await execa('noop.js');                             
   38:   t.is(all, undefined);                                             

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:37:22



  stream › stdout/stderr/all are undefined if ignored

  test/stream.js:42

   41: test('stdout/stderr/all are undefined if ignored', async t => {          
   42:   const {stdout, stderr, all} = await execa('noop.js', {stdio: 'ignore',…
   43:   t.is(stdout, undefined);                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:42:38



  stream › input option can be a String

  test/stream.js:56

   55: test('input option can be a String', async t => {             
   56:   const {stdout} = await execa('stdin.js', {input: 'foobar'});
   57:   t.is(stdout, 'foobar');                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:56:25



  stream › input option can be a Buffer

  test/stream.js:61

   60: test('input option can be a Buffer', async t => {                
   61:   const {stdout} = await execa('stdin.js', {input: 'testing12'});
   62:   t.is(stdout, 'testing12');                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:61:25



  stream › input can be a Stream

  test/stream.js:69

   68:   stream.end();                                             
   69:   const {stdout} = await execa('stdin.js', {input: stream});
   70:   t.is(stdout, 'howdy');                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:69:25



  stream › you can write to child.stdin

  test/stream.js:74

   73: test('you can write to child.stdin', async t => {
   74:   const subprocess = execa('stdin.js');          
   75:   subprocess.stdin.end('unicorns');              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:74:21



  stream › opts.stdout:ignore - stdout will not collect data

  test/stream.js:91

   90: test('opts.stdout:ignore - stdout will not collect data', async t => {
   91:   const {stdout} = await execa('stdin.js', {                          
   92:     input: 'hello',                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:91:25



  stream › maxBuffer affects stdout

  test/stream.js:108

   107: test('maxBuffer affects stdout', async t => {                           
   108:   await t.notThrowsAsync(execa('max-buffer.js', ['stdout', '10'], {maxB…
   109:   const {stdout, all} = await t.throwsAsync(execa('max-buffer.js', ['st…

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:108:25



  stream › maxBuffer affects stderr

  test/stream.js:115

   114: test('maxBuffer affects stderr', async t => {                           
   115:   await t.notThrowsAsync(execa('max-buffer.js', ['stderr', '10'], {maxB…
   116:   const {stderr, all} = await t.throwsAsync(execa('max-buffer.js', ['st…

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:115:25



  stream › do not buffer stdout when `buffer` set to `false`

  test/stream.js:122

   121: test('do not buffer stdout when `buffer` set to `false`', async t => {  
   122:   const promise = execa('max-buffer.js', ['stdout', '10'], {buffer: fal…
   123:   const [result, stdout] = await Promise.all([                          

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:122:18



  stream › do not buffer stderr when `buffer` set to `false`

  test/stream.js:133

   132: test('do not buffer stderr when `buffer` set to `false`', async t => {  
   133:   const promise = execa('max-buffer.js', ['stderr', '10'], {buffer: fal…
   134:   const [result, stderr] = await Promise.all([                          

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:133:18



  stream › do not buffer when streaming

  test/stream.js:144

   143: test('do not buffer when streaming', async t => {                       
   144:   const {stdout} = execa('max-buffer.js', ['stdout', '21'], {maxBuffer:…
   145:   const result = await getStream(stdout);                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:144:19



  stream › buffer: false > promise resolves

  test/stream.js:150

   149: test('buffer: false > promise resolves', async t => {       
   150:   await t.notThrowsAsync(execa('noop.js', {buffer: false}));
   151: });                                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:150:25



  stream › buffer: false > promise resolves when output is big but is not pipable

  test/stream.js:154

   153: test('buffer: false > promise resolves when output is big but is not pi…
   154:   await t.notThrowsAsync(execa('max-buffer.js', {buffer: false, stdout:…
   155: });                                                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:154:25



  stream › buffer: false > promise resolves when output is big and is read

  test/stream.js:158

   157: test('buffer: false > promise resolves when output is big and is read',…
   158:   const subprocess = execa('max-buffer.js', {buffer: false});           
   159:   subprocess.stdout.resume();                                           

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:158:21



  stream › buffer: false > promise resolves when output is big and "all" is used and is read

  test/stream.js:165

   164: test('buffer: false > promise resolves when output is big and "all" is …
   165:   const subprocess = execa('max-buffer.js', {buffer: false, all: true});
   166:   subprocess.all.resume();                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:165:21



  stream › buffer: false > promise rejects when process returns non-zero

  test/stream.js:171

   170: test('buffer: false > promise rejects when process returns non-zero', a…
   171:   const subprocess = execa('fail.js', {buffer: false});                 
   172:   const {exitCode} = await t.throwsAsync(subprocess);                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:171:21



  stream › can use all: true with stdout: ignore

  test/stream.js:177

   176: test('can use all: true with stdout: ignore', async t => {              
   177:   await t.notThrowsAsync(execa('max-buffer.js', {buffer: false, stdout:…
   178: });                                                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:177:25



  stream › can use all: true with stderr: ignore

  test/stream.js:181

   180: test('can use all: true with stderr: ignore', async t => {              
   181:   await t.notThrowsAsync(execa('max-buffer.js', ['stderr'], {buffer: fa…
   182: });                                                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/stream.js:181:25



  test › execa() returns a promise with pid

  test/test.js:131

   130: test('execa() returns a promise with pid', t => {
   131:   const {pid} = execa('noop.js', ['foo']);       
   132:   t.is(typeof pid, 'number');                    

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:131:16



  test › execa()

  test/test.js:16

   15: test('execa()', async t => {                       
   16:   const {stdout} = await execa('noop.js', ['foo']);
   17:   t.is(stdout, 'foo');                             

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:16:25



  test › skip throwing when using reject option

  test/test.js:44

   43: test('skip throwing when using reject option', async t => {  
   44:   const {exitCode} = await execa('fail.js', {reject: false});
   45:   t.is(exitCode, 2);                                         

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:44:27



  test › stripFinalNewline: true

  test/test.js:54

   53: test('stripFinalNewline: true', async t => {       
   54:   const {stdout} = await execa('noop.js', ['foo']);
   55:   t.is(stdout, 'foo');                             

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:54:25



  test › stripFinalNewline: false

  test/test.js:59

   58: test('stripFinalNewline: false', async t => {                            
   59:   const {stdout} = await execa('noop.js', ['foo'], {stripFinalNewline: f…
   60:   t.is(stdout, 'foo\n');                                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:59:25



  test › stripFinalNewline on failure

  test/test.js:64

   63: test('stripFinalNewline on failure', async t => {                        
   64:   const {stderr} = await t.throwsAsync(execa('noop-throw.js', ['foo'], {…
   65:   t.is(stderr, 'foo');                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:64:39



  test › preferLocal: true

  test/test.js:88

   87: test('preferLocal: true', async t => {                                   
   88:   await t.notThrowsAsync(execa('ava', ['--version'], {preferLocal: true,…
   89: });                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:88:25



  test › preferLocal: false

  test/test.js:92

   91: test('preferLocal: false', async t => {                                  
   92:   await t.throwsAsync(execa('ava', ['--version'], {preferLocal: false, e…
   93: });                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:92:22



  test › preferLocal: undefined

  test/test.js:96

   95: test('preferLocal: undefined', async t => {                              
   96:   await t.throwsAsync(execa('ava', ['--version'], {env: getPathWithoutLo…
   97: });                                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:96:22



  test › localDir option

  test/test.js:101

   100:   const command = process.platform === 'win32' ? 'echo %PATH%' : 'echo …
   101:   const {stdout} = await execa(command, {shell: true, preferLocal: true…
   102:   const envPaths = stdout.split(path.delimiter);                        

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:101:25



  test › stdin errors are handled

  test/test.js:113

   112: test('stdin errors are handled', async t => {       
   113:   const subprocess = execa('noop.js');              
   114:   subprocess.stdin.emit('error', new Error('test'));

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:113:21



  test › child process errors are handled

  test/test.js:119

   118: test('child process errors are handled', async t => {
   119:   const subprocess = execa('noop.js');               
   120:   subprocess.emit('error', new Error('test'));       

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:119:21



  test › child process errors rejects promise right away

  test/test.js:125

   124: test('child process errors rejects promise right away', async t => {
   125:   const subprocess = execa('noop.js');                              
   126:   subprocess.emit('error', new Error('test'));                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:125:21



  test › do not try to consume streams twice

  test/test.js:157

   156: test('do not try to consume streams twice', async t => {
   157:   const subprocess = execa('noop.js', ['foo']);         
   158:   const {stdout} = await subprocess;                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:157:21



  test › use relative path with '..' chars

  test/test.js:166

   165:   const pathViaParentDir = path.join('..', path.basename(fileURLToPath(…
   166:   const {stdout} = await execa(pathViaParentDir, ['foo']);              
   167:   t.is(stdout, 'foo');                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:166:25



  test › execa() rejects if running non-executable

  test/test.js:172

   171:   test('execa() rejects if running non-executable', async t => {
   172:     const subprocess = execa('non-executable.js');              
   173:     await t.throwsAsync(subprocess);                            

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:172:22



  test › execa() rejects with correct error and doesn't throw if running non-executable with input

  test/test.js:177

   176:   test('execa() rejects with correct error and doesn\'t throw if runnin…
   177:     await t.throwsAsync(execa('non-executable.js', {input: 'Hey!'}), {m…
   178:   });                                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:177:23



  test › write to fast-exit process

  test/test.js:189

   188:     } catch (error) {           
   189:       t.is(error.code, 'EPIPE');
   190:     }                           

  Difference:

  - undefined
  + 'EPIPE'

  › file://test/test.js:189:6



  test › use environment variables by default

  test/test.js:195

   194: test('use environment variables by default', async t => {
   195:   const {stdout} = await execa('environment.js');        
   196:   t.deepEqual(stdout.split('\n'), ['foo', 'undefined']); 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:195:25



  test › extend environment variables by default

  test/test.js:200

   199: test('extend environment variables by default', async t => {            
   200:   const {stdout} = await execa('environment.js', [], {env: {BAR: 'bar',…
   201:   t.deepEqual(stdout.split('\n'), ['foo', 'bar']);                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:200:25



  test › do not extend environment with `extendEnv: false`

  test/test.js:205

   204: test('do not extend environment with `extendEnv: false`', async t => {  
   205:   const {stdout} = await execa('environment.js', [], {env: {BAR: 'bar',…
   206:   t.deepEqual(stdout.split('\n'), ['undefined', 'bar']);                

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:205:25



  test › can use `options.cwd` as a string

  test/test.js:211

   210:   const cwd = '/';                                                     
   211:   const {stdout} = await execa('node', ['-p', 'process.cwd()'], {cwd});
   212:   t.is(path.toNamespacedPath(stdout), path.toNamespacedPath(cwd));     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:211:25



  test › localDir option can be a URL

  test/test.js:217

   216:   const command = process.platform === 'win32' ? 'echo %PATH%' : 'echo …
   217:   const {stdout} = await execa(command, {shell: true, preferLocal: true…
   218:   const envPaths = stdout.split(path.delimiter);                        

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:217:25



  test › can use `options.cwd` as a URL

  test/test.js:225

   224:   const cwdUrl = pathToFileURL(cwd);                                    
   225:   const {stdout} = await execa('node', ['-p', 'process.cwd()'], {cwd: c…
   226:   t.is(path.toNamespacedPath(stdout), path.toNamespacedPath(cwd));      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:225:25



  test › can use `options.shell: true`

  test/test.js:230

   229: test('can use `options.shell: true`', async t => {                      
   230:   const {stdout} = await execa('node test/fixtures/noop.js foo', {shell…
   231:   t.is(stdout, 'foo');                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:230:25



  test › can use `options.shell: string`

  test/test.js:236

   235:   const shell = process.platform === 'win32' ? 'cmd.exe' : '/bin/bash'; 
   236:   const {stdout} = await execa('node test/fixtures/noop.js foo', {shell…
   237:   t.is(stdout, 'foo');                                                  

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:236:25



  test › use extend environment with `extendEnv: true` and `shell: true`

  test/test.js:243

   242:   const command = process.platform === 'win32' ? 'echo %TEST%' : 'echo …
   243:   const {stdout} = await execa(command, {shell: true, env: {}, extendEn…
   244:   t.is(stdout, 'test');                                                 

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:243:25



  test › detach child process

  test/test.js:249

   248: test('detach child process', async t => {   
   249:   const {stdout} = await execa('detach.js');
   250:   const pid = Number(stdout);               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:249:25



  test › execPath option

  test/test.js:108

   107:   const {path: execPath} = await getNode('6.0.0');                      
   108:   const {stdout} = await execa('node', ['-p', 'process.env.Path || proc…
   109:   t.true(stdout.includes('6.0.0'));                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › onetime (file://node_modules/onetime/index.js:6:5)
  › execa (file://index.js:155:28)
  › file://test/test.js:108:25

  ─

  149 tests failed
  6 unhandled rejections
-------------|---------|----------|---------|---------|------------------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s            
-------------|---------|----------|---------|---------|------------------------------
All files    |   81.53 |    93.67 |   81.08 |   81.53 |                              
 execa       |   83.14 |     92.5 |   88.88 |   83.14 |                              
  index.js   |   83.14 |     92.5 |   88.88 |   83.14 | 55-57,71-72,113-152          
 execa/lib   |   80.45 |    94.06 |   78.57 |   80.45 |                              
  command.js |     100 |      100 |     100 |     100 |                              
  error.js   |   90.58 |    85.18 |     100 |   90.58 | 9-10,17-18,23-24,76-77       
  kill.js    |   89.21 |    93.54 |      90 |   89.21 | 20,41,43-46,51-55            
  promise.js |   97.22 |     90.9 |     100 |   97.22 | 33                           
  stdio.js   |     100 |      100 |     100 |     100 |                              
  stream.js  |   32.55 |      100 |   16.66 |   32.55 | 7-15,20-34,39-49,53-61,66-79 
-------------|---------|----------|---------|---------|------------------------------
./VariantsFile/execa/variant14/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (841ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.9s)
  ✔ error › result.killed is false if not killed, in sync mode (1.1s)
  ✔ error › result.killed is false on process error, in sync mode (253ms)
  ✔ error › Original error.message is kept (1.5s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (331ms)
  ✔ error › stdout/stderr/all on process errors (2.1s)
  ✔ error › stdout/stderr/all available on errors (2.2s)
  ✔ error › exitCode is 0 on success (2.1s)
  ✔ error › exitCode is 2 (2s)
  ✔ error › exitCode is 3 (2s)
  ✔ error › exitCode is 4 (2s)
  ✔ error › error.message contains the command (1.9s)
  ✔ error › error.message contains stdout/stderr if available (1.8s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.8s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.7s)
  ✔ error › failed is false on success (1.6s)
  ✔ error › failed is true on failure (1.5s)
  ✔ error › error.killed is true if process was killed directly (1.5s)
  ✔ error › error.killed is false if process was killed indirectly (1.4s)
  ✔ error › result.killed is false if not killed (1.3s)
  ✔ error › error.signal is SIGINT (418ms)
  ✔ error › error.signalDescription is defined (402ms)
  ✔ error › error.signal is SIGTERM (394ms)
  ✔ error › exitCode is undefined on signal termination (382ms)
  ✔ error › custom error.signal (418ms)
  ✔ error › result.signalDescription is undefined for successful execution (381ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (496ms)
  ✔ error › result.signal is undefined for successful execution (591ms)
  ✔ error › error.code is undefined on success (604ms)
  ✔ command › allow commands with spaces and no array arguments (3s)
  ✔ command › allow commands with spaces and array arguments (2.9s)
  ✔ command › execaCommand() (2.9s)
  ✔ command › execaCommand() ignores consecutive spaces (2.7s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.7s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.6s)
  ✔ command › execaCommand() escapes other whitespaces (2.5s)
  ✔ command › execaCommand() trims (2.4s)
  ✔ command › command is: " foo bar" (3.3s)
  ✔ command › command is: " baz quz" (3.2s)
  ✔ command › command is: "" (3.2s)
  ✔ command › escapedCommand is: "foo bar" (3.4s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.5s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3.7s)
  ✔ command › escapedCommand is: "\"*\"" (4.2s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.6s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.6s)
  ✔ kill › execa() returns a promise with kill() (3.5s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3.3s)
  ✔ kill › cancel method kills the subprocess (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (1s)
  ✔ kill › timeout kills the process if it times out, in sync mode (3.5s)
  ✔ kill › timeout must not be negative (3.4s)
  ✔ kill › timeout must be an integer (3.4s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel (101ms)
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (136ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (206ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (228ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.9s)
  ✔ kill › timeout does not kill the process if it does not time out (3.6s)
  ✔ kill › timedOut is false if timeout is undefined (3.5s)
  ✔ kill › timedOut is false if timeout is 0 (3.5s)
  ✔ kill › spawnAndExit (3.1s)
  ✔ kill › spawnAndExit cleanup (3s)
  ✔ kill › spawnAndExit detached (3s)
  ✔ kill › spawnAndExit cleanup detached (2.9s)
  ✔ kill › spawnAndKill SIGTERM (2.9s)
  ✔ kill › spawnAndKill SIGKILL (2.9s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.8s)
  ✔ kill › spawnAndKill detached SIGTERM (2.8s)
  ✔ kill › spawnAndKill detached SIGKILL (2.7s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.7s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.6s)
  ✔ kill › removes exit handler on exit (2.6s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.5s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.4s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (502ms)
  ✔ kill › error.isCanceled is true when cancel method is used (457ms)
  ✔ kill › error.isCanceled is false when kill method is used (438ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (420ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (390ms)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.9s)
  ✔ kill › timeout kills the process if it times out (3.7s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (4s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (438ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (4s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (425ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (113ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions (104ms)
  ✔ node › node correctly use nodePath
  ✔ node › node pass on nodeOptions (174ms)
  ✔ node › node's forked script has a communication channel (243ms)
  ✔ node › node() (362ms)
  ✔ node › node pipe stdout (365ms)
  ✔ override-promise › should work with third-party Promise (135ms)
  ✔ promise › promise methods are not enumerable (155ms)
  ✔ promise › finally function is executed on success (335ms)
  ✔ promise › finally function is executed on failure (350ms)
  ✔ promise › throw in finally function bubbles up on success (317ms)
  ✔ promise › throw in finally bubbles up on error (318ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.8s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.8s)
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ test › execaSync() (2.4s)
  ✔ test › execaSync() throws error if written to stderr (2.3s)
  ✔ test › skip throwing when using reject option in sync mode (2.2s)
  ✔ test › stripFinalNewline in sync mode (2s)
  ✔ test › stripFinalNewline in sync mode on failure (1.5s)
  ✔ test › execa() returns a promise with pid (976ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (922ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (862ms)
  ✔ test › child_process.spawn() errors are propagated (933ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (806ms)
  ✔ test › execa() rejects if running non-executable (879ms)
  ✔ test › preferLocal: undefined (1.3s)
  ✔ test › preferLocal: false (1.4s)
  ✔ test › child process errors rejects promise right away (1.1s)
  ✔ test › child process errors are handled (1.2s)
  ✔ test › stdin errors are handled (1.2s)
  ✔ test › execa() (2.8s)
  ✔ test › skip throwing when using reject option (2.6s)
  ✔ test › stripFinalNewline: true (2.4s)
  ✔ test › stripFinalNewline: false (2.4s)
  ✔ test › stripFinalNewline on failure (2.4s)
  ✔ test › localDir option (1.5s)
  ✔ test › do not try to consume streams twice (1.2s)
  ✔ test › use relative path with '..' chars (1.1s)
  ✔ test › write to fast-exit process (1s)
  ✔ test › can use `options.cwd` as a string (741ms)
  ✔ test › localDir option can be a URL (716ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (477ms)
  ✔ test › use environment variables by default (947ms)
  ✔ test › extend environment variables by default (948ms)
  ✔ test › do not extend environment with `extendEnv: false` (877ms)
  ✔ test › can use `options.cwd` as a URL (727ms)
  ✔ test › can use `options.shell: true` (951ms)
  ✔ test › can use `options.shell: string` (884ms)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (2.8s)
  ✔ stream › input option can be a String - sync (2.1s)
  ✔ stream › input option can be a Buffer - sync (1.4s)
  ✔ stream › helpful error trying to provide an input stream in sync mode (735ms)
  ✔ stream › buffer (3s)
  ✔ stream › pass `stdout` to a file descriptor (3s)
  ✔ stream › pass `stderr` to a file descriptor (3s)
  ✔ stream › result.all is undefined unless opts.all is true (3s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.9s)
  ✔ stream › input option can be a String (2.4s)
  ✔ stream › input can be a Stream (2.4s)
  ✔ stream › input option can be a Buffer (2.4s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (984ms)
  ✔ stream › you can write to child.stdin (2.4s)
  ✔ test › detach child process (1.3s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (1s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (996ms)
  ✔ stream › do not buffer when streaming (984ms)
  ✔ stream › buffer: false > promise resolves (949ms)
  ✔ test › execPath option (2.6s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (837ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.1s)
  ✔ stream › maxBuffer affects stdout (1.5s)
  ✔ stream › maxBuffer affects stderr (1.5s)
  ✔ stream › can use all: true with stdout: ignore (1s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.1s)
  ✔ stream › can use all: true with stderr: ignore (979ms)
  ✔ test › preferLocal: true (3.6s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsFile/execa/variant13/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✖ command › execaCommandSync() Error thrown in test
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.7s)
  ✖ error › result.killed is false if not killed, in sync mode Error thrown in test
  ✔ error › result.killed is false on process error, in sync mode (451ms)
  ✔ error › Original error.message is kept (1.3s)
  ✔ error › error.code is defined on failure if applicable
  ✖ error › result.killed is false on process error 
  ✖ error › stdout/stderr/all on process errors 
  ✖ error › stdout/stderr/all available on errors 
  ✖ error › exitCode is 0 on success Rejected promise returned by test
  ✖ error › exitCode is 2 
  ✖ error › exitCode is 3 
  ✖ error › exitCode is 4 
  ✖ error › error.message contains the command 
  ✖ error › error.message contains stdout/stderr if available 
  ✔ error › error.message does not contain stdout/stderr if not available (1.7s)
  ✖ error › error.shortMessage does not contain stdout/stderr Rejected promise returned by test
  ✖ error › failed is false on success Rejected promise returned by test
  ✖ error › failed is true on failure 
  ✖ error › error.killed is true if process was killed directly 
  ✖ error › error.killed is false if process was killed indirectly 
  ✖ error › result.killed is false if not killed Rejected promise returned by test
  ✖ error › error.signal is SIGINT 
  ✖ error › error.signalDescription is defined 
  ✖ error › error.signal is SIGTERM 
  ✔ error › exitCode is undefined on signal termination (587ms)
  ✖ error › result.signalDescription is undefined for successful execution Rejected promise returned by test
  ✖ error › custom error.signal 
  ✖ error › result.signal is undefined for successful execution Rejected promise returned by test
  ✖ error › error.code is undefined on success Rejected promise returned by test
  ✖ error › result.signal is undefined if process failed, but was not killed 
  ✖ command › allow commands with spaces and no array arguments Rejected promise returned by test
  ✖ command › allow commands with spaces and array arguments Rejected promise returned by test
  ✖ command › execaCommand() Rejected promise returned by test
  ✖ command › execaCommand() ignores consecutive spaces Rejected promise returned by test
  ✖ command › execaCommand() allows escaping spaces in commands Rejected promise returned by test
  ✖ command › execaCommand() allows escaping spaces in arguments Rejected promise returned by test
  ✖ command › execaCommand() escapes other whitespaces Rejected promise returned by test
  ✖ command › execaCommand() trims Rejected promise returned by test
  ✖ command › command is: " foo bar" 
  ✖ command › command is: " baz quz" 
  ✖ command › command is: "" 
  ✖ command › escapedCommand is: "foo bar" 
  ✖ command › escapedCommand is: "\"foo bar\"" 
  ✖ command › escapedCommand is: "\"\\\"foo\\\"\"" 
  ✖ command › escapedCommand is: "\"*\"" 
  ✖ node › node removes --inspect from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect=9222 from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect-brk from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process Rejected promise returned by test
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.8s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.7s)
  ✔ kill › execa() returns a promise with kill() (3.7s)
  ✖ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode Error thrown in test
  ✔ kill › cancel method kills the subprocess (2.4s)
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) Error thrown in test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) 
  ✖ kill › timeout kills the process if it times out, in sync mode 
  ✔ kill › timeout must not be negative (3.6s)
  ✔ kill › timeout must be an integer (3.6s)
  ✖ kill › calling abort after cancel should show the same behaviour as only calling cancel 
  ✖ kill › calling cancel after abort should show the same behaviour as only calling cancel 
  ✖ kill › calling abort twice should show the same behaviour as calling it once 
  ✖ kill › calling abort throws an error with message "Command was canceled" 
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (4s)
  ✖ kill › timeout does not kill the process if it does not time out Rejected promise returned by test
  ✖ kill › timedOut is false if timeout is undefined Rejected promise returned by test
  ✖ kill › timedOut is false if timeout is 0 Rejected promise returned by test
  ✖ kill › spawnAndExit 
  ✖ kill › spawnAndExit cleanup 
  ✖ kill › spawnAndExit detached 
  ✖ kill › spawnAndExit cleanup detached 
  ✔ kill › spawnAndKill SIGTERM (3.2s)
  ✔ kill › spawnAndKill SIGKILL (3.1s)
  ✔ kill › spawnAndKill cleanup SIGKILL (3.1s)
  ✔ kill › spawnAndKill detached SIGTERM (3s)
  ✔ kill › spawnAndKill detached SIGKILL (3s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.9s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.8s)
  ✔ kill › removes exit handler on exit (2.8s)
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called (success) Rejected promise returned by test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) 
  ✖ kill › calling cancel method throws an error with message "Command was canceled" 
  ✖ kill › error.isCanceled is true when cancel method is used 
  ✖ kill › error.isCanceled is false when kill method is used 
  ✖ kill › calling cancel method twice should show the same behaviour as calling it once 
  ✖ kill › calling cancel method on a successfully completed process does not make result.isCanceled true Rejected promise returned by test
  ✖ kill › calling cancel method on a process which has been killed does not make error.isCanceled true 
  ✔ kill › spawnAndKill cleanup SIGTERM (3.1s)
  ✖ kill › timeout kills the process if it times out 
  ✖ kill › kill("SIGKILL") should terminate cleanly 
  ✖ kill › `forceKillAfterTimeout: number` should kill after a timeout 
  ✖ node › node should not remove --inspect when passed through nodeOptions Rejected promise returned by test
  ✖ kill › calling abort on a successfully completed process does not make result.isCanceled true Rejected promise returned by test
  ✖ node › node correctly use nodePath Rejected promise returned by test
  ✖ node › node() Rejected promise returned by test
  ✖ node › node pass on nodeOptions Rejected promise returned by test
  ✔ node › node's forked script has a communication channel (228ms)
  ✖ node › node pipe stdout Rejected promise returned by test
  ✖ override-promise › should work with third-party Promise Rejected promise returned by test
  ✔ promise › promise methods are not enumerable (112ms)
  ✔ promise › throw in finally function bubbles up on success (166ms)
  ✖ promise › finally function is executed on failure 
  ✖ promise › finally function is executed on success Rejected promise returned by test
  ✔ promise › throw in finally bubbles up on error (332ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✖ kill › `forceKillAfterTimeout: true` should kill after a timeout 
  ✖ kill › kill() with no arguments should kill after a timeout 
  ✖ stream › result.all shows both `stdout` and `stderr` intermixed Rejected promise returned by test
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.8s)
  ✖ stream › input option can be a String - sync Error thrown in test
  ✖ stream › input option can be a Buffer - sync Error thrown in test
  ✔ stream › helpful error trying to provide an input stream in sync mode (800ms)
  ✖ stream › buffer Rejected promise returned by test
  ✖ stream › pass `stdout` to a file descriptor Rejected promise returned by test
  ✖ stream › pass `stderr` to a file descriptor Rejected promise returned by test
  ✖ stream › result.all is undefined unless opts.all is true Rejected promise returned by test
  ✔ stream › stdout/stderr/all are undefined if ignored (2.2s)
  ✔ stream › buffer: false > promise resolves (1s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (1.2s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (1.2s)
  ✔ stream › do not buffer when streaming (1.1s)
  ✖ stream › input option can be a String Rejected promise returned by test
  ✖ stream › input option can be a Buffer Rejected promise returned by test
  ✖ stream › you can write to child.stdin Rejected promise returned by test
  ✖ stream › opts.stdout:ignore - stdout will not collect data Rejected promise returned by test
  ✖ stream › input can be a Stream Rejected promise returned by test
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1.3s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (1.1s)
  ✖ test › execaSync() Error thrown in test
  ✔ test › execaSync() throws error if written to stderr (2.9s)
  ✖ test › skip throwing when using reject option in sync mode Error thrown in test
  ✖ test › stripFinalNewline in sync mode Error thrown in test
  ✖ test › stripFinalNewline in sync mode on failure 
  ✔ test › execa() returns a promise with pid (1.5s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1.4s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (1.3s)
  ✔ test › child_process.spawn() errors are propagated (1.5s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.5s)
  ✔ stream › can use all: true with stderr: ignore (1.2s)
  ✔ stream › can use all: true with stdout: ignore (1.3s)
  ✖ test › execa() rejects with correct error and doesn't throw if running non-executable with input 
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.5s)
  ✔ test › execa() rejects if running non-executable (1.4s)
  ✖ test › preferLocal: undefined 
  ✖ test › preferLocal: false 
  ✖ stream › maxBuffer affects stdout 
  ✖ test › child process errors rejects promise right away 
  ✖ test › child process errors are handled 
  ✖ stream › maxBuffer affects stderr 
  ✖ test › stdin errors are handled 
  ✖ test › execa() Rejected promise returned by test
  ✖ test › skip throwing when using reject option Rejected promise returned by test
  ✖ test › stripFinalNewline: true Rejected promise returned by test
  ✔ test › stripFinalNewline: false (2.9s)
  ✖ test › stripFinalNewline on failure 
  ✖ test › localDir option Rejected promise returned by test
  ✖ test › do not try to consume streams twice Rejected promise returned by test
  ✖ test › use relative path with '..' chars Rejected promise returned by test
  ✖ test › write to fast-exit process 
  ✖ test › use environment variables by default Rejected promise returned by test
  ✖ test › extend environment variables by default Rejected promise returned by test
  ✖ test › do not extend environment with `extendEnv: false` Rejected promise returned by test
  ✖ test › can use `options.cwd` as a string Rejected promise returned by test
  ✖ test › localDir option can be a URL Rejected promise returned by test
  ✖ test › can use `options.cwd` as a URL Rejected promise returned by test
  ✖ test › use extend environment with `extendEnv: true` and `shell: true` Rejected promise returned by test
  ✖ test › can use `options.shell: string` Rejected promise returned by test
  ✖ test › can use `options.shell: true` Rejected promise returned by test
  ✖ test › detach child process Rejected promise returned by test
  ✖ test › execPath option Rejected promise returned by test
  ✖ test › preferLocal: true 
  ─

  command › execaCommandSync()

  test/command.js:85

   84: test('execaCommandSync()', t => {                                        
   85:   const {stdout} = execaCommandSync('node test/fixtures/echo.js foo bar'…
   86:   t.is(stdout, 'foo\nbar');                                              

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › execaCommandSync (file://index.js:234:9)
  › file://test/command.js:85:19



  error › result.killed is false if not killed, in sync mode

  test/error.js:120

   119: test('result.killed is false if not killed, in sync mode', t => {
   120:   const {killed} = execaSync('noop.js');                         
   121:   t.false(killed);                                               

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/error.js:120:19



  error › result.killed is false on process error

  test/error.js:126

   125:   const {killed} = await t.throwsAsync(execa('wrong command'));
   126:   t.false(killed);                                             
   127: });                                                            

  Value is not `false`:

  undefined

  › file://test/error.js:126:9



  error › stdout/stderr/all on process errors

  test/error.js:29

   28:   const {stdout, stderr, all} = await t.throwsAsync(execa('wrong command…
   29:   t.is(stdout, '');                                                      
   30:   t.is(stderr, WRONG_COMMAND);                                           

  Difference:

  - undefined
  + ''

  › file://test/error.js:29:4



  error › stdout/stderr/all available on errors

  test/error.js:17

   16: test('stdout/stderr/all available on errors', async t => {               
   17:   const {stdout, stderr, all} = await t.throwsAsync(execa('exit.js', ['2…
   18:   t.is(typeof stdout, 'string');                                         

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 2/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › exitCode is 0 on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:44:21



  error › exitCode is 2

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 2/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › exitCode is 3

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 3/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › exitCode is 4

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 4/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.message contains the command

  test/error.js:58

   57: test('error.message contains the command', async t => {                  
   58:   await t.throwsAsync(execa('exit.js', ['2', 'foo', 'bar']), {message: /…
   59: });                                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /exit.js 2 foo bar/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.message contains stdout/stderr if available

  test/error.js:63

   62:   const {message} = await t.throwsAsync(execa('echo-fail.js'));
   63:   t.true(message.includes('stderr'));                          
   64:   t.true(message.includes('stdout'));                          

  Value is not `true`:

  false

  › file://test/error.js:63:8



  error › error.shortMessage does not contain stdout/stderr

  test/error.js:75

   74:   const {shortMessage} = await t.throwsAsync(execa('echo-fail.js'));
   75:   t.false(shortMessage.includes('stderr'));                         
   76:   t.false(shortMessage.includes('stdout'));                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'Cannot read properties of undefined (reading \'includes\')',
  }

  › file://test/error.js:75:23



  error › failed is false on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:85:19



  error › failed is true on failure

  test/error.js:91

   90:   const {failed} = await t.throwsAsync(execa('exit.js', ['2']));
   91:   t.true(failed);                                               
   92: });                                                             

  Value is not `true`:

  undefined

  › file://test/error.js:91:8



  error › error.killed is true if process was killed directly

  test/error.js:99

   98:                                                                          
   99:   const {killed} = await t.throwsAsync(subprocess, {message: /was killed…
   100:   t.true(killed);                                                        

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGTERM/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.killed is false if process was killed indirectly

  test/error.js:110

   109:   const message = process.platform === 'win32' ? /failed with exit code…
   110:   const {killed} = await t.throwsAsync(subprocess, {message});          
   111:   t.false(killed);                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGINT/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › result.killed is false if not killed

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:115:19



  error › error.signal is SIGINT

  test/error.js:154

   153:                                                                         
   154:     const {signal} = await t.throwsAsync(subprocess, {message: /was kil…
   155:     t.is(signal, 'SIGINT');                                             

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGINT/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.signalDescription is defined

  test/error.js:163

   162:                                                                         
   163:     const {signalDescription} = await t.throwsAsync(subprocess, {messag…
   164:     t.is(signalDescription, 'User interruption with CTRL-C');           

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /User interruption with CTRL-C/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.signal is SIGTERM

  test/error.js:172

   171:                                                                         
   172:     const {signal} = await t.throwsAsync(subprocess, {message: /was kil…
   173:     t.is(signal, 'SIGTERM');                                            

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGTERM/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › result.signalDescription is undefined for successful execution

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:202:30



  error › custom error.signal

  test/error.js:178

   177:     const {signal} = await t.throwsAsync(execa('noop.js', {killSignal: …
   178:     t.is(signal, 'SIGHUP');                                             
   179:   });                                                                   

  Difference:

  - undefined
  + 'SIGHUP'

  › file://test/error.js:178:5



  error › result.signal is undefined for successful execution

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:192:19



  error › error.code is undefined on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:207:17



  error › result.signal is undefined if process failed, but was not killed

  test/error.js:197

   196: test('result.signal is undefined if process failed, but was not killed'…
   197:   const {signal} = await t.throwsAsync(execa('exit.js', [2]), {message:…
   198:   t.is(signal, undefined);                                              

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 2/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  command › allow commands with spaces and no array arguments

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:45:19



  command › allow commands with spaces and array arguments

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:50:19



  command › execaCommand()

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:55:19



  command › execaCommand() ignores consecutive spaces

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:60:19



  command › execaCommand() allows escaping spaces in commands

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:65:19



  command › execaCommand() allows escaping spaces in arguments

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:70:19



  command › execaCommand() escapes other whitespaces

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:75:19



  command › execaCommand() trims

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:80:19



  command › command is: " foo bar"

  test/command.js:9

   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                
   10:                                                                           

  Difference:

  - undefined
  + 'fail.js foo bar'

  › command (file://test/command.js:9:4)



  command › command is: " baz quz"

  test/command.js:9

   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                
   10:                                                                           

  Difference:

  - undefined
  + 'fail.js baz quz'

  › command (file://test/command.js:9:4)



  command › command is: ""

  test/command.js:9

   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                
   10:                                                                           

  Difference:

  - undefined
  + 'fail.js'

  › command (file://test/command.js:9:4)



  command › escapedCommand is: "foo bar"

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js foo bar'

  › testEscapedCommand (file://test/command.js:23:4)



  command › escapedCommand is: "\"foo bar\""

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js "foo bar"'

  › testEscapedCommand (file://test/command.js:23:4)



  command › escapedCommand is: "\"\\\"foo\\\"\""

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js "\\"foo\\""'

  › testEscapedCommand (file://test/command.js:23:4)



  command › escapedCommand is: "\"*\""

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js "*"'

  › testEscapedCommand (file://test/command.js:23:4)



  node › node removes --inspect from nodeOptions when defined by parent process

  test/node.js:17

   16:                                               
   17:     const {stdout, stderr} = await subprocess;
   18:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async inspectMacro (file://test/node.js:17:28)



  node › node removes --inspect=9222 from nodeOptions when defined by parent process

  test/node.js:17

   16:                                               
   17:     const {stdout, stderr} = await subprocess;
   18:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async inspectMacro (file://test/node.js:17:28)



  node › node removes --inspect-brk from nodeOptions when defined by parent process

  test/node.js:17

   16:                                               
   17:     const {stdout, stderr} = await subprocess;
   18:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async inspectMacro (file://test/node.js:17:28)



  node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process

  test/node.js:17

   16:                                               
   17:     const {stdout, stderr} = await subprocess;
   18:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async inspectMacro (file://test/node.js:17:28)



  kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode

  test/kill.js:127

   126: test('timedOut is false if timeout is undefined and exit code is 0 in s…
   127:   const {timedOut} = execaSync('noop.js');                              
   128:   t.false(timedOut);                                                    

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/kill.js:127:21



  kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success)

  test/kill.js:211

   210: test('result.isCanceled is false when spawned.cancel() isn\'t called in…
   211:   const {isCanceled} = execaSync('noop.js');                            
   212:   t.false(isCanceled);                                                  

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/kill.js:211:23



  kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure)

  test/kill.js:219

   218:   });                 
   219:   t.false(isCanceled);
   220: });                   

  Value is not `false`:

  undefined

  › file://test/kill.js:219:9



  kill › timeout kills the process if it times out, in sync mode

  test/kill.js:93

   92:   });              
   93:   t.false(killed); 
   94:   t.true(timedOut);

  Value is not `false`:

  undefined

  › file://test/kill.js:93:9



  kill › calling abort after cancel should show the same behaviour as only calling cancel

  test/kill.js:307

   306:     const {isCanceled} = await t.throwsAsync(subprocess);
   307:     t.true(isCanceled);                                  
   308:     t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:307:9



  kill › calling cancel after abort should show the same behaviour as only calling cancel

  test/kill.js:297

   296:     const {isCanceled} = await t.throwsAsync(subprocess);
   297:     t.true(isCanceled);                                  
   298:     t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:297:9



  kill › calling abort twice should show the same behaviour as calling it once

  test/kill.js:279

   278:     const {isCanceled} = await t.throwsAsync(subprocess);
   279:     t.true(isCanceled);                                  
   280:     t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:279:9



  kill › calling abort throws an error with message "Command was canceled"

  test/kill.js:270

   269:     abortController.abort();                                           
   270:     await t.throwsAsync(subprocess, {message: /Command was canceled/});
   271:   });                                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /Command was canceled/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  kill › timeout does not kill the process if it does not time out

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:98:21



  kill › timedOut is false if timeout is undefined

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:117:21



  kill › timedOut is false if timeout is 0

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:122:21



  kill › spawnAndExit

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › spawnAndExit cleanup

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › spawnAndExit detached

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › spawnAndExit cleanup detached

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › result.isCanceled is false when spawned.cancel() isn't called (success)

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:201:23



  kill › result.isCanceled is false when spawned.cancel() isn't called (failure)

  test/kill.js:207

   206:   const {isCanceled} = await t.throwsAsync(execa('fail.js'));
   207:   t.false(isCanceled);                                       
   208: });                                                          

  Value is not `false`:

  undefined

  › file://test/kill.js:207:9



  kill › calling cancel method throws an error with message "Command was canceled"

  test/kill.js:225

   224:   subprocess.cancel();                                               
   225:   await t.throwsAsync(subprocess, {message: /Command was canceled/});
   226: });                                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /Command was canceled/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  kill › error.isCanceled is true when cancel method is used

  test/kill.js:232

   231:   const {isCanceled} = await t.throwsAsync(subprocess);
   232:   t.true(isCanceled);                                  
   233: });                                                    

  Value is not `true`:

  undefined

  › file://test/kill.js:232:8



  kill › error.isCanceled is false when kill method is used

  test/kill.js:239

   238:   const {isCanceled} = await t.throwsAsync(subprocess);
   239:   t.false(isCanceled);                                 
   240: });                                                    

  Value is not `false`:

  undefined

  › file://test/kill.js:239:9



  kill › calling cancel method twice should show the same behaviour as calling it once

  test/kill.js:247

   246:   const {isCanceled} = await t.throwsAsync(subprocess);
   247:   t.true(isCanceled);                                  
   248:   t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:247:8



  kill › calling cancel method on a successfully completed process does not make result.isCanceled true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:253:23



  kill › calling cancel method on a process which has been killed does not make error.isCanceled true

  test/kill.js:262

   261:   const {isCanceled} = await t.throwsAsync(subprocess);
   262:   t.false(isCanceled);                                 
   263: });                                                    

  Value is not `false`:

  undefined

  › file://test/kill.js:262:9



  kill › timeout kills the process if it times out

  test/kill.js:84

   83: test('timeout kills the process if it times out', async t => {           
   84:   const {killed, timedOut} = await t.throwsAsync(execa('noop.js', {timeo…
   85:   t.false(killed);                                                       

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /timed out after/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  kill › kill("SIGKILL") should terminate cleanly

  test/kill.js:19

   18:   const {signal} = await t.throwsAsync(subprocess);
   19:   t.is(signal, 'SIGKILL');                         
   20: });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:19:4



  kill › `forceKillAfterTimeout: number` should kill after a timeout

  test/kill.js:42

   41:     const {signal} = await t.throwsAsync(subprocess);
   42:     t.is(signal, 'SIGKILL');                         
   43:   });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:42:5



  node › node should not remove --inspect when passed through nodeOptions

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:85:28



  kill › calling abort on a successfully completed process does not make result.isCanceled true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:286:24



  node › node correctly use nodePath

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:40:19



  node › node()

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:27:21



  node › node pass on nodeOptions

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:50:19



  node › node pipe stdout

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:32:19



  override-promise › should work with third-party Promise

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/override-promise.js:12:19



  promise › finally function is executed on failure

  test/promise.js:29

   28:   t.is(isError, true);          
   29:   t.is(typeof stdout, 'string');
   30:   t.is(typeof stderr, 'string');

  Difference:

  - 'undefined'
  + 'string'

  › file://test/promise.js:29:4



  promise › finally function is executed on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/promise.js:16:19



  kill › `forceKillAfterTimeout: true` should kill after a timeout

  test/kill.js:52

   51:     const {signal} = await t.throwsAsync(subprocess);
   52:     t.is(signal, 'SIGKILL');                         
   53:   });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:52:5



  kill › kill() with no arguments should kill after a timeout

  test/kill.js:62

   61:     const {signal} = await t.throwsAsync(subprocess);
   62:     t.is(signal, 'SIGKILL');                         
   63:   });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:62:5



  stream › result.all shows both `stdout` and `stderr` intermixed

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:32:16



  stream › input option can be a String - sync

  test/stream.js:81

   80: test('input option can be a String - sync', t => {          
   81:   const {stdout} = execaSync('stdin.js', {input: 'foobar'});
   82:   t.is(stdout, 'foobar');                                   

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/stream.js:81:19



  stream › input option can be a Buffer - sync

  test/stream.js:86

   85: test('input option can be a Buffer - sync', t => {                       
   86:   const {stdout} = execaSync('stdin.js', {input: Buffer.from('testing12'…
   87:   t.is(stdout, 'testing12');                                             

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/stream.js:86:19



  stream › buffer

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:14:19



  stream › pass `stdout` to a file descriptor

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:115:18)
  › async file://test/stream.js:21:2



  stream › pass `stderr` to a file descriptor

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:27:2



  stream › result.all is undefined unless opts.all is true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:37:16



  stream › input option can be a String

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:56:19



  stream › input option can be a Buffer

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:61:19



  stream › you can write to child.stdin

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:76:19



  stream › opts.stdout:ignore - stdout will not collect data

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:115:18)
  › async file://test/stream.js:91:19



  stream › input can be a Stream

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:69:19



  test › execaSync()

  test/test.js:33

   32: test('execaSync()', t => {                       
   33:   const {stdout} = execaSync('noop.js', ['foo']);
   34:   t.is(stdout, 'foo');                           

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/test.js:33:19



  test › skip throwing when using reject option in sync mode

  test/test.js:49

   48: test('skip throwing when using reject option in sync mode', t => {
   49:   const {exitCode} = execaSync('fail.js', {reject: false});       
   50:   t.is(exitCode, 2);                                              

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/test.js:49:21



  test › stripFinalNewline in sync mode

  test/test.js:69

   68: test('stripFinalNewline in sync mode', t => {                            
   69:   const {stdout} = execaSync('noop.js', ['foo'], {stripFinalNewline: tru…
   70:   t.is(stdout, 'foo');                                                   

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/test.js:69:19



  test › stripFinalNewline in sync mode on failure

  test/test.js:77

   76:   });                 
   77:   t.is(stderr, 'foo');
   78: });                   

  Difference:

  - undefined
  + 'foo'

  › file://test/test.js:77:4



  test › execa() rejects with correct error and doesn't throw if running non-executable with input

  test/test.js:177

   176:   test('execa() rejects with correct error and doesn\'t throw if runnin…
   177:     await t.throwsAsync(execa('non-executable.js', {input: 'Hey!'}), {m…
   178:   });                                                                   

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /EACCES/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › preferLocal: undefined

  test/test.js:96

   95: test('preferLocal: undefined', async t => {                              
   96:   await t.throwsAsync(execa('ava', ['--version'], {env: getPathWithoutLo…
   97: });                                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /spawn.* ENOENT/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › preferLocal: false

  test/test.js:92

   91: test('preferLocal: false', async t => {                                  
   92:   await t.throwsAsync(execa('ava', ['--version'], {preferLocal: false, e…
   93: });                                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /spawn.* ENOENT/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  stream › maxBuffer affects stdout

  test/stream.js:108

   107: test('maxBuffer affects stdout', async t => {                           
   108:   await t.notThrowsAsync(execa('max-buffer.js', ['stdout', '10'], {maxB…
   109:   const {stdout, all} = await t.throwsAsync(execa('max-buffer.js', ['st…

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/stream.js:108:10



  test › child process errors rejects promise right away

  test/test.js:127

   126:   subprocess.emit('error', new Error('test'));       
   127:   await t.throwsAsync(subprocess, {message: /test/});
   128: });                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /test/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › child process errors are handled

  test/test.js:121

   120:   subprocess.emit('error', new Error('test'));       
   121:   await t.throwsAsync(subprocess, {message: /test/});
   122: });                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /test/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  stream › maxBuffer affects stderr

  test/stream.js:115

   114: test('maxBuffer affects stderr', async t => {                           
   115:   await t.notThrowsAsync(execa('max-buffer.js', ['stderr', '10'], {maxB…
   116:   const {stderr, all} = await t.throwsAsync(execa('max-buffer.js', ['st…

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/stream.js:115:10



  test › stdin errors are handled

  test/test.js:115

   114:   subprocess.stdin.emit('error', new Error('test')); 
   115:   await t.throwsAsync(subprocess, {message: /test/});
   116: });                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /test/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › execa()

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:16:19



  test › skip throwing when using reject option

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:44:21



  test › stripFinalNewline: true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:54:19



  test › stripFinalNewline on failure

  test/test.js:65

   64:   const {stderr} = await t.throwsAsync(execa('noop-throw.js', ['foo'], {…
   65:   t.is(stderr, 'foo');                                                   
   66: });                                                                      

  Difference:

  - undefined
  + 'foo'

  › file://test/test.js:65:4



  test › localDir option

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:101:19



  test › do not try to consume streams twice

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:158:19



  test › use relative path with '..' chars

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:166:19



  test › write to fast-exit process

  test/test.js:189

   188:     } catch (error) {           
   189:       t.is(error.code, 'EPIPE');
   190:     }                           

  Difference:

  - undefined
  + 'EPIPE'

  › file://test/test.js:189:6



  test › use environment variables by default

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:195:19



  test › extend environment variables by default

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:200:19



  test › do not extend environment with `extendEnv: false`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:205:19



  test › can use `options.cwd` as a string

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:211:19



  test › localDir option can be a URL

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:217:19



  test › can use `options.cwd` as a URL

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:225:19



  test › use extend environment with `extendEnv: true` and `shell: true`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:243:19



  test › can use `options.shell: string`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:236:19



  test › can use `options.shell: true`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:230:19



  test › detach child process

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:249:19



  test › execPath option

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:108:19



  test › preferLocal: true

  test/test.js:88

   87: test('preferLocal: true', async t => {                                   
   88:   await t.notThrowsAsync(execa('ava', ['--version'], {preferLocal: true,…
   89: });                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/test.js:88:10

  ─

  125 tests failed
-------------|---------|----------|---------|---------|-----------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s     
-------------|---------|----------|---------|---------|-----------------------
All files    |   98.04 |    96.13 |     100 |   98.04 |                       
 execa       |   97.37 |    89.58 |     100 |   97.37 |                       
  index.js   |   97.37 |    89.58 |     100 |   97.37 | 55-57,135-136,208-209 
 execa/lib   |   98.49 |    98.11 |     100 |   98.49 |                       
  command.js |     100 |      100 |     100 |     100 |                       
  error.js   |   92.94 |    88.46 |     100 |   92.94 | 9-10,23-24,76-77      
  kill.js    |     100 |      100 |     100 |     100 |                       
  promise.js |     100 |      100 |     100 |     100 |                       
  stdio.js   |     100 |      100 |     100 |     100 |                       
  stream.js  |     100 |      100 |     100 |     100 |                       
-------------|---------|----------|---------|---------|-----------------------
./VariantsFile/execa/variant12/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (1s)
  ✔ error › stdout/stderr/all on process errors, in sync mode (2s)
  ✔ error › result.killed is false if not killed, in sync mode (1s)
  ✔ error › result.killed is false on process error, in sync mode (350ms)
  ✔ error › Original error.message is kept (1.4s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (442ms)
  ✔ error › stdout/stderr/all on process errors (2.1s)
  ✔ error › stdout/stderr/all available on errors (2.3s)
  ✔ error › exitCode is 0 on success (2.2s)
  ✔ error › exitCode is 2 (2.1s)
  ✔ error › exitCode is 3 (2.1s)
  ✔ error › exitCode is 4 (2s)
  ✔ error › error.message contains the command (1.9s)
  ✔ error › error.message contains stdout/stderr if available (1.8s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.7s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.7s)
  ✔ error › failed is false on success (1.5s)
  ✔ error › failed is true on failure (1.4s)
  ✔ error › error.killed is true if process was killed directly (1.4s)
  ✔ error › error.killed is false if process was killed indirectly (1.3s)
  ✔ error › result.killed is false if not killed (1.3s)
  ✔ error › error.signal is SIGINT (519ms)
  ✔ error › error.signalDescription is defined (496ms)
  ✔ error › error.signal is SIGTERM (472ms)
  ✔ error › exitCode is undefined on signal termination (423ms)
  ✔ error › custom error.signal (457ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (466ms)
  ✔ error › error.code is undefined on success (498ms)
  ✔ error › result.signalDescription is undefined for successful execution (573ms)
  ✔ error › result.signal is undefined for successful execution (713ms)
  ✔ command › allow commands with spaces and no array arguments (3.1s)
  ✔ command › allow commands with spaces and array arguments (3.1s)
  ✔ command › execaCommand() (3s)
  ✔ command › execaCommand() ignores consecutive spaces (2.9s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.9s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.8s)
  ✔ command › execaCommand() escapes other whitespaces (2.7s)
  ✔ command › execaCommand() trims (2.6s)
  ✔ command › command is: " foo bar" (3.4s)
  ✔ command › command is: " baz quz" (3.3s)
  ✔ command › command is: "" (3.3s)
  ✔ command › escapedCommand is: "foo bar" (3.6s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.8s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (4s)
  ✔ command › escapedCommand is: "\"*\"" (4.5s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.5s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.5s)
  ✔ kill › execa() returns a promise with kill() (3.5s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3.2s)
  ✔ kill › cancel method kills the subprocess (2.4s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (997ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (3.5s)
  ✔ kill › timeout must not be negative (3.3s)
  ✔ kill › timeout must be an integer (3.3s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel (126ms)
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (154ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (214ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (237ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.8s)
  ✔ kill › timeout does not kill the process if it does not time out (3.5s)
  ✔ kill › timedOut is false if timeout is undefined (3.5s)
  ✔ kill › timedOut is false if timeout is 0 (3.4s)
  ✔ kill › spawnAndExit (3s)
  ✔ kill › spawnAndExit cleanup (3s)
  ✔ kill › spawnAndExit detached (2.9s)
  ✔ kill › spawnAndExit cleanup detached (2.9s)
  ✔ kill › spawnAndKill SIGTERM (2.9s)
  ✔ kill › spawnAndKill SIGKILL (2.9s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.9s)
  ✔ kill › spawnAndKill detached SIGTERM (2.9s)
  ✔ kill › spawnAndKill detached SIGKILL (2.8s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.7s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.7s)
  ✔ kill › removes exit handler on exit (2.7s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.5s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.5s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (461ms)
  ✔ kill › error.isCanceled is true when cancel method is used (442ms)
  ✔ kill › error.isCanceled is false when kill method is used (412ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (394ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (379ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (364ms)
  ✔ kill › timeout kills the process if it times out (3.6s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.9s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.9s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (336ms)
  ✔ kill › spawnAndKill cleanup SIGTERM (3s)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (103ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process (107ms)
  ✔ node › node should not remove --inspect when passed through nodeOptions (105ms)
  ✔ node › node correctly use nodePath
  ✔ node › node() (300ms)
  ✔ node › node's forked script has a communication channel (250ms)
  ✔ node › node pipe stdout (319ms)
  ✔ node › node pass on nodeOptions (297ms)
  ✔ override-promise › should work with third-party Promise (129ms)
  ✔ promise › promise methods are not enumerable (101ms)
  ✔ promise › finally function is executed on success (324ms)
  ✔ promise › finally function is executed on failure (319ms)
  ✔ promise › throw in finally bubbles up on error (342ms)
  ✔ promise › throw in finally function bubbles up on success (371ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ kill › kill() with no arguments should kill after a timeout (8.7s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.7s)
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ test › execaSync() (2.2s)
  ✔ test › execaSync() throws error if written to stderr (1.8s)
  ✔ test › skip throwing when using reject option in sync mode (1.8s)
  ✔ test › stripFinalNewline in sync mode (1.6s)
  ✔ test › stripFinalNewline in sync mode on failure (1.3s)
  ✔ test › execa() returns a promise with pid (1s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (937ms)
  ✔ test › child_process.spawn() errors are propagated (1s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (874ms)
  ✔ test › execa() rejects if running non-executable (942ms)
  ✔ test › preferLocal: undefined (1.4s)
  ✔ test › preferLocal: false (1.5s)
  ✔ test › child process errors rejects promise right away (1.3s)
  ✔ test › child process errors are handled (1.4s)
  ✔ test › stdin errors are handled (1.4s)
  ✔ test › execa() (2.7s)
  ✔ test › skip throwing when using reject option (2.2s)
  ✔ test › stripFinalNewline: true (2.1s)
  ✔ test › stripFinalNewline: false (2s)
  ✔ test › stripFinalNewline on failure (2s)
  ✔ test › localDir option (1.6s)
  ✔ test › do not try to consume streams twice (1.3s)
  ✔ test › use relative path with '..' chars (1.2s)
  ✔ test › write to fast-exit process (1s)
  ✔ test › use environment variables by default (1s)
  ✔ test › extend environment variables by default (1s)
  ✔ test › localDir option can be a URL (875ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (610ms)
  ✔ test › can use `options.cwd` as a string (916ms)
  ✔ test › do not extend environment with `extendEnv: false` (986ms)
  ✔ test › can use `options.cwd` as a URL (809ms)
  ✔ test › can use `options.shell: true` (748ms)
  ✔ test › can use `options.shell: string` (787ms)
  ✔ test › detach child process (822ms)
  ✔ test › execPath option (2s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (2.6s)
  ✔ stream › input option can be a String - sync (1.6s)
  ✔ stream › input option can be a Buffer - sync (819ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (532ms)
  ✔ stream › buffer (2.8s)
  ✔ stream › pass `stdout` to a file descriptor (2.8s)
  ✔ stream › pass `stderr` to a file descriptor (2.8s)
  ✔ stream › result.all is undefined unless opts.all is true (2.8s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.7s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (670ms)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (789ms)
  ✔ stream › you can write to child.stdin (1.9s)
  ✔ stream › input option can be a Buffer (2s)
  ✔ stream › input option can be a String (2.1s)
  ✔ stream › input can be a Stream (2s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (794ms)
  ✔ stream › do not buffer when streaming (843ms)
  ✔ stream › buffer: false > promise resolves (847ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (784ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1s)
  ✔ stream › can use all: true with stdout: ignore (910ms)
  ✔ stream › can use all: true with stderr: ignore (846ms)
  ✔ stream › maxBuffer affects stdout (1.3s)
  ✔ stream › maxBuffer affects stderr (1.3s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.1s)
  ✔ test › preferLocal: true (3.7s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsFile/execa/variant11/execa

> execa@6.1.0 test
> xo && c8 ava && tsd

./VariantsFile/execa/variant10/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (708ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.9s)
  ✔ error › result.killed is false if not killed, in sync mode (1.4s)
  ✔ error › result.killed is false on process error, in sync mode (416ms)
  ✔ error › Original error.message is kept (1.6s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (540ms)
  ✔ error › stdout/stderr/all on process errors (2s)
  ✔ error › stdout/stderr/all available on errors (2.1s)
  ✔ error › exitCode is 0 on success (2s)
  ✔ error › exitCode is 2 (2s)
  ✔ error › exitCode is 3 (2s)
  ✔ error › exitCode is 4 (2s)
  ✔ error › error.message contains the command (1.9s)
  ✔ error › error.message contains stdout/stderr if available (1.9s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.9s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.8s)
  ✔ error › failed is false on success (1.8s)
  ✔ error › failed is true on failure (1.8s)
  ✔ error › error.killed is true if process was killed directly (1.7s)
  ✔ error › error.killed is false if process was killed indirectly (1.7s)
  ✔ error › result.killed is false if not killed (1.6s)
  ✔ error › error.signal is SIGINT (590ms)
  ✔ error › error.signalDescription is defined (531ms)
  ✔ error › error.signal is SIGTERM (455ms)
  ✔ error › exitCode is undefined on signal termination (408ms)
  ✔ error › custom error.signal (441ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (548ms)
  ✔ error › result.signalDescription is undefined for successful execution (507ms)
  ✔ error › result.signal is undefined for successful execution (624ms)
  ✔ error › error.code is undefined on success (579ms)
  ✔ command › allow commands with spaces and no array arguments (2.7s)
  ✔ command › allow commands with spaces and array arguments (2.6s)
  ✔ command › execaCommand() (2.6s)
  ✔ command › execaCommand() ignores consecutive spaces (2.5s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.4s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.4s)
  ✔ command › execaCommand() escapes other whitespaces (2.3s)
  ✔ command › execaCommand() trims (2.3s)
  ✔ command › command is: " foo bar" (3.2s)
  ✔ command › command is: " baz quz" (3s)
  ✔ command › command is: "" (3s)
  ✔ command › escapedCommand is: "foo bar" (3.2s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.3s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3.4s)
  ✔ command › escapedCommand is: "\"*\"" (3.5s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.4s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.3s)
  ✔ kill › execa() returns a promise with kill() (3.3s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3s)
  ✔ kill › cancel method kills the subprocess (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (868ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (3.3s)
  ✔ kill › timeout must not be negative (3.1s)
  ✔ kill › timeout must be an integer (3.1s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (131ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (178ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (235ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.6s)
  ✔ kill › timeout does not kill the process if it does not time out (3.3s)
  ✔ kill › timedOut is false if timeout is undefined (3.3s)
  ✔ kill › timedOut is false if timeout is 0 (3.2s)
  ✔ kill › spawnAndExit (2.9s)
  ✔ kill › spawnAndExit cleanup (2.9s)
  ✔ kill › spawnAndExit detached (2.8s)
  ✔ kill › spawnAndExit cleanup detached (2.8s)
  ✔ kill › spawnAndKill SIGTERM (2.8s)
  ✔ kill › spawnAndKill SIGKILL (2.8s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.8s)
  ✔ kill › spawnAndKill detached SIGTERM (2.7s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.7s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.6s)
  ✔ kill › removes exit handler on exit (2.6s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.4s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.3s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (455ms)
  ✔ kill › error.isCanceled is true when cancel method is used (438ms)
  ✔ kill › error.isCanceled is false when kill method is used (425ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (412ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (397ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (390ms)
  ✔ kill › spawnAndKill detached SIGKILL (2.7s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.8s)
  ✔ kill › timeout kills the process if it times out (3.5s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.7s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.7s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (362ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (121ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process (111ms)
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process (104ms)
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions (120ms)
  ✔ node › node correctly use nodePath
  ✔ node › node() (322ms)
  ✔ node › node's forked script has a communication channel (261ms)
  ✔ node › node pipe stdout (320ms)
  ✔ node › node pass on nodeOptions (293ms)
  ✔ override-promise › should work with third-party Promise (125ms)
  ✔ promise › promise methods are not enumerable (122ms)
  ✔ promise › finally function is executed on success (337ms)
  ✔ promise › finally function is executed on failure (331ms)
  ✔ promise › throw in finally function bubbles up on success (343ms)
  ✔ promise › throw in finally bubbles up on error (329ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.6s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.5s)
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ test › execaSync() (2.3s)
  ✔ test › execaSync() throws error if written to stderr (2.1s)
  ✔ test › skip throwing when using reject option in sync mode (2.1s)
  ✔ test › stripFinalNewline in sync mode (1.9s)
  ✔ test › stripFinalNewline in sync mode on failure (1.5s)
  ✔ test › execa() returns a promise with pid (1.1s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1.1s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (1s)
  ✔ test › child_process.spawn() errors are propagated (1.1s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (891ms)
  ✔ test › execa() rejects if running non-executable (1s)
  ✔ test › preferLocal: undefined (1.6s)
  ✔ test › preferLocal: false (1.6s)
  ✔ test › child process errors rejects promise right away (1.4s)
  ✔ test › child process errors are handled (1.5s)
  ✔ test › stdin errors are handled (1.5s)
  ✔ test › execa() (2.7s)
  ✔ test › skip throwing when using reject option (2.5s)
  ✔ test › stripFinalNewline: true (2.3s)
  ✔ test › stripFinalNewline: false (2.3s)
  ✔ test › stripFinalNewline on failure (2.3s)
  ✔ test › localDir option (1.7s)
  ✔ test › do not try to consume streams twice (1.4s)
  ✔ test › use relative path with '..' chars (1.3s)
  ✔ test › write to fast-exit process (1.1s)
  ✔ test › can use `options.cwd` as a string (906ms)
  ✔ test › localDir option can be a URL (838ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (544ms)
  ✔ test › extend environment variables by default (1s)
  ✔ test › use environment variables by default (1s)
  ✔ test › do not extend environment with `extendEnv: false` (976ms)
  ✔ test › can use `options.cwd` as a URL (796ms)
  ✔ test › can use `options.shell: string` (812ms)
  ✔ test › can use `options.shell: true` (872ms)
  ✔ test › execPath option (2.2s)
  ✔ test › detach child process (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (2.7s)
  ✔ stream › input option can be a String - sync (1.6s)
  ✔ stream › input option can be a Buffer - sync (875ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (434ms)
  ✔ stream › buffer (2.9s)
  ✔ stream › pass `stdout` to a file descriptor (2.9s)
  ✔ stream › pass `stderr` to a file descriptor (2.9s)
  ✔ stream › result.all is undefined unless opts.all is true (2.9s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.8s)
  ✔ stream › you can write to child.stdin (1.9s)
  ✔ stream › input option can be a String (2.1s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (680ms)
  ✔ stream › input can be a Stream (2s)
  ✔ stream › input option can be a Buffer (2.1s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (855ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (831ms)
  ✔ stream › do not buffer when streaming (816ms)
  ✔ stream › buffer: false > promise resolves (899ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (757ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (977ms)
  ✔ stream › can use all: true with stdout: ignore (900ms)
  ✔ stream › can use all: true with stderr: ignore (875ms)
  ✔ stream › maxBuffer affects stderr (1.2s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1s)
  ✔ stream › maxBuffer affects stdout (1.3s)
  ✔ test › preferLocal: true (3.7s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsFile/execa/variant9/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (883ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.9s)
  ✔ error › result.killed is false if not killed, in sync mode (998ms)
  ✔ error › result.killed is false on process error, in sync mode (234ms)
  ✔ error › Original error.message is kept (1.5s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (357ms)
  ✔ error › stdout/stderr/all on process errors (2.1s)
  ✔ error › stdout/stderr/all available on errors (2.2s)
  ✔ error › exitCode is 0 on success (2.1s)
  ✔ error › exitCode is 2 (2.1s)
  ✔ error › exitCode is 3 (2s)
  ✔ error › exitCode is 4 (2s)
  ✔ error › error.message contains the command (2s)
  ✔ error › error.message contains stdout/stderr if available (1.9s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.8s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.7s)
  ✔ error › failed is false on success (1.7s)
  ✔ error › failed is true on failure (1.6s)
  ✔ error › error.killed is true if process was killed directly (1.5s)
  ✔ error › error.killed is false if process was killed indirectly (1.4s)
  ✔ error › result.killed is false if not killed (1.3s)
  ✔ error › error.signal is SIGINT (476ms)
  ✔ error › error.signalDescription is defined (464ms)
  ✔ error › error.signal is SIGTERM (447ms)
  ✔ error › exitCode is undefined on signal termination (411ms)
  ✔ error › custom error.signal (445ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (492ms)
  ✔ error › result.signal is undefined for successful execution (514ms)
  ✔ error › error.code is undefined on success (533ms)
  ✔ error › result.signalDescription is undefined for successful execution (563ms)
  ✔ command › allow commands with spaces and no array arguments (3.1s)
  ✔ command › allow commands with spaces and array arguments (3s)
  ✔ command › execaCommand() (2.9s)
  ✔ command › execaCommand() ignores consecutive spaces (2.8s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.7s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.6s)
  ✔ command › execaCommand() escapes other whitespaces (2.6s)
  ✔ command › execaCommand() trims (2.5s)
  ✔ command › command is: " foo bar" (3.4s)
  ✔ command › command is: " baz quz" (3.3s)
  ✔ command › command is: "" (3.3s)
  ✔ command › escapedCommand is: "foo bar" (3.5s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.6s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3.9s)
  ✔ command › escapedCommand is: "\"*\"" (4.4s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.4s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.3s)
  ✔ kill › execa() returns a promise with kill() (3.3s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3.1s)
  ✔ kill › cancel method kills the subprocess (2.4s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (1s)
  ✔ kill › timeout kills the process if it times out, in sync mode (3.3s)
  ✔ kill › timeout must not be negative (3.2s)
  ✔ kill › timeout must be an integer (3.2s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (104ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (176ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (214ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.6s)
  ✔ kill › timeout does not kill the process if it does not time out (3.4s)
  ✔ kill › timedOut is false if timeout is undefined (3.4s)
  ✔ kill › timedOut is false if timeout is 0 (3.4s)
  ✔ kill › spawnAndExit (2.9s)
  ✔ kill › spawnAndExit cleanup (2.9s)
  ✔ kill › spawnAndExit detached (2.9s)
  ✔ kill › spawnAndExit cleanup detached (2.8s)
  ✔ kill › spawnAndKill SIGTERM (2.8s)
  ✔ kill › spawnAndKill SIGKILL (2.8s)
  ✔ kill › spawnAndKill detached SIGTERM (2.7s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.6s)
  ✔ kill › removes exit handler on exit (2.6s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.5s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.5s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (524ms)
  ✔ kill › error.isCanceled is true when cancel method is used (500ms)
  ✔ kill › error.isCanceled is false when kill method is used (484ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (465ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (433ms)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.8s)
  ✔ kill › spawnAndKill detached SIGKILL (2.7s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.7s)
  ✔ kill › timeout kills the process if it times out (3.6s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.8s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (503ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.8s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.8s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (385ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (122ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process (103ms)
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process (105ms)
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process (102ms)
  ✔ node › node should not remove --inspect when passed through nodeOptions (111ms)
  ✔ node › node correctly use nodePath
  ✔ node › node() (266ms)
  ✔ node › node's forked script has a communication channel (224ms)
  ✔ node › node pipe stdout (330ms)
  ✔ node › node pass on nodeOptions (308ms)
  ✔ override-promise › should work with third-party Promise (175ms)
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on success (272ms)
  ✔ promise › finally function is executed on failure (318ms)
  ✔ promise › throw in finally function bubbles up on success (339ms)
  ✔ promise › throw in finally bubbles up on error (321ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.5s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.5s)
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.2s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ test › execaSync() (2.1s)
  ✔ test › execaSync() throws error if written to stderr (1.8s)
  ✔ test › skip throwing when using reject option in sync mode (1.8s)
  ✔ test › stripFinalNewline in sync mode (1.6s)
  ✔ test › stripFinalNewline in sync mode on failure (1.3s)
  ✔ test › execa() returns a promise with pid (1.1s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (993ms)
  ✔ test › child_process.spawn() errors are propagated (1.1s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (934ms)
  ✔ test › execa() rejects if running non-executable (992ms)
  ✔ test › preferLocal: undefined (1.3s)
  ✔ test › preferLocal: false (1.4s)
  ✔ test › child process errors rejects promise right away (1.3s)
  ✔ test › child process errors are handled (1.3s)
  ✔ test › stdin errors are handled (1.3s)
  ✔ test › execa() (2.5s)
  ✔ test › skip throwing when using reject option (2.2s)
  ✔ test › stripFinalNewline: true (2s)
  ✔ test › stripFinalNewline: false (2s)
  ✔ test › stripFinalNewline on failure (2s)
  ✔ test › localDir option (1.6s)
  ✔ test › do not try to consume streams twice (1.3s)
  ✔ test › use relative path with '..' chars (1.3s)
  ✔ test › write to fast-exit process (1.1s)
  ✔ test › use environment variables by default (1s)
  ✔ test › localDir option can be a URL (790ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (566ms)
  ✔ test › extend environment variables by default (1s)
  ✔ test › can use `options.cwd` as a string (891ms)
  ✔ test › do not extend environment with `extendEnv: false` (983ms)
  ✔ test › can use `options.cwd` as a URL (778ms)
  ✔ test › can use `options.shell: true` (746ms)
  ✔ test › can use `options.shell: string` (676ms)
  ✔ test › detach child process (1s)
  ✔ test › execPath option (2.1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (2.6s)
  ✔ stream › input option can be a String - sync (1.4s)
  ✔ stream › input option can be a Buffer - sync (870ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (475ms)
  ✔ stream › buffer (2.9s)
  ✔ stream › pass `stdout` to a file descriptor (2.9s)
  ✔ stream › pass `stderr` to a file descriptor (2.9s)
  ✔ stream › result.all is undefined unless opts.all is true (2.7s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.7s)
  ✔ stream › input option can be a String (1.8s)
  ✔ stream › input option can be a Buffer (1.8s)
  ✔ stream › input can be a Stream (1.7s)
  ✔ stream › you can write to child.stdin (1.7s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (714ms)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (714ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (685ms)
  ✔ stream › do not buffer when streaming (712ms)
  ✔ stream › buffer: false > promise resolves (743ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (656ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (871ms)
  ✔ stream › maxBuffer affects stdout (1.1s)
  ✔ test › preferLocal: true (3.7s)
  ✔ stream › maxBuffer affects stderr (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (890ms)
  ✔ stream › can use all: true with stdout: ignore (802ms)
  ✔ stream › can use all: true with stderr: ignore (794ms)
  ✔ stream › buffer: false > promise resolves when output is big and is read (981ms)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsFile/execa/variant8/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (921ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.9s)
  ✔ error › result.killed is false if not killed, in sync mode (1s)
  ✔ error › result.killed is false on process error, in sync mode (338ms)
  ✔ error › Original error.message is kept (1.5s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (458ms)
  ✔ error › stdout/stderr/all on process errors (2s)
  ✔ error › stdout/stderr/all available on errors (2.2s)
  ✔ error › exitCode is 0 on success (2s)
  ✔ error › exitCode is 2 (2s)
  ✔ error › exitCode is 3 (1.9s)
  ✔ error › exitCode is 4 (1.9s)
  ✔ error › error.message contains the command (1.9s)
  ✔ error › error.message contains stdout/stderr if available (1.8s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.8s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.7s)
  ✔ error › failed is false on success (1.6s)
  ✔ error › failed is true on failure (1.5s)
  ✔ error › error.killed is true if process was killed directly (1.4s)
  ✔ error › error.killed is false if process was killed indirectly (1.3s)
  ✔ error › result.killed is false if not killed (1.3s)
  ✔ error › error.signal is SIGINT (548ms)
  ✔ error › error.signalDescription is defined (509ms)
  ✔ error › error.signal is SIGTERM (496ms)
  ✔ error › exitCode is undefined on signal termination (450ms)
  ✔ error › custom error.signal (498ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (494ms)
  ✔ error › result.signalDescription is undefined for successful execution (477ms)
  ✔ error › result.signal is undefined for successful execution (575ms)
  ✔ error › error.code is undefined on success (470ms)
  ✔ command › allow commands with spaces and no array arguments (2.7s)
  ✔ command › allow commands with spaces and array arguments (2.7s)
  ✔ command › execaCommand() (2.6s)
  ✔ command › execaCommand() ignores consecutive spaces (2.6s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.5s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.5s)
  ✔ command › execaCommand() escapes other whitespaces (2.3s)
  ✔ command › execaCommand() trims (2.3s)
  ✔ command › command is: " foo bar" (3s)
  ✔ command › command is: " baz quz" (2.9s)
  ✔ command › command is: "" (2.9s)
  ✔ command › escapedCommand is: "foo bar" (3s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.2s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3.5s)
  ✔ command › escapedCommand is: "\"*\"" (3.6s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.6s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.6s)
  ✔ kill › execa() returns a promise with kill() (3.5s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3.4s)
  ✔ kill › cancel method kills the subprocess (2.5s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2.4s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (1.2s)
  ✔ kill › timeout kills the process if it times out, in sync mode (3.5s)
  ✔ kill › timeout must not be negative (3.5s)
  ✔ kill › timeout must be an integer (3.5s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel (105ms)
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (145ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (201ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (246ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.8s)
  ✔ kill › timeout does not kill the process if it does not time out (3.6s)
  ✔ kill › timedOut is false if timeout is undefined (3.6s)
  ✔ kill › timedOut is false if timeout is 0 (3.6s)
  ✔ kill › spawnAndExit (3.1s)
  ✔ kill › spawnAndExit cleanup (3.1s)
  ✔ kill › spawnAndExit detached (3.1s)
  ✔ kill › spawnAndExit cleanup detached (3s)
  ✔ kill › spawnAndKill SIGTERM (3s)
  ✔ kill › spawnAndKill SIGKILL (3s)
  ✔ kill › spawnAndKill cleanup SIGKILL (3s)
  ✔ kill › spawnAndKill detached SIGTERM (2.9s)
  ✔ kill › spawnAndKill detached SIGKILL (2.9s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.8s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.8s)
  ✔ kill › removes exit handler on exit (2.7s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.6s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.6s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (663ms)
  ✔ kill › error.isCanceled is true when cancel method is used (607ms)
  ✔ kill › error.isCanceled is false when kill method is used (533ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (438ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (406ms)
  ✔ kill › timeout kills the process if it times out (3.7s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (4s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (445ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.9s)
  ✔ kill › spawnAndKill cleanup SIGTERM (3s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (385ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (357ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process (101ms)
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process (103ms)
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process (103ms)
  ✔ node › node should not remove --inspect when passed through nodeOptions (109ms)
  ✔ node › node correctly use nodePath (119ms)
  ✔ node › node() (298ms)
  ✔ node › node pipe stdout (405ms)
  ✔ node › node pass on nodeOptions (375ms)
  ✔ node › node's forked script has a communication channel (366ms)
  ✔ override-promise › should work with third-party Promise (116ms)
  ✔ promise › promise methods are not enumerable (131ms)
  ✔ promise › finally function is executed on failure (268ms)
  ✔ promise › finally function is executed on success (344ms)
  ✔ promise › throw in finally function bubbles up on success (363ms)
  ✔ promise › throw in finally bubbles up on error (346ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.8s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.8s)
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ test › execaSync() (2.4s)
  ✔ test › execaSync() throws error if written to stderr (2.2s)
  ✔ test › skip throwing when using reject option in sync mode (2.2s)
  ✔ test › stripFinalNewline in sync mode (1.9s)
  ✔ test › stripFinalNewline in sync mode on failure (1.6s)
  ✔ test › execa() returns a promise with pid (959ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (907ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (797ms)
  ✔ test › child_process.spawn() errors are propagated (931ms)
  ✔ test › write to fast-exit process (689ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (758ms)
  ✔ test › execa() rejects if running non-executable (824ms)
  ✔ test › preferLocal: undefined (1.3s)
  ✔ test › preferLocal: false (1.3s)
  ✔ test › child process errors rejects promise right away (1.2s)
  ✔ test › child process errors are handled (1.2s)
  ✔ test › stdin errors are handled (1.2s)
  ✔ test › execa() (2.8s)
  ✔ test › skip throwing when using reject option (2.5s)
  ✔ test › stripFinalNewline: true (2.3s)
  ✔ test › stripFinalNewline: false (2.3s)
  ✔ test › stripFinalNewline on failure (2.3s)
  ✔ test › localDir option (1.4s)
  ✔ test › do not try to consume streams twice (1.1s)
  ✔ test › use relative path with '..' chars (1s)
  ✔ test › use environment variables by default (884ms)
  ✔ test › localDir option can be a URL (636ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (481ms)
  ✔ test › can use `options.cwd` as a string (698ms)
  ✔ test › extend environment variables by default (831ms)
  ✔ test › do not extend environment with `extendEnv: false` (744ms)
  ✔ test › can use `options.cwd` as a URL (650ms)
  ✔ test › can use `options.shell: true` (674ms)
  ✔ test › can use `options.shell: string` (654ms)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (2.5s)
  ✔ stream › input option can be a String - sync (1.9s)
  ✔ stream › input option can be a Buffer - sync (1.2s)
  ✔ stream › helpful error trying to provide an input stream in sync mode (557ms)
  ✔ stream › buffer (2.8s)
  ✔ stream › pass `stdout` to a file descriptor (2.8s)
  ✔ stream › pass `stderr` to a file descriptor (2.7s)
  ✔ stream › result.all is undefined unless opts.all is true (2.7s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.6s)
  ✔ test › detach child process (1.3s)
  ✔ stream › you can write to child.stdin (2.3s)
  ✔ stream › input can be a Stream (2.4s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (901ms)
  ✔ stream › input option can be a Buffer (2.4s)
  ✔ stream › input option can be a String (2.4s)
  ✔ test › execPath option (2.4s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (885ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (958ms)
  ✔ stream › do not buffer when streaming (920ms)
  ✔ stream › buffer: false > promise resolves (916ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (959ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (820ms)
  ✔ stream › buffer: false > promise resolves when output is big and is read (988ms)
  ✔ stream › maxBuffer affects stderr (1.2s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (977ms)
  ✔ stream › maxBuffer affects stdout (1.3s)
  ✔ stream › can use all: true with stderr: ignore (902ms)
  ✔ stream › can use all: true with stdout: ignore (954ms)
  ✔ test › preferLocal: true (3.5s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsFile/execa/variant7/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/command.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  Uncaught exception in test/error.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/command.js exited with a non-zero exit code: 1
  ✖ test/error.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/kill.js exited with a non-zero exit code: 1

  Uncaught exception in test/node.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  Uncaught exception in test/promise.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/promise.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }

  Uncaught exception in test/stream.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › <anonymous> (node_modules/get-node/src/archive/p7z.js:93:18)

  ✖ test/test.js exited with a non-zero exit code: 1

  ✖ Timed out while running tests

  ─

  36 tests passed
  8 uncaught exceptions
-------------|---------|----------|---------|---------|---------------------------------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                           
-------------|---------|----------|---------|---------|---------------------------------------------
All files    |   27.62 |      100 |    8.33 |   27.62 |                                             
 execa       |    13.1 |      100 |       0 |    13.1 |                                             
  index.js   |    13.1 |      100 |       0 |    13.1 | ...2,76-162,165-225,228-230,233-235,238-267 
 execa/lib   |   37.34 |      100 |   10.71 |   37.34 |                                             
  command.js |    43.9 |      100 |       0 |    43.9 | 2-6,13-17,28-40                             
  error.js   |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                  
  kill.js    |   36.27 |      100 |       0 |   36.27 | ...-29,38-46,51-55,59-60,65-80,84-86,91-101 
  promise.js |   36.11 |      100 |       0 |   36.11 | 9-18,23-35                                  
  stdio.js   |     100 |      100 |     100 |     100 |                                             
  stream.js  |   29.06 |      100 |       0 |   29.06 | 7-15,20-34,39-49,53-61,66-79,83-85          
-------------|---------|----------|---------|---------|---------------------------------------------
./VariantsFile/execa/variant6/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (929ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.8s)
  ✔ error › result.killed is false if not killed, in sync mode (918ms)
  ✔ error › result.killed is false on process error, in sync mode (254ms)
  ✔ error › Original error.message is kept (1.3s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (357ms)
  ✔ error › stdout/stderr/all on process errors (2s)
  ✔ error › stdout/stderr/all available on errors (2.2s)
  ✔ error › exitCode is 0 on success (1.9s)
  ✔ error › exitCode is 2 (1.9s)
  ✔ error › exitCode is 3 (1.8s)
  ✔ error › exitCode is 4 (1.8s)
  ✔ error › error.message contains the command (1.7s)
  ✔ error › error.message contains stdout/stderr if available (1.7s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.6s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.5s)
  ✔ error › failed is false on success (1.5s)
  ✔ error › failed is true on failure (1.4s)
  ✔ error › error.killed is true if process was killed directly (1.3s)
  ✔ error › error.killed is false if process was killed indirectly (1.3s)
  ✔ error › result.killed is false if not killed (1.2s)
  ✔ error › error.signal is SIGINT (487ms)
  ✔ error › error.signalDescription is defined (467ms)
  ✔ error › error.signal is SIGTERM (455ms)
  ✔ error › exitCode is undefined on signal termination (416ms)
  ✔ error › custom error.signal (437ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (453ms)
  ✔ error › result.signalDescription is undefined for successful execution (477ms)
  ✔ error › result.signal is undefined for successful execution (557ms)
  ✔ error › error.code is undefined on success (539ms)
  ✔ command › allow commands with spaces and no array arguments (3s)
  ✔ command › allow commands with spaces and array arguments (3s)
  ✔ command › execaCommand() (2.9s)
  ✔ command › execaCommand() ignores consecutive spaces (2.9s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.8s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.8s)
  ✔ command › execaCommand() escapes other whitespaces (2.7s)
  ✔ command › execaCommand() trims (2.6s)
  ✔ command › command is: " foo bar" (3.3s)
  ✔ command › command is: " baz quz" (3.2s)
  ✔ command › command is: "" (3.2s)
  ✔ command › escapedCommand is: "foo bar" (3.4s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.6s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3.9s)
  ✔ command › escapedCommand is: "\"*\"" (4.3s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.4s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.3s)
  ✔ kill › execa() returns a promise with kill() (3.3s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3s)
  ✔ kill › cancel method kills the subprocess (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (841ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (3.2s)
  ✔ kill › timeout must not be negative (3.1s)
  ✔ kill › timeout must be an integer (3.1s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (141ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (194ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (228ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.5s)
  ✔ kill › timeout does not kill the process if it does not time out (3.3s)
  ✔ kill › timedOut is false if timeout is undefined (3.3s)
  ✔ kill › timedOut is false if timeout is 0 (3.3s)
  ✔ kill › spawnAndExit (2.8s)
  ✔ kill › spawnAndExit cleanup (2.7s)
  ✔ kill › spawnAndExit detached (2.7s)
  ✔ kill › spawnAndExit cleanup detached (2.7s)
  ✔ kill › spawnAndKill SIGTERM (2.7s)
  ✔ kill › spawnAndKill SIGKILL (2.7s)
  ✔ kill › spawnAndKill detached SIGTERM (2.6s)
  ✔ kill › spawnAndKill detached SIGKILL (2.6s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.5s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.5s)
  ✔ kill › removes exit handler on exit (2.4s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.3s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (450ms)
  ✔ kill › error.isCanceled is true when cancel method is used (423ms)
  ✔ kill › error.isCanceled is false when kill method is used (414ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (395ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (368ms)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.7s)
  ✔ kill › timeout kills the process if it times out (3.4s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.7s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (412ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.7s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.7s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (389ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (121ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process (104ms)
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process (104ms)
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process (103ms)
  ✔ node › node should not remove --inspect when passed through nodeOptions (107ms)
  ✔ node › node correctly use nodePath
  ✔ node › node pipe stdout (271ms)
  ✔ node › node() (292ms)
  ✔ node › node's forked script has a communication channel (253ms)
  ✔ node › node pass on nodeOptions (272ms)
  ✔ override-promise › should work with third-party Promise (131ms)
  ✔ promise › promise methods are not enumerable (159ms)
  ✔ promise › finally function is executed on failure (264ms)
  ✔ promise › finally function is executed on success (383ms)
  ✔ promise › throw in finally function bubbles up on success (351ms)
  ✔ promise › throw in finally bubbles up on error (322ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.5s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.5s)
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ test › execaSync() (2.2s)
  ✔ test › execaSync() throws error if written to stderr (2s)
  ✔ test › skip throwing when using reject option in sync mode (2s)
  ✔ test › stripFinalNewline in sync mode (1.9s)
  ✔ test › stripFinalNewline in sync mode on failure (1.5s)
  ✔ test › execa() returns a promise with pid (931ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (895ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (784ms)
  ✔ test › child_process.spawn() errors are propagated (881ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (760ms)
  ✔ test › execa() rejects if running non-executable (819ms)
  ✔ test › preferLocal: undefined (1.2s)
  ✔ test › preferLocal: false (1.3s)
  ✔ test › child process errors rejects promise right away (1.1s)
  ✔ test › child process errors are handled (1.2s)
  ✔ test › stdin errors are handled (1.2s)
  ✔ test › execa() (2.6s)
  ✔ test › skip throwing when using reject option (2.4s)
  ✔ test › stripFinalNewline: true (2.3s)
  ✔ test › stripFinalNewline: false (2.3s)
  ✔ test › stripFinalNewline on failure (2.3s)
  ✔ test › localDir option (1.4s)
  ✔ test › do not try to consume streams twice (1.1s)
  ✔ test › use relative path with '..' chars (1s)
  ✔ test › write to fast-exit process (908ms)
  ✔ test › use environment variables by default (857ms)
  ✔ test › extend environment variables by default (817ms)
  ✔ test › localDir option can be a URL (729ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (508ms)
  ✔ test › do not extend environment with `extendEnv: false` (812ms)
  ✔ test › can use `options.cwd` as a string (771ms)
  ✔ test › can use `options.cwd` as a URL (686ms)
  ✔ test › can use `options.shell: true` (629ms)
  ✔ test › can use `options.shell: string` (669ms)
  ✔ test › detach child process (982ms)
  ✔ test › execPath option (2.1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (2.6s)
  ✔ stream › input option can be a String - sync (2s)
  ✔ stream › input option can be a Buffer - sync (1.1s)
  ✔ stream › helpful error trying to provide an input stream in sync mode (624ms)
  ✔ stream › buffer (2.9s)
  ✔ stream › pass `stdout` to a file descriptor (2.8s)
  ✔ stream › pass `stderr` to a file descriptor (2.8s)
  ✔ stream › result.all is undefined unless opts.all is true (2.8s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.7s)
  ✔ stream › input option can be a String (2.4s)
  ✔ stream › input option can be a Buffer (2.4s)
  ✔ stream › input can be a Stream (2.3s)
  ✔ stream › you can write to child.stdin (2.3s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (882ms)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (875ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (842ms)
  ✔ stream › do not buffer when streaming (829ms)
  ✔ stream › buffer: false > promise resolves (862ms)
  ✔ stream › buffer: false > promise resolves when output is big and is read (963ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (882ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1s)
  ✔ stream › maxBuffer affects stdout (1.3s)
  ✔ stream › maxBuffer affects stderr (1.3s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1s)
  ✔ stream › can use all: true with stdout: ignore (906ms)
  ✔ stream › can use all: true with stderr: ignore (903ms)
  ✔ test › preferLocal: true (3.5s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsFile/execa/variant5/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (704ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (2s)
  ✔ error › result.killed is false if not killed, in sync mode (1s)
  ✔ error › result.killed is false on process error, in sync mode (305ms)
  ✔ error › Original error.message is kept (1.6s)
  ✔ error › error.code is defined on failure if applicable (103ms)
  ✔ error › result.killed is false on process error (425ms)
  ✔ error › stdout/stderr/all on process errors (2.1s)
  ✔ error › stdout/stderr/all available on errors (2.3s)
  ✔ error › exitCode is 0 on success (2.2s)
  ✔ error › exitCode is 2 (2.1s)
  ✔ error › exitCode is 3 (2.1s)
  ✔ error › exitCode is 4 (2s)
  ✔ error › error.message contains the command (2s)
  ✔ error › error.message contains stdout/stderr if available (1.9s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.8s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.8s)
  ✔ error › failed is false on success (1.7s)
  ✔ error › failed is true on failure (1.6s)
  ✔ error › error.killed is true if process was killed directly (1.5s)
  ✔ error › error.killed is false if process was killed indirectly (1.5s)
  ✔ error › result.killed is false if not killed (1.3s)
  ✔ error › error.signal is SIGINT (498ms)
  ✔ error › error.signalDescription is defined (482ms)
  ✔ error › error.signal is SIGTERM (474ms)
  ✔ error › exitCode is undefined on signal termination (447ms)
  ✔ error › custom error.signal (461ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (471ms)
  ✔ error › result.signal is undefined for successful execution (542ms)
  ✔ error › error.code is undefined on success (520ms)
  ✔ error › result.signalDescription is undefined for successful execution (570ms)
  ✔ command › allow commands with spaces and no array arguments (3s)
  ✔ command › allow commands with spaces and array arguments (2.9s)
  ✔ command › execaCommand() (2.8s)
  ✔ command › execaCommand() ignores consecutive spaces (2.7s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.6s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.6s)
  ✔ command › execaCommand() escapes other whitespaces (2.4s)
  ✔ command › execaCommand() trims (2.3s)
  ✔ command › command is: " foo bar" (3.3s)
  ✔ command › command is: " baz quz" (3.2s)
  ✔ command › command is: "" (3.2s)
  ✔ command › escapedCommand is: "foo bar" (3.4s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.6s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3.7s)
  ✔ command › escapedCommand is: "\"*\"" (3.8s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.5s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.5s)
  ✔ kill › execa() returns a promise with kill() (3.4s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3.2s)
  ✔ kill › cancel method kills the subprocess (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (985ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (3.4s)
  ✔ kill › timeout must not be negative (3.3s)
  ✔ kill › timeout must be an integer (3.3s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel
  ✔ kill › calling abort twice should show the same behaviour as calling it once (124ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (139ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.7s)
  ✔ kill › timeout does not kill the process if it does not time out (3.5s)
  ✔ kill › timedOut is false if timeout is undefined (3.4s)
  ✔ kill › timedOut is false if timeout is 0 (3.4s)
  ✔ kill › spawnAndExit (3s)
  ✔ kill › spawnAndExit cleanup (3s)
  ✔ kill › spawnAndExit detached (2.9s)
  ✔ kill › spawnAndExit cleanup detached (2.8s)
  ✔ kill › spawnAndKill SIGTERM (2.8s)
  ✔ kill › spawnAndKill SIGKILL (2.8s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.7s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.5s)
  ✔ kill › removes exit handler on exit (2.5s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.4s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.3s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (382ms)
  ✔ kill › error.isCanceled is true when cancel method is used (349ms)
  ✔ kill › error.isCanceled is false when kill method is used (331ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (316ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (268ms)
  ✔ kill › spawnAndKill detached SIGTERM (2.7s)
  ✔ kill › spawnAndKill detached SIGKILL (2.6s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.6s)
  ✔ kill › timeout kills the process if it times out (3.6s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.8s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.8s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.8s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (370ms)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (358ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (118ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process (106ms)
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process (105ms)
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process (106ms)
  ✔ node › node should not remove --inspect when passed through nodeOptions (113ms)
  ✔ node › node correctly use nodePath
  ✔ node › node's forked script has a communication channel (197ms)
  ✔ node › node pass on nodeOptions (249ms)
  ✔ node › node pipe stdout (289ms)
  ✔ node › node() (306ms)
  ✔ override-promise › should work with third-party Promise (127ms)
  ✔ promise › promise methods are not enumerable (116ms)
  ✔ promise › throw in finally bubbles up on error (230ms)
  ✔ promise › finally function is executed on failure (365ms)
  ✔ promise › finally function is executed on success (391ms)
  ✔ promise › throw in finally function bubbles up on success (377ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.7s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.7s)
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1.1s)
  ✔ test › execaSync() (2.3s)
  ✔ test › execaSync() throws error if written to stderr (2s)
  ✔ test › skip throwing when using reject option in sync mode (1.9s)
  ✔ test › stripFinalNewline in sync mode (1.6s)
  ✔ test › stripFinalNewline in sync mode on failure (1.4s)
  ✔ test › execa() returns a promise with pid (1.2s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1.1s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (1s)
  ✔ test › child_process.spawn() errors are propagated (1.1s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (979ms)
  ✔ test › execa() rejects if running non-executable (1s)
  ✔ test › preferLocal: undefined (1.5s)
  ✔ test › preferLocal: false (1.5s)
  ✔ test › child process errors rejects promise right away (1.4s)
  ✔ test › child process errors are handled (1.5s)
  ✔ test › stdin errors are handled (1.5s)
  ✔ test › execa() (2.8s)
  ✔ test › skip throwing when using reject option (2.3s)
  ✔ test › stripFinalNewline: true (2.1s)
  ✔ test › stripFinalNewline: false (2.1s)
  ✔ test › stripFinalNewline on failure (2s)
  ✔ test › localDir option (1.6s)
  ✔ test › do not try to consume streams twice (1.3s)
  ✔ test › use relative path with '..' chars (1.3s)
  ✔ test › write to fast-exit process (1.1s)
  ✔ test › use environment variables by default (1s)
  ✔ test › extend environment variables by default (976ms)
  ✔ test › can use `options.cwd` as a string (870ms)
  ✔ test › localDir option can be a URL (836ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (605ms)
  ✔ test › do not extend environment with `extendEnv: false` (938ms)
  ✔ test › can use `options.cwd` as a URL (787ms)
  ✔ test › can use `options.shell: true` (843ms)
  ✔ test › can use `options.shell: string` (788ms)
  ✔ test › execPath option (2s)
  ✔ test › detach child process (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (2.5s)
  ✔ stream › input option can be a String - sync (1.5s)
  ✔ stream › input option can be a Buffer - sync (878ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (502ms)
  ✔ stream › buffer (2.7s)
  ✔ stream › pass `stdout` to a file descriptor (2.8s)
  ✔ stream › pass `stderr` to a file descriptor (2.7s)
  ✔ stream › result.all is undefined unless opts.all is true (2.7s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.7s)
  ✔ stream › input option can be a String (1.8s)
  ✔ stream › input option can be a Buffer (1.8s)
  ✔ stream › input can be a Stream (1.8s)
  ✔ stream › you can write to child.stdin (1.8s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (777ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (772ms)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (840ms)
  ✔ stream › do not buffer when streaming (844ms)
  ✔ stream › buffer: false > promise resolves (883ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (728ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (970ms)
  ✔ stream › maxBuffer affects stdout (1.2s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (996ms)
  ✔ stream › maxBuffer affects stderr (1.2s)
  ✔ stream › can use all: true with stdout: ignore (948ms)
  ✔ stream › can use all: true with stderr: ignore (899ms)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.1s)
  ✔ test › preferLocal: true (3.9s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsFile/execa/variant4/execa

> execa@6.1.0 test
> xo && c8 ava && tsd

./VariantsFile/execa/variant3/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ error › stdout/stderr/all on process errors, in sync mode (1.8s)
  ✔ error › result.killed is false if not killed, in sync mode (1.2s)
  ✔ error › result.killed is false on process error, in sync mode (353ms)
  ✔ error › Original error.message is kept (1.6s)
  ✔ error › error.code is defined on failure if applicable
  ✔ command › execaCommandSync() (587ms)
  ✔ error › result.killed is false on process error (528ms)
  ✔ error › stdout/stderr/all on process errors (2s)
  ✔ error › stdout/stderr/all available on errors (2.2s)
  ✔ error › exitCode is 0 on success (2s)
  ✔ error › exitCode is 2 (2s)
  ✔ error › exitCode is 3 (2s)
  ✔ error › exitCode is 4 (2s)
  ✔ error › error.message contains the command (1.9s)
  ✔ error › error.message contains stdout/stderr if available (1.9s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.9s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.9s)
  ✔ error › failed is false on success (1.8s)
  ✔ error › failed is true on failure (1.7s)
  ✔ error › error.killed is true if process was killed directly (1.7s)
  ✔ error › error.killed is false if process was killed indirectly (1.6s)
  ✔ error › result.killed is false if not killed (1.6s)
  ✔ error › error.signal is SIGINT (631ms)
  ✔ error › error.signalDescription is defined (595ms)
  ✔ error › error.signal is SIGTERM (585ms)
  ✔ error › exitCode is undefined on signal termination (501ms)
  ✔ error › custom error.signal (575ms)
  ✔ error › result.signal is undefined for successful execution (515ms)
  ✔ error › error.code is undefined on success (439ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (512ms)
  ✔ error › result.signalDescription is undefined for successful execution (475ms)
  ✔ command › allow commands with spaces and no array arguments (2.7s)
  ✔ command › allow commands with spaces and array arguments (2.6s)
  ✔ command › execaCommand() (2.6s)
  ✔ command › execaCommand() ignores consecutive spaces (2.5s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.5s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.4s)
  ✔ command › execaCommand() escapes other whitespaces (2.4s)
  ✔ command › execaCommand() trims (2.2s)
  ✔ command › command is: " foo bar" (3.2s)
  ✔ command › command is: " baz quz" (3.1s)
  ✔ command › command is: "" (3s)
  ✔ command › escapedCommand is: "foo bar" (3.6s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.9s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (4.4s)
  ✔ command › escapedCommand is: "\"*\"" (5.5s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.5s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.5s)
  ✔ kill › execa() returns a promise with kill() (3.5s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3.2s)
  ✔ kill › cancel method kills the subprocess (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (977ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (3.4s)
  ✔ kill › timeout must not be negative (3.4s)
  ✔ kill › timeout must be an integer (3.4s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel
  ✔ kill › calling abort twice should show the same behaviour as calling it once (146ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (170ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.7s)
  ✔ kill › timeout does not kill the process if it does not time out (3.5s)
  ✔ kill › timedOut is false if timeout is undefined (3.5s)
  ✔ kill › timedOut is false if timeout is 0 (3.5s)
  ✔ kill › spawnAndExit (3s)
  ✔ kill › spawnAndExit cleanup (3s)
  ✔ kill › spawnAndExit detached (3s)
  ✔ kill › spawnAndExit cleanup detached (2.9s)
  ✔ kill › spawnAndKill SIGTERM (2.9s)
  ✔ kill › spawnAndKill SIGKILL (2.9s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.8s)
  ✔ kill › spawnAndKill detached SIGTERM (2.8s)
  ✔ kill › spawnAndKill detached SIGKILL (2.7s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.7s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.6s)
  ✔ kill › removes exit handler on exit (2.6s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.5s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.3s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (450ms)
  ✔ kill › error.isCanceled is true when cancel method is used (428ms)
  ✔ kill › error.isCanceled is false when kill method is used (414ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (385ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (338ms)
  ✔ kill › timeout kills the process if it times out (3.7s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (4s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.9s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.9s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (427ms)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (396ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (131ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions (107ms)
  ✔ node › node correctly use nodePath
  ✔ node › node() (335ms)
  ✔ node › node pipe stdout (323ms)
  ✔ node › node's forked script has a communication channel (277ms)
  ✔ node › node pass on nodeOptions (306ms)
  ✔ override-promise › should work with third-party Promise (152ms)
  ✔ promise › promise methods are not enumerable (153ms)
  ✔ promise › finally function is executed on failure (378ms)
  ✔ promise › finally function is executed on success (411ms)
  ✔ promise › throw in finally bubbles up on error (341ms)
  ✔ promise › throw in finally function bubbles up on success (416ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.7s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.7s)
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.2s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ test › execaSync() (2.2s)
  ✔ test › execaSync() throws error if written to stderr (2.1s)
  ✔ test › skip throwing when using reject option in sync mode (2s)
  ✔ test › stripFinalNewline in sync mode (1.7s)
  ✔ test › stripFinalNewline in sync mode on failure (1.4s)
  ✔ test › execa() returns a promise with pid (1.2s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1.2s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (1.1s)
  ✔ test › child_process.spawn() errors are propagated (1.3s)
  ✔ test › write to fast-exit process (969ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (1s)
  ✔ test › execa() rejects if running non-executable (1.1s)
  ✔ test › preferLocal: undefined (1.6s)
  ✔ test › preferLocal: false (1.6s)
  ✔ test › child process errors rejects promise right away (1.6s)
  ✔ test › child process errors are handled (1.6s)
  ✔ test › stdin errors are handled (1.6s)
  ✔ test › execa() (2.8s)
  ✔ test › skip throwing when using reject option (2.6s)
  ✔ test › stripFinalNewline: true (2.3s)
  ✔ test › stripFinalNewline: false (2.3s)
  ✔ test › stripFinalNewline on failure (2.3s)
  ✔ test › localDir option (1.8s)
  ✔ test › do not try to consume streams twice (1.5s)
  ✔ test › use relative path with '..' chars (1.5s)
  ✔ test › use environment variables by default (1.1s)
  ✔ test › extend environment variables by default (1s)
  ✔ test › do not extend environment with `extendEnv: false` (1s)
  ✔ test › can use `options.cwd` as a string (967ms)
  ✔ test › localDir option can be a URL (905ms)
  ✔ test › can use `options.cwd` as a URL (841ms)
  ✔ test › can use `options.shell: true` (796ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (713ms)
  ✔ test › can use `options.shell: string` (782ms)
  ✔ test › detach child process (886ms)
  ✔ test › execPath option (2.1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (2.1s)
  ✔ stream › input option can be a String - sync (1.2s)
  ✔ stream › input option can be a Buffer - sync (831ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (475ms)
  ✔ stream › buffer (2.5s)
  ✔ stream › pass `stdout` to a file descriptor (2.4s)
  ✔ stream › pass `stderr` to a file descriptor (2.4s)
  ✔ stream › result.all is undefined unless opts.all is true (2.3s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.3s)
  ✔ stream › you can write to child.stdin (1.5s)
  ✔ stream › input option can be a String (1.6s)
  ✔ stream › input option can be a Buffer (1.6s)
  ✔ stream › input can be a Stream (1.5s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (718ms)
  ✔ stream › do not buffer when streaming (788ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (810ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (738ms)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (900ms)
  ✔ stream › buffer: false > promise resolves (972ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (970ms)
  ✔ stream › can use all: true with stdout: ignore (932ms)
  ✔ stream › can use all: true with stderr: ignore (875ms)
  ✔ stream › maxBuffer affects stdout (1.2s)
  ✔ stream › maxBuffer affects stderr (1.2s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.1s)
  ✔ test › preferLocal: true (3.7s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsFile/execa/variant2/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ error › stdout/stderr/all on process errors, in sync mode (2.2s)
  ✔ error › result.killed is false if not killed, in sync mode (1.5s)
  ✔ error › result.killed is false on process error, in sync mode (562ms)
  ✔ error › Original error.message is kept (1.9s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (680ms)
  ✔ error › stdout/stderr/all on process errors (2.4s)
  ✔ command › execaCommandSync() (845ms)
  ✔ error › stdout/stderr/all available on errors (2.6s)
  ✔ error › exitCode is 0 on success (2.4s)
  ✔ error › exitCode is 2 (2.4s)
  ✔ error › exitCode is 3 (2.4s)
  ✔ error › exitCode is 4 (2.3s)
  ✔ error › error.message contains the command (2.3s)
  ✔ error › error.message contains stdout/stderr if available (2.2s)
  ✔ error › error.message does not contain stdout/stderr if not available (2.2s)
  ✔ error › error.shortMessage does not contain stdout/stderr (2.2s)
  ✔ error › failed is false on success (2.1s)
  ✔ error › failed is true on failure (2s)
  ✔ error › error.killed is true if process was killed directly (1.9s)
  ✔ error › error.killed is false if process was killed indirectly (1.8s)
  ✔ error › result.killed is false if not killed (1.8s)
  ✔ error › error.signal is SIGINT (768ms)
  ✔ error › error.signalDescription is defined (712ms)
  ✔ error › error.signal is SIGTERM (659ms)
  ✔ error › exitCode is undefined on signal termination (550ms)
  ✔ error › custom error.signal (615ms)
  ✔ error › error.code is undefined on success (526ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (617ms)
  ✔ error › result.signal is undefined for successful execution (687ms)
  ✔ error › result.signalDescription is undefined for successful execution (641ms)
  ✔ command › allow commands with spaces and no array arguments (2.9s)
  ✔ command › allow commands with spaces and array arguments (2.8s)
  ✔ command › execaCommand() (2.7s)
  ✔ command › execaCommand() ignores consecutive spaces (2.7s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.6s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.6s)
  ✔ command › execaCommand() escapes other whitespaces (2.5s)
  ✔ command › execaCommand() trims (2.4s)
  ✔ command › command is: " foo bar" (3.3s)
  ✔ command › command is: " baz quz" (3.2s)
  ✔ command › command is: "" (3.1s)
  ✔ command › escapedCommand is: "foo bar" (3.3s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.6s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3.9s)
  ✔ command › escapedCommand is: "\"*\"" (4.4s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (4.3s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (4.2s)
  ✔ kill › execa() returns a promise with kill() (4.2s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3.8s)
  ✔ kill › cancel method kills the subprocess (2.7s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2.5s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (1.1s)
  ✔ kill › timeout kills the process if it times out, in sync mode (4.1s)
  ✔ kill › timeout must not be negative (4s)
  ✔ kill › timeout must be an integer (4s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (109ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (143ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (179ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (4.5s)
  ✔ kill › timeout does not kill the process if it does not time out (4.2s)
  ✔ kill › timedOut is false if timeout is undefined (4.1s)
  ✔ kill › timedOut is false if timeout is 0 (4.1s)
  ✔ kill › spawnAndExit (3.5s)
  ✔ kill › spawnAndExit cleanup (3.5s)
  ✔ kill › spawnAndExit detached (3.5s)
  ✔ kill › spawnAndExit cleanup detached (3.4s)
  ✔ kill › spawnAndKill SIGTERM (3.4s)
  ✔ kill › spawnAndKill SIGKILL (3.3s)
  ✔ kill › spawnAndKill cleanup SIGKILL (3.3s)
  ✔ kill › spawnAndKill detached SIGTERM (3.3s)
  ✔ kill › spawnAndKill detached SIGKILL (3.2s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (3.2s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (3.1s)
  ✔ kill › removes exit handler on exit (3.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.9s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.8s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (466ms)
  ✔ kill › error.isCanceled is true when cancel method is used (439ms)
  ✔ kill › error.isCanceled is false when kill method is used (406ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (383ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (339ms)
  ✔ kill › timeout kills the process if it times out (4.4s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (4.7s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (372ms)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (298ms)
  ✔ kill › spawnAndKill cleanup SIGTERM (3.4s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (4.6s)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (125ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node pass on nodeOptions (164ms)
  ✔ node › node() (225ms)
  ✔ node › node pipe stdout (246ms)
  ✔ node › node's forked script has a communication channel (223ms)
  ✔ override-promise › should work with third-party Promise (372ms)
  ✔ promise › promise methods are not enumerable (135ms)
  ✔ promise › finally function is executed on success (302ms)
  ✔ promise › throw in finally function bubbles up on success (262ms)
  ✔ promise › finally function is executed on failure (362ms)
  ✔ promise › throw in finally bubbles up on error (305ms)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (9.5s)
  ✔ kill › kill() with no arguments should kill after a timeout (9.5s)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.3s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ test › execaSync() (2.4s)
  ✔ test › execaSync() throws error if written to stderr (2s)
  ✔ test › skip throwing when using reject option in sync mode (2s)
  ✔ test › stripFinalNewline in sync mode (1.5s)
  ✔ test › stripFinalNewline in sync mode on failure (1.3s)
  ✔ test › execa() returns a promise with pid (966ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (929ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (855ms)
  ✔ test › child_process.spawn() errors are propagated (1.1s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (1s)
  ✔ test › execa() rejects if running non-executable (1s)
  ✔ test › preferLocal: undefined (1.4s)
  ✔ test › preferLocal: false (1.4s)
  ✔ test › child process errors rejects promise right away (1.3s)
  ✔ test › child process errors are handled (1.4s)
  ✔ test › stdin errors are handled (1.4s)
  ✔ test › execa() (3.1s)
  ✔ test › skip throwing when using reject option (2.7s)
  ✔ test › stripFinalNewline: true (2.2s)
  ✔ test › stripFinalNewline: false (2.2s)
  ✔ test › stripFinalNewline on failure (2.2s)
  ✔ test › localDir option (1.7s)
  ✔ test › do not try to consume streams twice (1.4s)
  ✔ test › use relative path with '..' chars (1.4s)
  ✔ test › write to fast-exit process (1.3s)
  ✔ test › use environment variables by default (1.2s)
  ✔ test › extend environment variables by default (1.2s)
  ✔ test › do not extend environment with `extendEnv: false` (1.1s)
  ✔ test › can use `options.cwd` as a string (1.1s)
  ✔ test › localDir option can be a URL (1.1s)
  ✔ test › can use `options.cwd` as a URL (1s)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (855ms)
  ✔ test › can use `options.shell: string` (914ms)
  ✔ test › can use `options.shell: true` (935ms)
  ✔ test › detach child process (1.4s)
  ✔ test › execPath option (2.8s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (2.3s)
  ✔ stream › input option can be a String - sync (1.5s)
  ✔ stream › input option can be a Buffer - sync (1s)
  ✔ stream › helpful error trying to provide an input stream in sync mode (744ms)
  ✔ stream › buffer (2.7s)
  ✔ stream › pass `stdout` to a file descriptor (2.7s)
  ✔ stream › pass `stderr` to a file descriptor (2.6s)
  ✔ stream › result.all is undefined unless opts.all is true (2.5s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.4s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (815ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (945ms)
  ✔ stream › input option can be a Buffer (1.9s)
  ✔ stream › input option can be a String (2s)
  ✔ stream › you can write to child.stdin (1.9s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (1.1s)
  ✔ stream › input can be a Stream (1.9s)
  ✔ stream › do not buffer when streaming (975ms)
  ✔ stream › buffer: false > promise resolves (1s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.1s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (975ms)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1s)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1.2s)
  ✔ stream › can use all: true with stdout: ignore (1s)
  ✔ stream › maxBuffer affects stderr (1.5s)
  ✔ stream › maxBuffer affects stdout (1.5s)
  ✔ stream › can use all: true with stderr: ignore (975ms)
  ✔ test › preferLocal: true (4.6s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsFile/execa/variant1/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (830ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (2.3s)
  ✔ error › result.killed is false if not killed, in sync mode (1.3s)
  ✔ error › result.killed is false on process error, in sync mode (282ms)
  ✔ error › Original error.message is kept (1.9s)
  ✔ error › error.code is defined on failure if applicable (124ms)
  ✔ error › result.killed is false on process error (503ms)
  ✔ error › stdout/stderr/all on process errors (2.6s)
  ✔ error › stdout/stderr/all available on errors (3s)
  ✔ error › exitCode is 0 on success (2.7s)
  ✔ error › exitCode is 2 (2.7s)
  ✔ error › exitCode is 3 (2.7s)
  ✔ error › exitCode is 4 (2.6s)
  ✔ error › error.message contains the command (2.6s)
  ✔ error › error.message contains stdout/stderr if available (2.5s)
  ✔ error › error.message does not contain stdout/stderr if not available (2.4s)
  ✔ error › error.shortMessage does not contain stdout/stderr (2.3s)
  ✔ error › failed is false on success (2.3s)
  ✔ error › failed is true on failure (2.1s)
  ✔ error › error.killed is true if process was killed directly (2.1s)
  ✔ error › error.killed is false if process was killed indirectly (2s)
  ✔ error › result.killed is false if not killed (1.9s)
  ✔ error › error.signal is SIGINT (753ms)
  ✔ error › error.signalDescription is defined (745ms)
  ✔ error › error.signal is SIGTERM (736ms)
  ✔ error › exitCode is undefined on signal termination (692ms)
  ✔ error › custom error.signal (763ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (714ms)
  ✔ error › result.signalDescription is undefined for successful execution (684ms)
  ✔ error › error.code is undefined on success (678ms)
  ✔ error › result.signal is undefined for successful execution (761ms)
  ✔ command › allow commands with spaces and no array arguments (3.5s)
  ✔ command › allow commands with spaces and array arguments (3.4s)
  ✔ command › execaCommand() (3.3s)
  ✔ command › execaCommand() ignores consecutive spaces (3.2s)
  ✔ command › execaCommand() allows escaping spaces in commands (3.1s)
  ✔ command › execaCommand() allows escaping spaces in arguments (3s)
  ✔ command › execaCommand() escapes other whitespaces (2.9s)
  ✔ command › execaCommand() trims (2.9s)
  ✔ command › command is: " foo bar" (4s)
  ✔ command › command is: " baz quz" (4s)
  ✔ command › command is: "" (3.9s)
  ✔ command › escapedCommand is: "foo bar" (4.1s)
  ✔ command › escapedCommand is: "\"foo bar\"" (4.2s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (4.5s)
  ✔ command › escapedCommand is: "\"*\"" (5s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.9s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.9s)
  ✔ kill › execa() returns a promise with kill() (3.8s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3.6s)
  ✔ kill › cancel method kills the subprocess (2.5s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2.4s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (1s)
  ✔ kill › timeout kills the process if it times out, in sync mode (3.8s)
  ✔ kill › timeout must not be negative (3.7s)
  ✔ kill › timeout must be an integer (3.7s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (114ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (140ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (164ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (4.2s)
  ✔ kill › timeout does not kill the process if it does not time out (3.9s)
  ✔ kill › timedOut is false if timeout is undefined (3.8s)
  ✔ kill › timedOut is false if timeout is 0 (3.8s)
  ✔ kill › spawnAndExit (3.2s)
  ✔ kill › spawnAndExit cleanup (3.2s)
  ✔ kill › spawnAndExit detached (3.1s)
  ✔ kill › spawnAndExit cleanup detached (3.1s)
  ✔ kill › spawnAndKill SIGTERM (3.1s)
  ✔ kill › spawnAndKill SIGKILL (3.1s)
  ✔ kill › spawnAndKill cleanup SIGKILL (3s)
  ✔ kill › spawnAndKill detached SIGTERM (3s)
  ✔ kill › spawnAndKill detached SIGKILL (2.9s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.9s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.9s)
  ✔ kill › removes exit handler on exit (2.8s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.7s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.6s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (471ms)
  ✔ kill › error.isCanceled is true when cancel method is used (463ms)
  ✔ kill › error.isCanceled is false when kill method is used (444ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (402ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (349ms)
  ✔ kill › timeout kills the process if it times out (4s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (4.4s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (4.3s)
  ✔ kill › spawnAndKill cleanup SIGTERM (3.1s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (374ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (503ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (236ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process (144ms)
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process (106ms)
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process (145ms)
  ✔ node › node should not remove --inspect when passed through nodeOptions (117ms)
  ✔ node › node correctly use nodePath
  ✔ node › node() (252ms)
  ✔ node › node pass on nodeOptions (261ms)
  ✔ node › node pipe stdout (344ms)
  ✔ node › node's forked script has a communication channel (267ms)
  ✔ override-promise › should work with third-party Promise (253ms)
  ✔ promise › promise methods are not enumerable (181ms)
  ✔ promise › finally function is executed on success (405ms)
  ✔ promise › throw in finally bubbles up on error (335ms)
  ✔ promise › finally function is executed on failure (444ms)
  ✔ promise › throw in finally function bubbles up on success (423ms)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (9.1s)
  ✔ kill › kill() with no arguments should kill after a timeout (9.1s)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.4s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ test › execaSync() (3.1s)
  ✔ test › execaSync() throws error if written to stderr (2.9s)
  ✔ test › skip throwing when using reject option in sync mode (2.8s)
  ✔ test › stripFinalNewline in sync mode (2.2s)
  ✔ test › stripFinalNewline in sync mode on failure (1.7s)
  ✔ test › execa() returns a promise with pid (1.1s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (993ms)
  ✔ test › child_process.spawn() errors are propagated (1.1s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (1s)
  ✔ test › execa() rejects if running non-executable (1.1s)
  ✔ test › preferLocal: undefined (1.5s)
  ✔ test › preferLocal: false (1.6s)
  ✔ test › child process errors rejects promise right away (1.5s)
  ✔ test › child process errors are handled (1.5s)
  ✔ test › stdin errors are handled (1.5s)
  ✔ test › execa() (4s)
  ✔ test › skip throwing when using reject option (3.6s)
  ✔ test › stripFinalNewline: true (3.3s)
  ✔ test › stripFinalNewline: false (3.2s)
  ✔ test › stripFinalNewline on failure (3.1s)
  ✔ test › localDir option (2s)
  ✔ test › do not try to consume streams twice (1.8s)
  ✔ test › use relative path with '..' chars (1.7s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (3.1s)
  ✔ stream › input option can be a String - sync (2.2s)
  ✔ stream › input option can be a Buffer - sync (1.6s)
  ✔ stream › helpful error trying to provide an input stream in sync mode (838ms)
  ✔ test › write to fast-exit process (1.5s)
  ✔ test › use environment variables by default (1.5s)
  ✔ test › extend environment variables by default (1.4s)
  ✔ test › can use `options.cwd` as a string (1.3s)
  ✔ test › localDir option can be a URL (1.2s)
  ✔ test › can use `options.cwd` as a URL (1.2s)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (1s)
  ✔ stream › buffer (3.4s)
  ✔ stream › pass `stdout` to a file descriptor (3.4s)
  ✔ stream › pass `stderr` to a file descriptor (3.3s)
  ✔ stream › result.all is undefined unless opts.all is true (3.2s)
  ✔ stream › stdout/stderr/all are undefined if ignored (3.1s)
  ✔ test › do not extend environment with `extendEnv: false` (1.4s)
  ✔ test › can use `options.shell: true` (1.2s)
  ✔ test › can use `options.shell: string` (1.2s)
  ✔ stream › input option can be a String (2.6s)
  ✔ stream › you can write to child.stdin (2.5s)
  ✔ stream › input option can be a Buffer (2.7s)
  ✔ stream › input can be a Stream (2.6s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (1.2s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (1.1s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (1.2s)
  ✔ stream › buffer: false > promise resolves (1s)
  ✔ stream › do not buffer when streaming (1.2s)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1.2s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.2s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (1.1s)
  ✔ test › detach child process (1.9s)
  ✔ stream › maxBuffer affects stdout (1.8s)
  ✔ stream › can use all: true with stderr: ignore (1s)
  ✔ stream › can use all: true with stdout: ignore (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.3s)
  ✔ stream › maxBuffer affects stderr (1.8s)
  ✔ test › execPath option (3.1s)
  ✔ test › preferLocal: true (3.9s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------

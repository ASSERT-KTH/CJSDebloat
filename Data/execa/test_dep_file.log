13
./VariantsPureDep/execa/variant13/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✖ command › execaCommandSync() Error thrown in test
  ✖ command › command is: " foo bar" Rejected promise returned by test
  ✖ command › command is: " baz quz" Rejected promise returned by test
  ✖ command › command is: "" Rejected promise returned by test
  ✖ command › escapedCommand is: "foo bar" Rejected promise returned by test
  ✖ command › escapedCommand is: "\"foo bar\"" Rejected promise returned by test
  ✖ command › escapedCommand is: "\"\\\"foo\\\"\"" Rejected promise returned by test
  ✖ command › escapedCommand is: "\"*\"" Rejected promise returned by test
  ✖ command › allow commands with spaces and no array arguments Rejected promise returned by test
  ✖ command › allow commands with spaces and array arguments Rejected promise returned by test
  ✖ command › execaCommand() Rejected promise returned by test
  ✖ command › execaCommand() ignores consecutive spaces Rejected promise returned by test
  ✖ command › execaCommand() allows escaping spaces in commands Rejected promise returned by test
  ✖ command › execaCommand() allows escaping spaces in arguments Rejected promise returned by test
  ✖ command › execaCommand() escapes other whitespaces Rejected promise returned by test
  ✖ command › execaCommand() trims Rejected promise returned by test
  ✖ error › stdout/stderr/all on process errors, in sync mode 
  ✖ error › result.killed is false if not killed, in sync mode Error thrown in test
  ✖ error › result.killed is false on process error, in sync mode 
  ✖ error › stdout/stderr/all available on errors Rejected promise returned by test
  ✖ error › stdout/stderr/all on process errors Rejected promise returned by test
  ✖ error › exitCode is 0 on success Rejected promise returned by test
  ✖ error › exitCode is 2 Rejected promise returned by test
  ✖ error › exitCode is 3 Rejected promise returned by test
  ✖ error › exitCode is 4 Rejected promise returned by test
  ✖ error › error.message contains the command Rejected promise returned by test
  ✖ error › error.message contains stdout/stderr if available Rejected promise returned by test
  ✖ error › error.message does not contain stdout/stderr if not available Rejected promise returned by test
  ✖ error › error.shortMessage does not contain stdout/stderr Rejected promise returned by test
  ✖ error › Original error.message is kept Rejected promise returned by test
  ✖ error › failed is false on success Rejected promise returned by test
  ✖ error › failed is true on failure Rejected promise returned by test
  ✖ error › error.killed is true if process was killed directly Rejected promise returned by test
  ✖ error › error.killed is false if process was killed indirectly Rejected promise returned by test
  ✖ error › result.killed is false if not killed Rejected promise returned by test
  ✖ error › result.killed is false on process error Rejected promise returned by test
  ✖ error › error.signal is SIGINT Rejected promise returned by test
  ✖ error › error.signalDescription is defined Rejected promise returned by test
  ✖ error › error.signal is SIGTERM Rejected promise returned by test
  ✖ error › custom error.signal Rejected promise returned by test
  ✖ error › exitCode is undefined on signal termination Rejected promise returned by test
  ✖ error › result.signal is undefined for successful execution Rejected promise returned by test
  ✖ error › result.signal is undefined if process failed, but was not killed Rejected promise returned by test
  ✖ error › result.signalDescription is undefined for successful execution Rejected promise returned by test
  ✖ error › error.code is undefined on success Rejected promise returned by test
  ✖ error › error.code is defined on failure if applicable Rejected promise returned by test
  ✖ node › node removes --inspect from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect=9222 from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect-brk from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node should not remove --inspect when passed through nodeOptions Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout` should not be NaN 
  ✖ kill › `forceKillAfterTimeout` should not be negative 
  ✖ kill › execa() returns a promise with kill() Error thrown in test
  ✖ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode Error thrown in test
  ✖ kill › cancel method kills the subprocess Error thrown in test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) Error thrown in test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) 
  ✖ node › node() Rejected promise returned by test
  ✖ node › node pipe stdout Rejected promise returned by test
  ✖ node › node correctly use nodePath Rejected promise returned by test
  ✖ node › node pass on nodeOptions Rejected promise returned by test
  ✖ node › node's forked script has a communication channel Rejected promise returned by test
  ✖ kill › kill("SIGKILL") should terminate cleanly Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout: false` should not kill after a timeout Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout: number` should kill after a timeout Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout: true` should kill after a timeout Rejected promise returned by test
  ✖ kill › kill() with no arguments should kill after a timeout Rejected promise returned by test
  ✖ kill › timeout kills the process if it times out Rejected promise returned by test
  ✖ kill › timeout does not kill the process if it does not time out Rejected promise returned by test
  ✖ kill › timedOut is false if timeout is undefined Rejected promise returned by test
  ✖ kill › timedOut is false if timeout is 0 Rejected promise returned by test
  ✖ kill › spawnAndExit Rejected promise returned by test
  ✖ kill › spawnAndExit cleanup Rejected promise returned by test
  ✖ kill › spawnAndExit detached Rejected promise returned by test
  ✖ kill › spawnAndExit cleanup detached Rejected promise returned by test
  ✖ kill › spawnAndKill SIGTERM Rejected promise returned by test
  ✖ kill › spawnAndKill SIGKILL Rejected promise returned by test
  ✖ kill › spawnAndKill cleanup SIGTERM Rejected promise returned by test
  ✖ kill › spawnAndKill cleanup SIGKILL Rejected promise returned by test
  ✖ kill › spawnAndKill detached SIGTERM Rejected promise returned by test
  ✖ kill › spawnAndKill detached SIGKILL Rejected promise returned by test
  ✖ kill › spawnAndKill cleanup detached SIGTERM Rejected promise returned by test
  ✖ kill › spawnAndKill cleanup detached SIGKILL Rejected promise returned by test
  ✖ kill › removes exit handler on exit Rejected promise returned by test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called (success) Rejected promise returned by test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) Rejected promise returned by test
  ✖ kill › calling cancel method throws an error with message "Command was canceled" Rejected promise returned by test
  ✖ kill › error.isCanceled is true when cancel method is used Rejected promise returned by test
  ✖ kill › error.isCanceled is false when kill method is used Rejected promise returned by test
  ✖ kill › calling cancel method twice should show the same behaviour as calling it once Rejected promise returned by test
  ✖ kill › calling cancel method on a successfully completed process does not make result.isCanceled true Rejected promise returned by test
  ✖ kill › calling cancel method on a process which has been killed does not make error.isCanceled true Rejected promise returned by test
  ✖ kill › calling abort throws an error with message "Command was canceled" Rejected promise returned by test
  ✖ kill › calling abort twice should show the same behaviour as calling it once Rejected promise returned by test
  ✖ kill › calling abort on a successfully completed process does not make result.isCanceled true Rejected promise returned by test
  ✖ kill › calling cancel after abort should show the same behaviour as only calling cancel Rejected promise returned by test
  ✖ kill › calling abort after cancel should show the same behaviour as only calling cancel Rejected promise returned by test
  ✖ kill › timeout kills the process if it times out, in sync mode 
  ✖ kill › timeout must not be negative 
  ✖ kill › timeout must be an integer 
  ✖ promise › promise methods are not enumerable Error thrown in test
  ✖ promise › finally function is executed on success Rejected promise returned by test
  ✖ promise › finally function is executed on failure Rejected promise returned by test
  ✖ promise › throw in finally function bubbles up on success Rejected promise returned by test
  ✖ promise › throw in finally bubbles up on error Rejected promise returned by test
  ✖ override-promise › should work with third-party Promise Rejected promise returned by test
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✖ stream › result.all shows both `stdout` and `stderr` intermixed Rejected promise returned by test
  ✖ stream › buffer: false > promise does not resolve when output is big and is not read Rejected promise returned by test
  ✖ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read Rejected promise returned by test
  ✖ stream › stdout/stderr/all are undefined if ignored in sync mode Error thrown in test
  ✖ stream › input option can be a String - sync Error thrown in test
  ✖ stream › input option can be a Buffer - sync Error thrown in test
  ✖ stream › helpful error trying to provide an input stream in sync mode 
  ✖ stream › buffer Rejected promise returned by test
  ✖ stream › pass `stdout` to a file descriptor Rejected promise returned by test
  ✖ stream › pass `stderr` to a file descriptor Rejected promise returned by test
  ✖ stream › result.all is undefined unless opts.all is true Rejected promise returned by test
  ✖ stream › stdout/stderr/all are undefined if ignored Rejected promise returned by test
  ✖ stream › input option can be a String Rejected promise returned by test
  ✖ stream › input option can be a Buffer Rejected promise returned by test
  ✖ stream › input can be a Stream Rejected promise returned by test
  ✖ stream › you can write to child.stdin Rejected promise returned by test
  ✖ stream › opts.stdout:ignore - stdout will not collect data Rejected promise returned by test
  ✖ stream › maxBuffer affects stdout Rejected promise returned by test
  ✖ stream › maxBuffer affects stderr Rejected promise returned by test
  ✖ stream › do not buffer stdout when `buffer` set to `false` Rejected promise returned by test
  ✖ stream › do not buffer stderr when `buffer` set to `false` Rejected promise returned by test
  ✖ stream › do not buffer when streaming Rejected promise returned by test
  ✖ stream › buffer: false > promise resolves Rejected promise returned by test
  ✖ stream › buffer: false > promise resolves when output is big but is not pipable Rejected promise returned by test
  ✖ stream › buffer: false > promise resolves when output is big and is read Rejected promise returned by test
  ✖ stream › buffer: false > promise resolves when output is big and "all" is used and is read Rejected promise returned by test
  ✖ stream › buffer: false > promise rejects when process returns non-zero Rejected promise returned by test
  ✖ stream › can use all: true with stdout: ignore Rejected promise returned by test
  ✖ stream › can use all: true with stderr: ignore Rejected promise returned by test
  ✖ test › execaSync() Error thrown in test
  ✖ test › execaSync() throws error if written to stderr 
  ✖ test › skip throwing when using reject option in sync mode Error thrown in test
  ✖ test › stripFinalNewline in sync mode Error thrown in test
  ✖ test › stripFinalNewline in sync mode on failure 
  ✖ test › execa() returns a promise with pid Error thrown in test
  ✖ test › child_process.spawn() propagated errors have correct shape Error thrown in test
  ✖ test › child_process.spawnSync() errors are propagated with a correct shape 
  ✖ test › execa() Rejected promise returned by test
  ✖ test › skip throwing when using reject option Rejected promise returned by test
  ✖ test › stripFinalNewline: true Rejected promise returned by test
  ✖ test › stripFinalNewline: false Rejected promise returned by test
  ✖ test › stripFinalNewline on failure Rejected promise returned by test
  ✖ test › preferLocal: true Rejected promise returned by test
  ✖ test › preferLocal: false Rejected promise returned by test
  ✖ test › preferLocal: undefined Rejected promise returned by test
  ✖ test › localDir option Rejected promise returned by test
  ✖ test › stdin errors are handled Rejected promise returned by test
  ✖ test › child process errors are handled Rejected promise returned by test
  ✖ test › child process errors rejects promise right away Rejected promise returned by test
  ✖ test › child_process.spawn() errors are propagated Rejected promise returned by test
  ✖ test › do not try to consume streams twice Rejected promise returned by test
  ✖ test › use relative path with '..' chars Rejected promise returned by test
  ✖ test › execa() rejects if running non-executable Rejected promise returned by test
  ✖ test › execa() rejects with correct error and doesn't throw if running non-executable with input Rejected promise returned by test
  ✖ test › write to fast-exit process 
  ✖ test › use environment variables by default Rejected promise returned by test
  ✖ test › extend environment variables by default Rejected promise returned by test
  ✖ test › do not extend environment with `extendEnv: false` Rejected promise returned by test
  ✖ test › can use `options.cwd` as a string Rejected promise returned by test
  ✖ test › localDir option can be a URL Rejected promise returned by test
  ✖ test › can use `options.cwd` as a URL Rejected promise returned by test
  ✖ test › can use `options.shell: true` Rejected promise returned by test
  ✖ test › can use `options.shell: string` Rejected promise returned by test
  ✖ test › use extend environment with `extendEnv: true` and `shell: true` Rejected promise returned by test
  ✖ test › detach child process Rejected promise returned by test
  ✖ test › execPath option Rejected promise returned by test
  ─

  command › execaCommandSync()

  test/command.js:85

   84: test('execaCommandSync()', t => {                                        
   85:   const {stdout} = execaCommandSync('node test/fixtures/echo.js foo bar'…
   86:   t.is(stdout, 'foo\nbar');                                              

  Error thrown in test:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execaSync (file://index.js:165:17)
  › execaCommandSync (file://index.js:234:9)
  › file://test/command.js:85:19



  command › command is: " foo bar"

  test/command.js:8

   7: const command = async (t, expected, ...args) => {                         
   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › command (file://test/command.js:8:53)



  command › command is: " baz quz"

  test/command.js:8

   7: const command = async (t, expected, ...args) => {                         
   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › command (file://test/command.js:8:53)



  command › command is: ""

  test/command.js:8

   7: const command = async (t, expected, ...args) => {                         
   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › command (file://test/command.js:8:53)



  command › escapedCommand is: "foo bar"

  test/command.js:22

   21: const testEscapedCommand = async (t, expected, args) => {                
   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › testEscapedCommand (file://test/command.js:22:67)



  command › escapedCommand is: "\"foo bar\""

  test/command.js:22

   21: const testEscapedCommand = async (t, expected, args) => {                
   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › testEscapedCommand (file://test/command.js:22:67)



  command › escapedCommand is: "\"\\\"foo\\\"\""

  test/command.js:22

   21: const testEscapedCommand = async (t, expected, args) => {                
   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › testEscapedCommand (file://test/command.js:22:67)



  command › escapedCommand is: "\"*\""

  test/command.js:22

   21: const testEscapedCommand = async (t, expected, args) => {                
   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › testEscapedCommand (file://test/command.js:22:67)



  command › allow commands with spaces and no array arguments

  test/command.js:45

   44: test('allow commands with spaces and no array arguments', async t => {
   45:   const {stdout} = await execa('command with space.js');              
   46:   t.is(stdout, '');                                                   

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/command.js:45:25



  command › allow commands with spaces and array arguments

  test/command.js:50

   49: test('allow commands with spaces and array arguments', async t => {     
   50:   const {stdout} = await execa('command with space.js', ['foo', 'bar']);
   51:   t.is(stdout, 'foo\nbar');                                             

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/command.js:50:25



  command › execaCommand()

  test/command.js:55

   54: test('execaCommand()', async t => {                                      
   55:   const {stdout} = await execaCommand('node test/fixtures/echo.js foo ba…
   56:   t.is(stdout, 'foo\nbar');                                              

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:55:25



  command › execaCommand() ignores consecutive spaces

  test/command.js:60

   59: test('execaCommand() ignores consecutive spaces', async t => {           
   60:   const {stdout} = await execaCommand('node test/fixtures/echo.js foo   …
   61:   t.is(stdout, 'foo\nbar');                                              

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:60:25



  command › execaCommand() allows escaping spaces in commands

  test/command.js:65

   64: test('execaCommand() allows escaping spaces in commands', async t => {   
   65:   const {stdout} = await execaCommand('command\\ with\\ space.js foo bar…
   66:   t.is(stdout, 'foo\nbar');                                              

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:65:25



  command › execaCommand() allows escaping spaces in arguments

  test/command.js:70

   69: test('execaCommand() allows escaping spaces in arguments', async t => {  
   70:   const {stdout} = await execaCommand('node test/fixtures/echo.js foo\\ …
   71:   t.is(stdout, 'foo bar');                                               

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:70:25



  command › execaCommand() escapes other whitespaces

  test/command.js:75

   74: test('execaCommand() escapes other whitespaces', async t => {            
   75:   const {stdout} = await execaCommand('node test/fixtures/echo.js foo\tb…
   76:   t.is(stdout, 'foo\tbar');                                              

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:75:25



  command › execaCommand() trims

  test/command.js:80

   79: test('execaCommand() trims', async t => {                                
   80:   const {stdout} = await execaCommand('  node test/fixtures/echo.js foo …
   81:   t.is(stdout, 'foo\nbar');                                              

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › execaCommand (file://index.js:229:9)
  › file://test/command.js:80:25



  error › stdout/stderr/all on process errors, in sync mode

  test/error.js:38

   37:   });                         
   38:   t.is(stdout, '');           
   39:   t.is(stderr, WRONG_COMMAND);

  Difference:

  - undefined
  + ''

  › file://test/error.js:38:4



  error › result.killed is false if not killed, in sync mode

  test/error.js:120

   119: test('result.killed is false if not killed, in sync mode', t => {
   120:   const {killed} = execaSync('noop.js');                         
   121:   t.false(killed);                                               

  Error thrown in test:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execaSync (file://index.js:165:17)
  › file://test/error.js:120:19



  error › result.killed is false on process error, in sync mode

  test/error.js:133

   132:   });             
   133:   t.false(killed);
   134: });               

  Value is not `false`:

  undefined

  › file://test/error.js:133:9



  error › stdout/stderr/all available on errors

  test/error.js:17

   16: test('stdout/stderr/all available on errors', async t => {               
   17:   const {stdout, stderr, all} = await t.throwsAsync(execa('exit.js', ['2…
   18:   t.is(typeof stdout, 'string');                                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:17:52



  error › stdout/stderr/all on process errors

  test/error.js:28

   27: test('stdout/stderr/all on process errors', async t => {                 
   28:   const {stdout, stderr, all} = await t.throwsAsync(execa('wrong command…
   29:   t.is(stdout, '');                                                      

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:28:52



  error › exitCode is 0 on success

  test/error.js:44

   43: test('exitCode is 0 on success', async t => {        
   44:   const {exitCode} = await execa('noop.js', ['foo']);
   45:   t.is(exitCode, 0);                                 

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:44:27



  error › exitCode is 2

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › testExitCode (file://test/error.js:49:41)



  error › exitCode is 3

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › testExitCode (file://test/error.js:49:41)



  error › exitCode is 4

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › testExitCode (file://test/error.js:49:41)



  error › error.message contains the command

  test/error.js:58

   57: test('error.message contains the command', async t => {                  
   58:   await t.throwsAsync(execa('exit.js', ['2', 'foo', 'bar']), {message: /…
   59: });                                                                      

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:58:22



  error › error.message contains stdout/stderr if available

  test/error.js:62

   61: test('error.message contains stdout/stderr if available', async t => {
   62:   const {message} = await t.throwsAsync(execa('echo-fail.js'));       
   63:   t.true(message.includes('stderr'));                                 

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:62:40



  error › error.message does not contain stdout/stderr if not available

  test/error.js:68

   67: test('error.message does not contain stdout/stderr if not available', as…
   68:   const {message} = await t.throwsAsync(execa('echo-fail.js', {stdio: 'i…
   69:   t.false(message.includes('stderr'));                                   

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:68:40



  error › error.shortMessage does not contain stdout/stderr

  test/error.js:74

   73: test('error.shortMessage does not contain stdout/stderr', async t => {
   74:   const {shortMessage} = await t.throwsAsync(execa('echo-fail.js'));  
   75:   t.false(shortMessage.includes('stderr'));                           

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:74:45



  error › Original error.message is kept

  test/error.js:80

   79: test('Original error.message is kept', async t => {                      
   80:   const {originalMessage} = await t.throwsAsync(execa('noop.js', {cwd: 1…
   81:   t.true(originalMessage.startsWith('The "options.cwd" property must be …

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:80:48



  error › failed is false on success

  test/error.js:85

   84: test('failed is false on success', async t => {    
   85:   const {failed} = await execa('noop.js', ['foo']);
   86:   t.false(failed);                                 

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:85:25



  error › failed is true on failure

  test/error.js:90

   89: test('failed is true on failure', async t => {                  
   90:   const {failed} = await t.throwsAsync(execa('exit.js', ['2']));
   91:   t.true(failed);                                               

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:90:39



  error › error.killed is true if process was killed directly

  test/error.js:95

   94: test('error.killed is true if process was killed directly', async t => {
   95:   const subprocess = execa('noop.js');                                  
   96:                                                                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:95:21



  error › error.killed is false if process was killed indirectly

  test/error.js:104

   103: test('error.killed is false if process was killed indirectly', async t …
   104:   const subprocess = execa('noop.js');                                  
   105:                                                                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:104:21



  error › result.killed is false if not killed

  test/error.js:115

   114: test('result.killed is false if not killed', async t => {
   115:   const {killed} = await execa('noop.js');               
   116:   t.false(killed);                                       

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:115:25



  error › result.killed is false on process error

  test/error.js:125

   124: test('result.killed is false on process error', async t => {   
   125:   const {killed} = await t.throwsAsync(execa('wrong command'));
   126:   t.false(killed);                                             

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:125:39



  error › error.signal is SIGINT

  test/error.js:150

   149:   test('error.signal is SIGINT', async t => {
   150:     const subprocess = execa('noop.js');     
   151:                                              

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:150:22



  error › error.signalDescription is defined

  test/error.js:159

   158:   test('error.signalDescription is defined', async t => {
   159:     const subprocess = execa('noop.js');                 
   160:                                                          

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:159:22



  error › error.signal is SIGTERM

  test/error.js:168

   167:   test('error.signal is SIGTERM', async t => {
   168:     const subprocess = execa('noop.js');      
   169:                                               

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:168:22



  error › custom error.signal

  test/error.js:177

   176:   test('custom error.signal', async t => {                              
   177:     const {signal} = await t.throwsAsync(execa('noop.js', {killSignal: …
   178:     t.is(signal, 'SIGHUP');                                             

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:177:40



  error › exitCode is undefined on signal termination

  test/error.js:182

   181:   test('exitCode is undefined on signal termination', async t => {
   182:     const subprocess = execa('noop.js');                          
   183:                                                                   

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:182:22



  error › result.signal is undefined for successful execution

  test/error.js:192

   191: test('result.signal is undefined for successful execution', async t => {
   192:   const {signal} = await execa('noop.js');                              
   193:   t.is(signal, undefined);                                              

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:192:25



  error › result.signal is undefined if process failed, but was not killed

  test/error.js:197

   196: test('result.signal is undefined if process failed, but was not killed'…
   197:   const {signal} = await t.throwsAsync(execa('exit.js', [2]), {message:…
   198:   t.is(signal, undefined);                                              

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:197:39



  error › result.signalDescription is undefined for successful execution

  test/error.js:202

   201: test('result.signalDescription is undefined for successful execution', …
   202:   const {signalDescription} = await execa('noop.js');                   
   203:   t.is(signalDescription, undefined);                                   

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:202:36



  error › error.code is undefined on success

  test/error.js:207

   206: test('error.code is undefined on success', async t => {
   207:   const {code} = await execa('noop.js');               
   208:   t.is(code, undefined);                               

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:207:23



  error › error.code is defined on failure if applicable

  test/error.js:212

   211: test('error.code is defined on failure if applicable', async t => {
   212:   const {code} = await t.throwsAsync(execa('noop.js', {cwd: 1}));  
   213:   t.is(code, 'ERR_INVALID_ARG_TYPE');                              

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/error.js:212:37



  node › node removes --inspect from nodeOptions when defined by parent process

  test/node.js:13

   12:   try {                                                 
   13:     const subprocess = execaNode('console.log("foo")', {
   14:       reject: false,                                    

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › execaNode (file://index.js:251:9)
  › inspectMacro (file://test/node.js:13:22)



  node › node removes --inspect=9222 from nodeOptions when defined by parent process

  test/node.js:13

   12:   try {                                                 
   13:     const subprocess = execaNode('console.log("foo")', {
   14:       reject: false,                                    

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › execaNode (file://index.js:251:9)
  › inspectMacro (file://test/node.js:13:22)



  node › node removes --inspect-brk from nodeOptions when defined by parent process

  test/node.js:13

   12:   try {                                                 
   13:     const subprocess = execaNode('console.log("foo")', {
   14:       reject: false,                                    

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › execaNode (file://index.js:251:9)
  › inspectMacro (file://test/node.js:13:22)



  node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process

  test/node.js:13

   12:   try {                                                 
   13:     const subprocess = execaNode('console.log("foo")', {
   14:       reject: false,                                    

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › execaNode (file://index.js:251:9)
  › inspectMacro (file://test/node.js:13:22)



  node › node should not remove --inspect when passed through nodeOptions

  test/node.js:85

   84:   async t => {                                                      
   85:     const {stdout, stderr} = await execaNode('console.log("foo")', {
   86:       reject: false,                                                

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:85:34



  kill › `forceKillAfterTimeout` should not be NaN

  test/kill.js:66

   65:   test('`forceKillAfterTimeout` should not be NaN', t => {               
   66:     t.throws(() => {                                                     
   67:       execa('noop.js').kill('SIGTERM', {forceKillAfterTimeout: Number.Na…

  Function threw unexpected exception:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  Expected message to match:

  /non-negative integer/

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › t.throws.instanceOf (file://test/kill.js:67:4)
  › file://test/kill.js:66:5



  kill › `forceKillAfterTimeout` should not be negative

  test/kill.js:72

   71:   test('`forceKillAfterTimeout` should not be negative', t => {     
   72:     t.throws(() => {                                                
   73:       execa('noop.js').kill('SIGTERM', {forceKillAfterTimeout: -1});

  Function threw unexpected exception:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  Expected message to match:

  /non-negative integer/

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › t.throws.instanceOf (file://test/kill.js:73:4)
  › file://test/kill.js:72:5



  kill › execa() returns a promise with kill()

  test/kill.js:79

   78: test('execa() returns a promise with kill()', t => {
   79:   const {kill} = execa('noop.js', ['foo']);         
   80:   t.is(typeof kill, 'function');                    

  Error thrown in test:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:79:17



  kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode

  test/kill.js:127

   126: test('timedOut is false if timeout is undefined and exit code is 0 in s…
   127:   const {timedOut} = execaSync('noop.js');                              
   128:   t.false(timedOut);                                                    

  Error thrown in test:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execaSync (file://index.js:165:17)
  › file://test/kill.js:127:21



  kill › cancel method kills the subprocess

  test/kill.js:195

   194: test('cancel method kills the subprocess', t => {
   195:   const subprocess = execa('node');              
   196:   subprocess.cancel();                           

  Error thrown in test:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:195:21



  kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success)

  test/kill.js:211

   210: test('result.isCanceled is false when spawned.cancel() isn\'t called in…
   211:   const {isCanceled} = execaSync('noop.js');                            
   212:   t.false(isCanceled);                                                  

  Error thrown in test:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execaSync (file://index.js:165:17)
  › file://test/kill.js:211:23



  kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure)

  test/kill.js:219

   218:   });                 
   219:   t.false(isCanceled);
   220: });                   

  Value is not `false`:

  undefined

  › file://test/kill.js:219:9



  node › node()

  test/node.js:27

   26: test('node()', async t => {                                   
   27:   const {exitCode} = await execaNode('test/fixtures/noop.js');
   28:   t.is(exitCode, 0);                                          

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:27:27



  node › node pipe stdout

  test/node.js:32

   31: test('node pipe stdout', async t => {                                 
   32:   const {stdout} = await execaNode('test/fixtures/noop.js', ['foo'], {
   33:     stdout: 'pipe',                                                   

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:32:25



  node › node correctly use nodePath

  test/node.js:40

   39: test('node correctly use nodePath', async t => {                         
   40:   const {stdout} = await execaNode(process.platform === 'win32' ? 'hello…
   41:     stdout: 'pipe',                                                      

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:40:25



  node › node pass on nodeOptions

  test/node.js:50

   49: test('node pass on nodeOptions', async t => {             
   50:   const {stdout} = await execaNode('console.log("foo")', {
   51:     stdout: 'pipe',                                       

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:50:25



  node › node's forked script has a communication channel

  test/node.js:96

   95: test('node\'s forked script has a communication channel', async t => {
   96:   const subprocess = execaNode('test/fixtures/send.js');              
   97:   await pEvent(subprocess, 'message');                                

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › execaNode (file://index.js:251:9)
  › file://test/node.js:96:21



  kill › kill("SIGKILL") should terminate cleanly

  test/kill.js:13

   12: test('kill("SIGKILL") should terminate cleanly', async t => {            
   13:   const subprocess = execa('node', ['./test/fixtures/no-killable.js'], {…
   14:   await pEvent(subprocess, 'message');                                   

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:13:21



  kill › `forceKillAfterTimeout: false` should not kill after a timeout

  test/kill.js:26

   25:   test('`forceKillAfterTimeout: false` should not kill after a timeout',…
   26:     const subprocess = execa('node', ['./test/fixtures/no-killable.js'],…
   27:     await pEvent(subprocess, 'message');                                 

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:26:22



  kill › `forceKillAfterTimeout: number` should kill after a timeout

  test/kill.js:36

   35:   test('`forceKillAfterTimeout: number` should kill after a timeout', as…
   36:     const subprocess = execa('node', ['./test/fixtures/no-killable.js'],…
   37:     await pEvent(subprocess, 'message');                                 

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:36:22



  kill › `forceKillAfterTimeout: true` should kill after a timeout

  test/kill.js:46

   45:   test('`forceKillAfterTimeout: true` should kill after a timeout', asyn…
   46:     const subprocess = execa('node', ['./test/fixtures/no-killable.js'],…
   47:     await pEvent(subprocess, 'message');                                 

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:46:22



  kill › kill() with no arguments should kill after a timeout

  test/kill.js:56

   55:   test('kill() with no arguments should kill after a timeout', async t =…
   56:     const subprocess = execa('node', ['./test/fixtures/no-killable.js'],…
   57:     await pEvent(subprocess, 'message');                                 

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:56:22



  kill › timeout kills the process if it times out

  test/kill.js:84

   83: test('timeout kills the process if it times out', async t => {           
   84:   const {killed, timedOut} = await t.throwsAsync(execa('noop.js', {timeo…
   85:   t.false(killed);                                                       

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:84:49



  kill › timeout does not kill the process if it does not time out

  test/kill.js:98

   97: test('timeout does not kill the process if it does not time out', async …
   98:   const {timedOut} = await execa('delay.js', ['500'], {timeout: 1e8});   
   99:   t.false(timedOut);                                                     

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:98:27



  kill › timedOut is false if timeout is undefined

  test/kill.js:117

   116: test('timedOut is false if timeout is undefined', async t => {
   117:   const {timedOut} = await execa('noop.js');                  
   118:   t.false(timedOut);                                          

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:117:27



  kill › timedOut is false if timeout is 0

  test/kill.js:122

   121: test('timedOut is false if timeout is 0', async t => {    
   122:   const {timedOut} = await execa('noop.js', {timeout: 0});
   123:   t.false(timedOut);                                      

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:122:27



  kill › spawnAndExit

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › spawnAndExit (file://test/kill.js:133:25)



  kill › spawnAndExit cleanup

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › spawnAndExit (file://test/kill.js:133:25)



  kill › spawnAndExit detached

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › spawnAndExit (file://test/kill.js:133:25)



  kill › spawnAndExit cleanup detached

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › spawnAndExit (file://test/kill.js:133:25)



  kill › spawnAndKill SIGTERM

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill SIGKILL

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill cleanup SIGTERM

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill cleanup SIGKILL

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill detached SIGTERM

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill detached SIGKILL

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill cleanup detached SIGTERM

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › spawnAndKill cleanup detached SIGKILL

  test/kill.js:143

   142: const spawnAndKill = async (t, [signal, cleanup, detached, isKilled]) =…
   143:   const subprocess = execa('sub-process.js', [cleanup, detached], {stdi…
   144:                                                                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › spawnAndKill (file://test/kill.js:143:21)



  kill › removes exit handler on exit

  test/kill.js:182

   181:                                                    
   182:   const subprocess = execa('noop.js');             
   183:   const listener = emitter.listeners('exit').pop();

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:182:21



  kill › result.isCanceled is false when spawned.cancel() isn't called (success)

  test/kill.js:201

   200: test('result.isCanceled is false when spawned.cancel() isn\'t called (s…
   201:   const {isCanceled} = await execa('noop.js');                          
   202:   t.false(isCanceled);                                                  

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:201:29



  kill › result.isCanceled is false when spawned.cancel() isn't called (failure)

  test/kill.js:206

   205: test('result.isCanceled is false when spawned.cancel() isn\'t called (f…
   206:   const {isCanceled} = await t.throwsAsync(execa('fail.js'));           
   207:   t.false(isCanceled);                                                  

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:206:43



  kill › calling cancel method throws an error with message "Command was canceled"

  test/kill.js:223

   222: test('calling cancel method throws an error with message "Command was c…
   223:   const subprocess = execa('noop.js');                                  
   224:   subprocess.cancel();                                                  

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:223:21



  kill › error.isCanceled is true when cancel method is used

  test/kill.js:229

   228: test('error.isCanceled is true when cancel method is used', async t => {
   229:   const subprocess = execa('noop.js');                                  
   230:   subprocess.cancel();                                                  

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:229:21



  kill › error.isCanceled is false when kill method is used

  test/kill.js:236

   235: test('error.isCanceled is false when kill method is used', async t => {
   236:   const subprocess = execa('noop.js');                                 
   237:   subprocess.kill();                                                   

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:236:21



  kill › calling cancel method twice should show the same behaviour as calling it once

  test/kill.js:243

   242: test('calling cancel method twice should show the same behaviour as cal…
   243:   const subprocess = execa('noop.js');                                  
   244:   subprocess.cancel();                                                  

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:243:21



  kill › calling cancel method on a successfully completed process does not make result.isCanceled true

  test/kill.js:252

   251: test('calling cancel method on a successfully completed process does no…
   252:   const subprocess = execa('noop.js');                                  
   253:   const {isCanceled} = await subprocess;                                

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:252:21



  kill › calling cancel method on a process which has been killed does not make error.isCanceled true

  test/kill.js:259

   258: test('calling cancel method on a process which has been killed does not…
   259:   const subprocess = execa('noop.js');                                  
   260:   subprocess.kill();                                                    

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:259:21



  kill › calling abort throws an error with message "Command was canceled"

  test/kill.js:268

   267:     const abortController = new AbortController();                      
   268:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   269:     abortController.abort();                                            

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:268:22



  kill › calling abort twice should show the same behaviour as calling it once

  test/kill.js:275

   274:     const abortController = new AbortController();                      
   275:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   276:     abortController.abort();                                            

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:275:22



  kill › calling abort on a successfully completed process does not make result.isCanceled true

  test/kill.js:285

   284:     const abortController = new AbortController();                      
   285:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   286:     const {isCanceled} = await subprocess;                              

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:285:22



  kill › calling cancel after abort should show the same behaviour as only calling cancel

  test/kill.js:293

   292:     const abortController = new AbortController();                      
   293:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   294:     abortController.abort();                                            

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:293:22



  kill › calling abort after cancel should show the same behaviour as only calling cancel

  test/kill.js:303

   302:     const abortController = new AbortController();                      
   303:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   304:     subprocess.cancel();                                                

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/kill.js:303:22



  kill › timeout kills the process if it times out, in sync mode

  test/kill.js:93

   92:   });              
   93:   t.false(killed); 
   94:   t.true(timedOut);

  Value is not `false`:

  undefined

  › file://test/kill.js:93:9



  kill › timeout must not be negative

  test/kill.js:105

   104: test('timeout must not be negative', async t => {
   105:   await t.throws(() => {                         
   106:     execa('noop.js', {timeout: -1});             

  Function threw unexpected exception:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  Expected message to match:

  /`timeout` option to be a non-negative integer/

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › t.throws.message (file://test/kill.js:106:3)
  › file://test/kill.js:105:10



  kill › timeout must be an integer

  test/kill.js:111

   110: test('timeout must be an integer', async t => {
   111:   await t.throws(() => {                       
   112:     execa('noop.js', {timeout: false});        

  Function threw unexpected exception:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  Expected message to match:

  /`timeout` option to be a non-negative integer/

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › t.throws.message (file://test/kill.js:112:3)
  › file://test/kill.js:111:10



  promise › promise methods are not enumerable

  test/promise.js:8

   7: test('promise methods are not enumerable', t => {                        
   8:   const descriptors = Object.getOwnPropertyDescriptors(execa('noop.js'));
   9:   t.false(descriptors.then.enumerable);                                  

  Error thrown in test:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/promise.js:8:55



  promise › finally function is executed on success

  test/promise.js:16

   15:   let isCalled = false;                                           
   16:   const {stdout} = await execa('noop.js', ['foo']).finally(() => {
   17:     isCalled = true;                                              

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/promise.js:16:25



  promise › finally function is executed on failure

  test/promise.js:25

   24:   let isError = false;                                                   
   25:   const {stdout, stderr} = await t.throwsAsync(execa('exit.js', ['2']).f…
   26:     isError = true;                                                      

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/promise.js:25:47



  promise › throw in finally function bubbles up on success

  test/promise.js:34

   33: test('throw in finally function bubbles up on success', async t => {     
   34:   const {message} = await t.throwsAsync(execa('noop.js', ['foo']).finall…
   35:     throw new Error('called');                                           

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/promise.js:34:40



  promise › throw in finally bubbles up on error

  test/promise.js:41

   40: test('throw in finally bubbles up on error', async t => {                
   41:   const {message} = await t.throwsAsync(execa('exit.js', ['2']).finally(…
   42:     throw new Error('called');                                           

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/promise.js:41:40



  override-promise › should work with third-party Promise

  test/override-promise.js:12

   11: test('should work with third-party Promise', async t => {
   12:   const {stdout} = await execa('noop.js', ['foo']);      
   13:   t.is(stdout, 'foo');                                   

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/override-promise.js:12:25



  stream › result.all shows both `stdout` and `stderr` intermixed

  test/stream.js:32

   31: test.serial('result.all shows both `stdout` and `stderr` intermixed', as…
   32:   const {all} = await execa('noop-132.js', {all: true});                 
   33:   t.is(all, '132');                                                      

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:32:22



  stream › buffer: false > promise does not resolve when output is big and is not read

  test/stream.js:189

   188:   test.serial('buffer: false > promise does not resolve when output is …
   189:     const {timedOut} = await t.throwsAsync(execa('max-buffer.js', {buff…
   190:     t.true(timedOut);                                                   

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:189:42



  stream › buffer: false > promise does not resolve when output is big and "all" is used but not read

  test/stream.js:194

   193:   test.serial('buffer: false > promise does not resolve when output is …
   194:     const subprocess = execa('max-buffer.js', {buffer: false, all: true…
   195:     subprocess.stdout.resume();                                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:194:22



  stream › stdout/stderr/all are undefined if ignored in sync mode

  test/stream.js:49

   48: test('stdout/stderr/all are undefined if ignored in sync mode', t => {   
   49:   const {stdout, stderr, all} = execaSync('noop.js', {stdio: 'ignore', a…
   50:   t.is(stdout, undefined);                                               

  Error thrown in test:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execaSync (file://index.js:165:17)
  › file://test/stream.js:49:32



  stream › input option can be a String - sync

  test/stream.js:81

   80: test('input option can be a String - sync', t => {          
   81:   const {stdout} = execaSync('stdin.js', {input: 'foobar'});
   82:   t.is(stdout, 'foobar');                                   

  Error thrown in test:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execaSync (file://index.js:165:17)
  › file://test/stream.js:81:19



  stream › input option can be a Buffer - sync

  test/stream.js:86

   85: test('input option can be a Buffer - sync', t => {                       
   86:   const {stdout} = execaSync('stdin.js', {input: Buffer.from('testing12'…
   87:   t.is(stdout, 'testing12');                                             

  Error thrown in test:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execaSync (file://index.js:165:17)
  › file://test/stream.js:86:19



  stream › helpful error trying to provide an input stream in sync mode

  test/stream.js:99

   98: test('helpful error trying to provide an input stream in sync mode', t =…
   99:   t.throws(                                                              
   100:     () => {                                                              

  Function threw unexpected exception:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  Expected message to match:

  /The `input` option cannot be a stream in sync mode/

  › handleArguments (file://index.js:29:28)
  › execaSync (file://index.js:165:17)
  › t.throws.message (file://test/stream.js:101:4)
  › file://test/stream.js:99:4



  stream › buffer

  test/stream.js:14

   13: test('buffer', async t => {                                          
   14:   const {stdout} = await execa('noop.js', ['foo'], {encoding: null});
   15:   t.true(Buffer.isBuffer(stdout));                                   

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:14:25



  stream › pass `stdout` to a file descriptor

  test/stream.js:21

   20:   const file = tempfile('.txt');                                         
   21:   await execa('test/fixtures/noop.js', ['foo bar'], {stdout: fs.openSync…
   22:   t.is(fs.readFileSync(file, 'utf8'), 'foo bar\n');                      

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:21:8



  stream › pass `stderr` to a file descriptor

  test/stream.js:27

   26:   const file = tempfile('.txt');                                         
   27:   await execa('test/fixtures/noop-err.js', ['foo bar'], {stderr: fs.open…
   28:   t.is(fs.readFileSync(file, 'utf8'), 'foo bar\n');                      

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:27:8



  stream › result.all is undefined unless opts.all is true

  test/stream.js:37

   36: test('result.all is undefined unless opts.all is true', async t => {
   37:   const {all} = await execa('noop.js');                             
   38:   t.is(all, undefined);                                             

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:37:22



  stream › stdout/stderr/all are undefined if ignored

  test/stream.js:42

   41: test('stdout/stderr/all are undefined if ignored', async t => {          
   42:   const {stdout, stderr, all} = await execa('noop.js', {stdio: 'ignore',…
   43:   t.is(stdout, undefined);                                               

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:42:38



  stream › input option can be a String

  test/stream.js:56

   55: test('input option can be a String', async t => {             
   56:   const {stdout} = await execa('stdin.js', {input: 'foobar'});
   57:   t.is(stdout, 'foobar');                                     

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:56:25



  stream › input option can be a Buffer

  test/stream.js:61

   60: test('input option can be a Buffer', async t => {                
   61:   const {stdout} = await execa('stdin.js', {input: 'testing12'});
   62:   t.is(stdout, 'testing12');                                     

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:61:25



  stream › input can be a Stream

  test/stream.js:69

   68:   stream.end();                                             
   69:   const {stdout} = await execa('stdin.js', {input: stream});
   70:   t.is(stdout, 'howdy');                                    

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:69:25



  stream › you can write to child.stdin

  test/stream.js:74

   73: test('you can write to child.stdin', async t => {
   74:   const subprocess = execa('stdin.js');          
   75:   subprocess.stdin.end('unicorns');              

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:74:21



  stream › opts.stdout:ignore - stdout will not collect data

  test/stream.js:91

   90: test('opts.stdout:ignore - stdout will not collect data', async t => {
   91:   const {stdout} = await execa('stdin.js', {                          
   92:     input: 'hello',                                                   

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:91:25



  stream › maxBuffer affects stdout

  test/stream.js:108

   107: test('maxBuffer affects stdout', async t => {                           
   108:   await t.notThrowsAsync(execa('max-buffer.js', ['stdout', '10'], {maxB…
   109:   const {stdout, all} = await t.throwsAsync(execa('max-buffer.js', ['st…

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:108:25



  stream › maxBuffer affects stderr

  test/stream.js:115

   114: test('maxBuffer affects stderr', async t => {                           
   115:   await t.notThrowsAsync(execa('max-buffer.js', ['stderr', '10'], {maxB…
   116:   const {stderr, all} = await t.throwsAsync(execa('max-buffer.js', ['st…

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:115:25



  stream › do not buffer stdout when `buffer` set to `false`

  test/stream.js:122

   121: test('do not buffer stdout when `buffer` set to `false`', async t => {  
   122:   const promise = execa('max-buffer.js', ['stdout', '10'], {buffer: fal…
   123:   const [result, stdout] = await Promise.all([                          

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:122:18



  stream › do not buffer stderr when `buffer` set to `false`

  test/stream.js:133

   132: test('do not buffer stderr when `buffer` set to `false`', async t => {  
   133:   const promise = execa('max-buffer.js', ['stderr', '10'], {buffer: fal…
   134:   const [result, stderr] = await Promise.all([                          

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:133:18



  stream › do not buffer when streaming

  test/stream.js:144

   143: test('do not buffer when streaming', async t => {                       
   144:   const {stdout} = execa('max-buffer.js', ['stdout', '21'], {maxBuffer:…
   145:   const result = await getStream(stdout);                               

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:144:19



  stream › buffer: false > promise resolves

  test/stream.js:150

   149: test('buffer: false > promise resolves', async t => {       
   150:   await t.notThrowsAsync(execa('noop.js', {buffer: false}));
   151: });                                                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:150:25



  stream › buffer: false > promise resolves when output is big but is not pipable

  test/stream.js:154

   153: test('buffer: false > promise resolves when output is big but is not pi…
   154:   await t.notThrowsAsync(execa('max-buffer.js', {buffer: false, stdout:…
   155: });                                                                     

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:154:25



  stream › buffer: false > promise resolves when output is big and is read

  test/stream.js:158

   157: test('buffer: false > promise resolves when output is big and is read',…
   158:   const subprocess = execa('max-buffer.js', {buffer: false});           
   159:   subprocess.stdout.resume();                                           

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:158:21



  stream › buffer: false > promise resolves when output is big and "all" is used and is read

  test/stream.js:165

   164: test('buffer: false > promise resolves when output is big and "all" is …
   165:   const subprocess = execa('max-buffer.js', {buffer: false, all: true});
   166:   subprocess.all.resume();                                              

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:165:21



  stream › buffer: false > promise rejects when process returns non-zero

  test/stream.js:171

   170: test('buffer: false > promise rejects when process returns non-zero', a…
   171:   const subprocess = execa('fail.js', {buffer: false});                 
   172:   const {exitCode} = await t.throwsAsync(subprocess);                   

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:171:21



  stream › can use all: true with stdout: ignore

  test/stream.js:177

   176: test('can use all: true with stdout: ignore', async t => {              
   177:   await t.notThrowsAsync(execa('max-buffer.js', {buffer: false, stdout:…
   178: });                                                                     

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:177:25



  stream › can use all: true with stderr: ignore

  test/stream.js:181

   180: test('can use all: true with stderr: ignore', async t => {              
   181:   await t.notThrowsAsync(execa('max-buffer.js', ['stderr'], {buffer: fa…
   182: });                                                                     

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/stream.js:181:25



  test › execaSync()

  test/test.js:33

   32: test('execaSync()', t => {                       
   33:   const {stdout} = execaSync('noop.js', ['foo']);
   34:   t.is(stdout, 'foo');                           

  Error thrown in test:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execaSync (file://index.js:165:17)
  › file://test/test.js:33:19



  test › execaSync() throws error if written to stderr

  test/test.js:38

   37: test('execaSync() throws error if written to stderr', t => {
   38:   t.throws(() => {                                          
   39:     execaSync('foo');                                       

  Function threw unexpected exception:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  Expected message to match:

  /spawn.* ENOENT/

  › handleArguments (file://index.js:29:28)
  › execaSync (file://index.js:165:17)
  › t.throws.message (file://test/test.js:39:3)
  › file://test/test.js:38:4



  test › skip throwing when using reject option in sync mode

  test/test.js:49

   48: test('skip throwing when using reject option in sync mode', t => {
   49:   const {exitCode} = execaSync('fail.js', {reject: false});       
   50:   t.is(exitCode, 2);                                              

  Error thrown in test:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execaSync (file://index.js:165:17)
  › file://test/test.js:49:21



  test › stripFinalNewline in sync mode

  test/test.js:69

   68: test('stripFinalNewline in sync mode', t => {                            
   69:   const {stdout} = execaSync('noop.js', ['foo'], {stripFinalNewline: tru…
   70:   t.is(stdout, 'foo');                                                   

  Error thrown in test:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execaSync (file://index.js:165:17)
  › file://test/test.js:69:19



  test › stripFinalNewline in sync mode on failure

  test/test.js:77

   76:   });                 
   77:   t.is(stderr, 'foo');
   78: });                   

  Difference:

  - undefined
  + 'foo'

  › file://test/test.js:77:4



  test › execa() returns a promise with pid

  test/test.js:131

   130: test('execa() returns a promise with pid', t => {
   131:   const {pid} = execa('noop.js', ['foo']);       
   132:   t.is(typeof pid, 'number');                    

  Error thrown in test:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:131:16



  test › child_process.spawn() propagated errors have correct shape

  test/test.js:136

   135: test('child_process.spawn() propagated errors have correct shape', t =>…
   136:   const subprocess = execa('noop.js', {uid: -1});                       
   137:   t.notThrows(() => {                                                   

  Error thrown in test:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:136:21



  test › child_process.spawnSync() errors are propagated with a correct shape

  test/test.js:153

   152:   });            
   153:   t.true(failed);
   154: });              

  Value is not `true`:

  undefined

  › file://test/test.js:153:8



  test › execa()

  test/test.js:16

   15: test('execa()', async t => {                       
   16:   const {stdout} = await execa('noop.js', ['foo']);
   17:   t.is(stdout, 'foo');                             

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:16:25



  test › skip throwing when using reject option

  test/test.js:44

   43: test('skip throwing when using reject option', async t => {  
   44:   const {exitCode} = await execa('fail.js', {reject: false});
   45:   t.is(exitCode, 2);                                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:44:27



  test › stripFinalNewline: true

  test/test.js:54

   53: test('stripFinalNewline: true', async t => {       
   54:   const {stdout} = await execa('noop.js', ['foo']);
   55:   t.is(stdout, 'foo');                             

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:54:25



  test › stripFinalNewline: false

  test/test.js:59

   58: test('stripFinalNewline: false', async t => {                            
   59:   const {stdout} = await execa('noop.js', ['foo'], {stripFinalNewline: f…
   60:   t.is(stdout, 'foo\n');                                                 

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:59:25



  test › stripFinalNewline on failure

  test/test.js:64

   63: test('stripFinalNewline on failure', async t => {                        
   64:   const {stderr} = await t.throwsAsync(execa('noop-throw.js', ['foo'], {…
   65:   t.is(stderr, 'foo');                                                   

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:64:39



  test › preferLocal: true

  test/test.js:88

   87: test('preferLocal: true', async t => {                                   
   88:   await t.notThrowsAsync(execa('ava', ['--version'], {preferLocal: true,…
   89: });                                                                      

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:88:25



  test › preferLocal: false

  test/test.js:92

   91: test('preferLocal: false', async t => {                                  
   92:   await t.throwsAsync(execa('ava', ['--version'], {preferLocal: false, e…
   93: });                                                                      

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:92:22



  test › preferLocal: undefined

  test/test.js:96

   95: test('preferLocal: undefined', async t => {                              
   96:   await t.throwsAsync(execa('ava', ['--version'], {env: getPathWithoutLo…
   97: });                                                                      

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:96:22



  test › localDir option

  test/test.js:101

   100:   const command = process.platform === 'win32' ? 'echo %PATH%' : 'echo …
   101:   const {stdout} = await execa(command, {shell: true, preferLocal: true…
   102:   const envPaths = stdout.split(path.delimiter);                        

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:101:25



  test › stdin errors are handled

  test/test.js:113

   112: test('stdin errors are handled', async t => {       
   113:   const subprocess = execa('noop.js');              
   114:   subprocess.stdin.emit('error', new Error('test'));

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:113:21



  test › child process errors are handled

  test/test.js:119

   118: test('child process errors are handled', async t => {
   119:   const subprocess = execa('noop.js');               
   120:   subprocess.emit('error', new Error('test'));       

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:119:21



  test › child process errors rejects promise right away

  test/test.js:125

   124: test('child process errors rejects promise right away', async t => {
   125:   const subprocess = execa('noop.js');                              
   126:   subprocess.emit('error', new Error('test'));                      

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:125:21



  test › child_process.spawn() errors are propagated

  test/test.js:145

   144: test('child_process.spawn() errors are propagated', async t => {    
   145:   const {failed} = await t.throwsAsync(execa('noop.js', {uid: -1}));
   146:   t.true(failed);                                                   

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:145:39



  test › do not try to consume streams twice

  test/test.js:157

   156: test('do not try to consume streams twice', async t => {
   157:   const subprocess = execa('noop.js', ['foo']);         
   158:   const {stdout} = await subprocess;                    

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:157:21



  test › use relative path with '..' chars

  test/test.js:166

   165:   const pathViaParentDir = path.join('..', path.basename(fileURLToPath(…
   166:   const {stdout} = await execa(pathViaParentDir, ['foo']);              
   167:   t.is(stdout, 'foo');                                                  

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:166:25



  test › execa() rejects if running non-executable

  test/test.js:172

   171:   test('execa() rejects if running non-executable', async t => {
   172:     const subprocess = execa('non-executable.js');              
   173:     await t.throwsAsync(subprocess);                            

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:172:22



  test › execa() rejects with correct error and doesn't throw if running non-executable with input

  test/test.js:177

   176:   test('execa() rejects with correct error and doesn\'t throw if runnin…
   177:     await t.throwsAsync(execa('non-executable.js', {input: 'Hey!'}), {m…
   178:   });                                                                   

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:177:23



  test › write to fast-exit process

  test/test.js:189

   188:     } catch (error) {           
   189:       t.is(error.code, 'EPIPE');
   190:     }                           

  Difference:

  - undefined
  + 'EPIPE'

  › file://test/test.js:189:6



  test › use environment variables by default

  test/test.js:195

   194: test('use environment variables by default', async t => {
   195:   const {stdout} = await execa('environment.js');        
   196:   t.deepEqual(stdout.split('\n'), ['foo', 'undefined']); 

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:195:25



  test › extend environment variables by default

  test/test.js:200

   199: test('extend environment variables by default', async t => {            
   200:   const {stdout} = await execa('environment.js', [], {env: {BAR: 'bar',…
   201:   t.deepEqual(stdout.split('\n'), ['foo', 'bar']);                      

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:200:25



  test › do not extend environment with `extendEnv: false`

  test/test.js:205

   204: test('do not extend environment with `extendEnv: false`', async t => {  
   205:   const {stdout} = await execa('environment.js', [], {env: {BAR: 'bar',…
   206:   t.deepEqual(stdout.split('\n'), ['undefined', 'bar']);                

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:205:25



  test › can use `options.cwd` as a string

  test/test.js:211

   210:   const cwd = '/';                                                     
   211:   const {stdout} = await execa('node', ['-p', 'process.cwd()'], {cwd});
   212:   t.is(path.toNamespacedPath(stdout), path.toNamespacedPath(cwd));     

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:211:25



  test › localDir option can be a URL

  test/test.js:217

   216:   const command = process.platform === 'win32' ? 'echo %PATH%' : 'echo …
   217:   const {stdout} = await execa(command, {shell: true, preferLocal: true…
   218:   const envPaths = stdout.split(path.delimiter);                        

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:217:25



  test › can use `options.cwd` as a URL

  test/test.js:225

   224:   const cwdUrl = pathToFileURL(cwd);                                    
   225:   const {stdout} = await execa('node', ['-p', 'process.cwd()'], {cwd: c…
   226:   t.is(path.toNamespacedPath(stdout), path.toNamespacedPath(cwd));      

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:225:25



  test › can use `options.shell: true`

  test/test.js:230

   229: test('can use `options.shell: true`', async t => {                      
   230:   const {stdout} = await execa('node test/fixtures/noop.js foo', {shell…
   231:   t.is(stdout, 'foo');                                                  

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:230:25



  test › can use `options.shell: string`

  test/test.js:236

   235:   const shell = process.platform === 'win32' ? 'cmd.exe' : '/bin/bash'; 
   236:   const {stdout} = await execa('node test/fixtures/noop.js foo', {shell…
   237:   t.is(stdout, 'foo');                                                  

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:236:25



  test › use extend environment with `extendEnv: true` and `shell: true`

  test/test.js:243

   242:   const command = process.platform === 'win32' ? 'echo %TEST%' : 'echo …
   243:   const {stdout} = await execa(command, {shell: true, env: {}, extendEn…
   244:   t.is(stdout, 'test');                                                 

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:243:25



  test › detach child process

  test/test.js:249

   248: test('detach child process', async t => {   
   249:   const {stdout} = await execa('detach.js');
   250:   const pid = Number(stdout);               

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:249:25



  test › execPath option

  test/test.js:108

   107:   const {path: execPath} = await getNode('6.0.0');                      
   108:   const {stdout} = await execa('node', ['-p', 'process.env.Path || proc…
   109:   t.true(stdout.includes('6.0.0'));                                     

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'crossSpawn._parse is not a function',
  }

  › handleArguments (file://index.js:29:28)
  › execa (file://index.js:76:17)
  › file://test/test.js:108:25

  ─

  173 tests failed
-------------|---------|----------|---------|---------|---------------------------------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                           
-------------|---------|----------|---------|---------|---------------------------------------------
All files    |   42.34 |    87.93 |   27.02 |   42.34 |                                             
 execa       |   44.94 |       65 |   66.66 |   44.94 |                                             
  index.js   |   44.94 |       65 |   66.66 |   44.94 | 19-25,55-59,63-72,86-161,175-191,193-224    
 execa/lib   |    40.6 |      100 |   14.28 |    40.6 |                                             
  command.js |    75.6 |      100 |      20 |    75.6 | 2-6,13-17                                   
  error.js   |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                  
  kill.js    |   36.27 |      100 |       0 |   36.27 | ...-29,38-46,51-55,59-60,65-80,84-86,91-101 
  promise.js |   36.11 |      100 |       0 |   36.11 | 9-18,23-35                                  
  stdio.js   |     100 |      100 |     100 |     100 |                                             
  stream.js  |   29.06 |      100 |       0 |   29.06 | 7-15,20-34,39-49,53-61,66-79,83-85          
-------------|---------|----------|---------|---------|---------------------------------------------
./VariantsPureDep/execa/variant12/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (683ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.6s)
  ✔ error › result.killed is false if not killed, in sync mode (780ms)
  ✔ error › result.killed is false on process error, in sync mode (225ms)
  ✔ error › Original error.message is kept (1.2s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (323ms)
  ✔ error › stdout/stderr/all on process errors (1.8s)
  ✔ error › stdout/stderr/all available on errors (1.9s)
  ✔ error › exitCode is 0 on success (1.8s)
  ✔ error › exitCode is 2 (1.8s)
  ✔ error › exitCode is 3 (1.7s)
  ✔ error › exitCode is 4 (1.7s)
  ✔ error › error.message contains the command (1.7s)
  ✔ error › error.message contains stdout/stderr if available (1.6s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.6s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.5s)
  ✔ error › failed is false on success (1.4s)
  ✔ error › failed is true on failure (1.3s)
  ✔ error › error.killed is true if process was killed directly (1.2s)
  ✔ error › error.killed is false if process was killed indirectly (1.1s)
  ✔ error › result.killed is false if not killed (1s)
  ✔ error › error.signal is SIGINT (425ms)
  ✔ error › error.signalDescription is defined (418ms)
  ✔ error › error.signal is SIGTERM (412ms)
  ✔ error › exitCode is undefined on signal termination (404ms)
  ✔ error › custom error.signal (425ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (376ms)
  ✔ error › result.signal is undefined for successful execution (408ms)
  ✔ error › result.signalDescription is undefined for successful execution (448ms)
  ✔ error › error.code is undefined on success (406ms)
  ✔ command › allow commands with spaces and no array arguments (2.3s)
  ✔ command › allow commands with spaces and array arguments (2.2s)
  ✔ command › execaCommand() (2.1s)
  ✔ command › execaCommand() ignores consecutive spaces (2.1s)
  ✔ command › execaCommand() allows escaping spaces in commands (2s)
  ✔ command › execaCommand() allows escaping spaces in arguments (1.9s)
  ✔ command › execaCommand() escapes other whitespaces (1.8s)
  ✔ command › execaCommand() trims (1.7s)
  ✔ command › command is: " foo bar" (2.5s)
  ✔ command › command is: " baz quz" (2.5s)
  ✔ command › command is: "" (2.5s)
  ✔ command › escapedCommand is: "foo bar" (2.7s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.8s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (2.8s)
  ✔ command › escapedCommand is: "\"*\"" (3s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (2.9s)
  ✔ kill › execa() returns a promise with kill() (2.9s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.7s)
  ✔ kill › cancel method kills the subprocess (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (918ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (2.9s)
  ✔ kill › timeout must not be negative (2.8s)
  ✔ kill › timeout must be an integer (2.8s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (117ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (157ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (173ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.2s)
  ✔ kill › timeout does not kill the process if it does not time out (2.9s)
  ✔ kill › timedOut is false if timeout is undefined (2.9s)
  ✔ kill › timedOut is false if timeout is 0 (2.9s)
  ✔ kill › spawnAndExit (2.6s)
  ✔ kill › spawnAndExit cleanup (2.6s)
  ✔ kill › spawnAndExit detached (2.6s)
  ✔ kill › spawnAndExit cleanup detached (2.5s)
  ✔ kill › spawnAndKill SIGTERM (2.5s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.4s)
  ✔ kill › removes exit handler on exit (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.2s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (337ms)
  ✔ kill › error.isCanceled is true when cancel method is used (328ms)
  ✔ kill › error.isCanceled is false when kill method is used (309ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (288ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (280ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (274ms)
  ✔ kill › spawnAndKill SIGKILL (2.5s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.5s)
  ✔ kill › spawnAndKill detached SIGTERM (2.5s)
  ✔ kill › spawnAndKill detached SIGKILL (2.5s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.4s)
  ✔ kill › timeout kills the process if it times out (3.1s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.3s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (254ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.3s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.5s)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath (128ms)
  ✔ node › node() (182ms)
  ✔ node › node pass on nodeOptions (190ms)
  ✔ node › node pipe stdout (267ms)
  ✔ node › node's forked script has a communication channel (165ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › throw in finally function bubbles up on success (181ms)
  ✔ promise › finally function is executed on failure (228ms)
  ✔ promise › finally function is executed on success (244ms)
  ✔ promise › throw in finally bubbles up on error (206ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.2s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.8s)
  ✔ stream › input option can be a String - sync (1.3s)
  ✔ stream › input option can be a Buffer - sync (1s)
  ✔ stream › helpful error trying to provide an input stream in sync mode (825ms)
  ✔ stream › buffer (2.1s)
  ✔ stream › pass `stdout` to a file descriptor (2.1s)
  ✔ stream › pass `stderr` to a file descriptor (2.1s)
  ✔ stream › result.all is undefined unless opts.all is true (2.1s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.1s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (1.1s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (1.1s)
  ✔ stream › do not buffer when streaming (1.1s)
  ✔ stream › input option can be a String (2s)
  ✔ stream › input option can be a Buffer (2s)
  ✔ stream › input can be a Stream (1.9s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (1.4s)
  ✔ stream › you can write to child.stdin (1.9s)
  ✔ stream › buffer: false > promise resolves (1.1s)
  ✔ test › execaSync() (2.5s)
  ✔ test › execaSync() throws error if written to stderr (2.4s)
  ✔ test › skip throwing when using reject option in sync mode (2.4s)
  ✔ test › stripFinalNewline in sync mode (2s)
  ✔ test › stripFinalNewline in sync mode on failure (1.7s)
  ✔ test › execa() returns a promise with pid (1.3s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1.3s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (1.2s)
  ✔ test › child_process.spawn() errors are propagated (1.4s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (1.2s)
  ✔ test › execa() rejects if running non-executable (1.3s)
  ✔ test › preferLocal: undefined (1.8s)
  ✔ test › preferLocal: false (1.8s)
  ✔ test › child process errors rejects promise right away (1.7s)
  ✔ test › child process errors are handled (1.8s)
  ✔ test › stdin errors are handled (1.8s)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1.3s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.3s)
  ✔ test › execa() (3.1s)
  ✔ test › skip throwing when using reject option (3s)
  ✔ test › stripFinalNewline: true (2.6s)
  ✔ test › stripFinalNewline: false (2.6s)
  ✔ test › stripFinalNewline on failure (2.6s)
  ✔ test › localDir option (2s)
  ✔ test › do not try to consume streams twice (1.7s)
  ✔ test › use relative path with '..' chars (1.6s)
  ✔ test › write to fast-exit process (1.5s)
  ✔ test › use environment variables by default (1.4s)
  ✔ test › extend environment variables by default (1.4s)
  ✔ test › can use `options.cwd` as a string (1.3s)
  ✔ test › localDir option can be a URL (1.1s)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (762ms)
  ✔ stream › maxBuffer affects stdout (1.8s)
  ✔ test › do not extend environment with `extendEnv: false` (1.3s)
  ✔ test › can use `options.cwd` as a URL (1.1s)
  ✔ stream › can use all: true with stdout: ignore (1.2s)
  ✔ stream › can use all: true with stderr: ignore (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.4s)
  ✔ stream › maxBuffer affects stderr (1.9s)
  ✔ test › can use `options.shell: true` (1s)
  ✔ test › can use `options.shell: string` (992ms)
  ✔ test › execPath option (2.3s)
  ✔ test › detach child process (1s)
  ✔ test › preferLocal: true (2.7s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsPureDep/execa/variant11/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/command.js

  SyntaxError: The requested module 'strip-final-newline' does not provide an export named 'default'

  Uncaught exception in test/error.js

  SyntaxError: The requested module 'strip-final-newline' does not provide an export named 'default'

  ✖ test/command.js exited with a non-zero exit code: 1
  ✖ test/error.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  SyntaxError: The requested module 'strip-final-newline' does not provide an export named 'default'

  Uncaught exception in test/node.js

  SyntaxError: The requested module 'strip-final-newline' does not provide an export named 'default'

  ✖ test/kill.js exited with a non-zero exit code: 1
  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/promise.js

  SyntaxError: The requested module 'strip-final-newline' does not provide an export named 'default'

  Uncaught exception in test/override-promise.js

  SyntaxError: The requested module 'strip-final-newline' does not provide an export named 'default'

  ✖ test/promise.js exited with a non-zero exit code: 1
  ✖ test/override-promise.js exited with a non-zero exit code: 1

  Uncaught exception in test/stream.js

  SyntaxError: The requested module 'strip-final-newline' does not provide an export named 'default'

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  SyntaxError: The requested module 'strip-final-newline' does not provide an export named 'default'

  ✖ test/test.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ─

  36 tests passed
  8 uncaught exceptions
------------|---------|----------|---------|---------|----------------------------------------------
File        | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                            
------------|---------|----------|---------|---------|----------------------------------------------
All files   |   36.84 |      100 |   10.71 |   36.84 |                                              
 command.js |    43.9 |      100 |       0 |    43.9 | 2-6,13-17,28-40                              
 error.js   |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                   
 kill.js    |   36.27 |      100 |       0 |   36.27 | ...4-29,38-46,51-55,59-60,65-80,84-86,91-101 
 promise.js |   30.55 |      100 |       0 |   30.55 | 3-4,9-18,23-35                               
 stdio.js   |     100 |      100 |     100 |     100 |                                              
 stream.js  |   29.06 |      100 |       0 |   29.06 | 7-15,20-34,39-49,53-61,66-79,83-85           
------------|---------|----------|---------|---------|----------------------------------------------
./VariantsPureDep/execa/variant10/execa

> execa@6.1.0 test
> xo && c8 ava && tsd

----------|---------|----------|---------|---------|-------------------
File      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
----------|---------|----------|---------|---------|-------------------
All files |       0 |        0 |       0 |       0 |                   
----------|---------|----------|---------|---------|-------------------
./VariantsPureDep/execa/variant9/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/error.js

  SyntaxError: The requested module 'onetime' does not provide an export named 'default'

  Uncaught exception in test/command.js

  SyntaxError: The requested module 'onetime' does not provide an export named 'default'

  ✖ test/error.js exited with a non-zero exit code: 1
  ✖ test/command.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  SyntaxError: The requested module 'onetime' does not provide an export named 'default'

  Uncaught exception in test/node.js

  SyntaxError: The requested module 'onetime' does not provide an export named 'default'

  ✖ test/kill.js exited with a non-zero exit code: 1
  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  SyntaxError: The requested module 'onetime' does not provide an export named 'default'

  Uncaught exception in test/promise.js

  SyntaxError: The requested module 'onetime' does not provide an export named 'default'

  ✖ test/override-promise.js exited with a non-zero exit code: 1
  ✖ test/promise.js exited with a non-zero exit code: 1

  Uncaught exception in test/stream.js

  SyntaxError: The requested module 'onetime' does not provide an export named 'default'

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  SyntaxError: The requested module 'onetime' does not provide an export named 'default'

  ✖ test/test.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ─

  36 tests passed
  8 uncaught exceptions
------------|---------|----------|---------|---------|----------------------------------------------
File        | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                            
------------|---------|----------|---------|---------|----------------------------------------------
All files   |   36.84 |      100 |   10.71 |   36.84 |                                              
 command.js |    43.9 |      100 |       0 |    43.9 | 2-6,13-17,28-40                              
 error.js   |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                   
 kill.js    |   36.27 |      100 |       0 |   36.27 | ...4-29,38-46,51-55,59-60,65-80,84-86,91-101 
 promise.js |   30.55 |      100 |       0 |   30.55 | 3-4,9-18,23-35                               
 stdio.js   |     100 |      100 |     100 |     100 |                                              
 stream.js  |   29.06 |      100 |       0 |   29.06 | 7-15,20-34,39-49,53-61,66-79,83-85           
------------|---------|----------|---------|---------|----------------------------------------------
./VariantsPureDep/execa/variant8/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (808ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.8s)
  ✔ error › result.killed is false if not killed, in sync mode (909ms)
  ✔ error › result.killed is false on process error, in sync mode (190ms)
  ✔ error › Original error.message is kept (1.3s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (278ms)
  ✔ error › stdout/stderr/all on process errors (1.9s)
  ✔ error › stdout/stderr/all available on errors (2s)
  ✔ error › exitCode is 0 on success (1.9s)
  ✔ error › exitCode is 2 (1.9s)
  ✔ error › exitCode is 3 (1.9s)
  ✔ error › exitCode is 4 (1.8s)
  ✔ error › error.message contains the command (1.7s)
  ✔ error › error.message contains stdout/stderr if available (1.7s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.6s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.5s)
  ✔ error › failed is false on success (1.5s)
  ✔ error › failed is true on failure (1.3s)
  ✔ error › error.killed is true if process was killed directly (1.3s)
  ✔ error › error.killed is false if process was killed indirectly (1.2s)
  ✔ error › result.killed is false if not killed (1.1s)
  ✔ error › error.signal is SIGINT (382ms)
  ✔ error › error.signalDescription is defined (373ms)
  ✔ error › error.signal is SIGTERM (366ms)
  ✔ error › exitCode is undefined on signal termination (345ms)
  ✔ error › custom error.signal (374ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (411ms)
  ✔ error › result.signal is undefined for successful execution (481ms)
  ✔ error › result.signalDescription is undefined for successful execution (483ms)
  ✔ error › error.code is undefined on success (482ms)
  ✔ command › allow commands with spaces and no array arguments (2.3s)
  ✔ command › allow commands with spaces and array arguments (2.3s)
  ✔ command › execaCommand() (2.2s)
  ✔ command › execaCommand() ignores consecutive spaces (2.1s)
  ✔ command › execaCommand() allows escaping spaces in commands (2s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2s)
  ✔ command › execaCommand() escapes other whitespaces (1.9s)
  ✔ command › execaCommand() trims (1.8s)
  ✔ command › command is: " foo bar" (2.7s)
  ✔ command › command is: " baz quz" (2.6s)
  ✔ command › command is: "" (2.6s)
  ✔ command › escapedCommand is: "foo bar" (2.7s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.8s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (2.9s)
  ✔ command › escapedCommand is: "\"*\"" (3s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.1s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3s)
  ✔ kill › execa() returns a promise with kill() (3s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.8s)
  ✔ kill › cancel method kills the subprocess (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (902ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (3s)
  ✔ kill › timeout must not be negative (2.9s)
  ✔ kill › timeout must be an integer (2.9s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel
  ✔ kill › calling abort twice should show the same behaviour as calling it once (151ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (184ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.2s)
  ✔ kill › timeout does not kill the process if it does not time out (3s)
  ✔ kill › timedOut is false if timeout is undefined (3s)
  ✔ kill › timedOut is false if timeout is 0 (2.9s)
  ✔ kill › spawnAndExit (2.6s)
  ✔ kill › spawnAndExit cleanup (2.6s)
  ✔ kill › spawnAndExit detached (2.6s)
  ✔ kill › spawnAndExit cleanup detached (2.6s)
  ✔ kill › spawnAndKill SIGTERM (2.6s)
  ✔ kill › spawnAndKill SIGKILL (2.5s)
  ✔ kill › spawnAndKill detached SIGTERM (2.5s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.5s)
  ✔ kill › removes exit handler on exit (2.4s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.3s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (341ms)
  ✔ kill › error.isCanceled is true when cancel method is used (321ms)
  ✔ kill › error.isCanceled is false when kill method is used (310ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (291ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (271ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (259ms)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.5s)
  ✔ kill › spawnAndKill detached SIGKILL (2.5s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.4s)
  ✔ kill › timeout kills the process if it times out (3.1s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.3s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (212ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.2s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.6s)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (169ms)
  ✔ node › node pipe stdout (180ms)
  ✔ node › node pass on nodeOptions (173ms)
  ✔ node › node's forked script has a communication channel (163ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on failure (221ms)
  ✔ promise › finally function is executed on success (253ms)
  ✔ promise › throw in finally function bubbles up on success (229ms)
  ✔ promise › throw in finally bubbles up on error (211ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.2s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.6s)
  ✔ stream › input option can be a String - sync (1.1s)
  ✔ stream › input option can be a Buffer - sync (901ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (745ms)
  ✔ stream › buffer (1.9s)
  ✔ stream › pass `stdout` to a file descriptor (1.8s)
  ✔ stream › pass `stderr` to a file descriptor (1.8s)
  ✔ stream › result.all is undefined unless opts.all is true (1.8s)
  ✔ stream › stdout/stderr/all are undefined if ignored (1.8s)
  ✔ stream › buffer: false > promise resolves (1s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (1.2s)
  ✔ stream › do not buffer when streaming (1.1s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (1.2s)
  ✔ stream › input option can be a String (1.8s)
  ✔ stream › input option can be a Buffer (1.8s)
  ✔ stream › input can be a Stream (1.7s)
  ✔ stream › you can write to child.stdin (1.7s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (1.4s)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1.2s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (1s)
  ✔ test › execaSync() (2.7s)
  ✔ test › execaSync() throws error if written to stderr (2.6s)
  ✔ test › skip throwing when using reject option in sync mode (2.6s)
  ✔ test › stripFinalNewline in sync mode (2.2s)
  ✔ test › stripFinalNewline in sync mode on failure (1.7s)
  ✔ test › execa() returns a promise with pid (1.4s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1.3s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (1.2s)
  ✔ test › child_process.spawn() errors are propagated (1.3s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (1.1s)
  ✔ test › execa() rejects if running non-executable (1.2s)
  ✔ test › preferLocal: undefined (1.7s)
  ✔ test › preferLocal: false (1.8s)
  ✔ test › child process errors rejects promise right away (1.7s)
  ✔ test › child process errors are handled (1.7s)
  ✔ test › stdin errors are handled (1.8s)
  ✔ stream › maxBuffer affects stdout (1.8s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.6s)
  ✔ stream › can use all: true with stdout: ignore (1.3s)
  ✔ stream › can use all: true with stderr: ignore (1.2s)
  ✔ stream › maxBuffer affects stderr (1.9s)
  ✔ test › execa() (3.2s)
  ✔ test › skip throwing when using reject option (3s)
  ✔ test › stripFinalNewline: true (2.7s)
  ✔ test › stripFinalNewline: false (2.7s)
  ✔ test › stripFinalNewline on failure (2.6s)
  ✔ test › localDir option (1.9s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.6s)
  ✔ test › do not try to consume streams twice (1.6s)
  ✔ test › use relative path with '..' chars (1.5s)
  ✔ test › write to fast-exit process (1.3s)
  ✔ test › use environment variables by default (1.2s)
  ✔ test › extend environment variables by default (1.2s)
  ✔ test › can use `options.cwd` as a string (1s)
  ✔ test › localDir option can be a URL (971ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (631ms)
  ✔ test › do not extend environment with `extendEnv: false` (1.1s)
  ✔ test › can use `options.shell: true` (786ms)
  ✔ test › can use `options.cwd` as a URL (882ms)
  ✔ test › can use `options.shell: string` (797ms)
  ✔ test › execPath option (2.2s)
  ✔ test › detach child process (905ms)
  ✔ test › preferLocal: true (2.6s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsPureDep/execa/variant7/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/error.js

  SyntaxError: The requested module 'human-signals' does not provide an export named 'signalsByName'

  Uncaught exception in test/command.js

  SyntaxError: The requested module 'human-signals' does not provide an export named 'signalsByName'

  ✖ test/error.js exited with a non-zero exit code: 1
  ✖ test/command.js exited with a non-zero exit code: 1

  Uncaught exception in test/node.js

  SyntaxError: The requested module 'human-signals' does not provide an export named 'signalsByName'

  Uncaught exception in test/kill.js

  SyntaxError: The requested module 'human-signals' does not provide an export named 'signalsByName'

  ✖ test/node.js exited with a non-zero exit code: 1
  ✖ test/kill.js exited with a non-zero exit code: 1

  Uncaught exception in test/promise.js

  SyntaxError: The requested module 'human-signals' does not provide an export named 'signalsByName'

  Uncaught exception in test/override-promise.js

  SyntaxError: The requested module 'human-signals' does not provide an export named 'signalsByName'

  ✖ test/promise.js exited with a non-zero exit code: 1
  ✖ test/override-promise.js exited with a non-zero exit code: 1

  Uncaught exception in test/stream.js

  SyntaxError: The requested module 'human-signals' does not provide an export named 'signalsByName'

  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  SyntaxError: The requested module 'human-signals' does not provide an export named 'signalsByName'

  ✖ test/test.js exited with a non-zero exit code: 1
  ─

  36 tests passed
  8 uncaught exceptions
----------|---------|----------|---------|---------|-------------------
File      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
----------|---------|----------|---------|---------|-------------------
All files |     100 |      100 |     100 |     100 |                   
 stdio.js |     100 |      100 |     100 |     100 |                   
----------|---------|----------|---------|---------|-------------------
./VariantsPureDep/execa/variant6/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (753ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.6s)
  ✔ error › result.killed is false if not killed, in sync mode (909ms)
  ✔ error › result.killed is false on process error, in sync mode (195ms)
  ✔ error › Original error.message is kept (1.4s)
  ✔ error › error.code is defined on failure if applicable (108ms)
  ✔ error › result.killed is false on process error (315ms)
  ✔ error › stdout/stderr/all on process errors (1.8s)
  ✔ error › stdout/stderr/all available on errors (1.9s)
  ✔ error › exitCode is 0 on success (1.8s)
  ✔ error › exitCode is 2 (1.8s)
  ✔ error › exitCode is 3 (1.8s)
  ✔ error › exitCode is 4 (1.8s)
  ✔ error › error.message contains the command (1.7s)
  ✔ error › error.message contains stdout/stderr if available (1.7s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.6s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.6s)
  ✔ error › failed is false on success (1.5s)
  ✔ error › failed is true on failure (1.4s)
  ✔ error › error.killed is true if process was killed directly (1.3s)
  ✔ error › error.killed is false if process was killed indirectly (1.3s)
  ✔ error › result.killed is false if not killed (1.2s)
  ✔ error › error.signal is SIGINT (374ms)
  ✔ error › error.signalDescription is defined (368ms)
  ✔ error › error.signal is SIGTERM (365ms)
  ✔ error › exitCode is undefined on signal termination (341ms)
  ✔ error › custom error.signal (359ms)
  ✔ error › result.signal is undefined for successful execution (323ms)
  ✔ error › result.signalDescription is undefined for successful execution (358ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (408ms)
  ✔ error › error.code is undefined on success (389ms)
  ✔ command › allow commands with spaces and no array arguments (2.3s)
  ✔ command › allow commands with spaces and array arguments (2.3s)
  ✔ command › execaCommand() (2.2s)
  ✔ command › execaCommand() ignores consecutive spaces (2.1s)
  ✔ command › execaCommand() allows escaping spaces in commands (2s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2s)
  ✔ command › execaCommand() escapes other whitespaces (1.9s)
  ✔ command › execaCommand() trims (1.8s)
  ✔ command › command is: " foo bar" (2.6s)
  ✔ command › command is: " baz quz" (2.5s)
  ✔ command › command is: "" (2.5s)
  ✔ command › escapedCommand is: "foo bar" (2.6s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.7s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (2.8s)
  ✔ command › escapedCommand is: "\"*\"" (2.9s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3s)
  ✔ kill › execa() returns a promise with kill() (3s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.8s)
  ✔ kill › cancel method kills the subprocess (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (1.9s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (790ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (3s)
  ✔ kill › timeout must not be negative (2.9s)
  ✔ kill › timeout must be an integer (2.9s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (103ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (133ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (169ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.2s)
  ✔ kill › timeout does not kill the process if it does not time out (3s)
  ✔ kill › timedOut is false if timeout is undefined (3s)
  ✔ kill › timedOut is false if timeout is 0 (2.9s)
  ✔ kill › spawnAndExit (2.6s)
  ✔ kill › spawnAndExit cleanup (2.6s)
  ✔ kill › spawnAndExit detached (2.6s)
  ✔ kill › spawnAndExit cleanup detached (2.6s)
  ✔ kill › spawnAndKill SIGTERM (2.5s)
  ✔ kill › spawnAndKill SIGKILL (2.5s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.4s)
  ✔ kill › removes exit handler on exit (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.1s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (356ms)
  ✔ kill › error.isCanceled is true when cancel method is used (309ms)
  ✔ kill › error.isCanceled is false when kill method is used (298ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (287ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (248ms)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.5s)
  ✔ kill › spawnAndKill detached SIGTERM (2.5s)
  ✔ kill › spawnAndKill detached SIGKILL (2.4s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.4s)
  ✔ kill › timeout kills the process if it times out (3.1s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.3s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (273ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.2s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.5s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (253ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (169ms)
  ✔ node › node pipe stdout (183ms)
  ✔ node › node pass on nodeOptions (167ms)
  ✔ node › node's forked script has a communication channel (160ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on success (225ms)
  ✔ promise › finally function is executed on failure (215ms)
  ✔ promise › throw in finally function bubbles up on success (207ms)
  ✔ promise › throw in finally bubbles up on error (194ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.2s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.2s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.7s)
  ✔ stream › input option can be a String - sync (1.2s)
  ✔ stream › input option can be a Buffer - sync (935ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (735ms)
  ✔ stream › buffer (1.9s)
  ✔ stream › pass `stdout` to a file descriptor (2s)
  ✔ stream › pass `stderr` to a file descriptor (2s)
  ✔ stream › result.all is undefined unless opts.all is true (2s)
  ✔ stream › stdout/stderr/all are undefined if ignored (1.9s)
  ✔ stream › input option can be a String (1.7s)
  ✔ stream › you can write to child.stdin (1.6s)
  ✔ stream › input option can be a Buffer (1.7s)
  ✔ stream › input can be a Stream (1.6s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (1.1s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (1s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (1s)
  ✔ stream › do not buffer when streaming (1.1s)
  ✔ stream › buffer: false > promise resolves (1s)
  ✔ test › execaSync() (2.6s)
  ✔ test › execaSync() throws error if written to stderr (2.5s)
  ✔ test › skip throwing when using reject option in sync mode (2.4s)
  ✔ test › stripFinalNewline in sync mode (2.1s)
  ✔ test › stripFinalNewline in sync mode on failure (1.7s)
  ✔ test › execa() returns a promise with pid (1.4s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1.4s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (1.3s)
  ✔ test › child_process.spawn() errors are propagated (1.4s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (1.2s)
  ✔ test › execa() rejects if running non-executable (1.3s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (1.1s)
  ✔ test › preferLocal: undefined (1.7s)
  ✔ test › preferLocal: false (1.7s)
  ✔ test › child process errors rejects promise right away (1.7s)
  ✔ test › child process errors are handled (1.7s)
  ✔ test › stdin errors are handled (1.7s)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1.4s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.3s)
  ✔ stream › can use all: true with stdout: ignore (1.2s)
  ✔ test › execa() (3s)
  ✔ test › skip throwing when using reject option (2.9s)
  ✔ test › stripFinalNewline: true (2.5s)
  ✔ test › stripFinalNewline: false (2.5s)
  ✔ test › stripFinalNewline on failure (2.5s)
  ✔ test › localDir option (1.9s)
  ✔ test › do not try to consume streams twice (1.6s)
  ✔ test › use relative path with '..' chars (1.6s)
  ✔ test › write to fast-exit process (1.4s)
  ✔ stream › maxBuffer affects stdout (1.8s)
  ✔ test › use environment variables by default (1.4s)
  ✔ test › extend environment variables by default (1.3s)
  ✔ test › can use `options.cwd` as a string (1.1s)
  ✔ test › localDir option can be a URL (1s)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (611ms)
  ✔ test › do not extend environment with `extendEnv: false` (1.2s)
  ✔ test › can use `options.cwd` as a URL (987ms)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.4s)
  ✔ stream › maxBuffer affects stderr (1.8s)
  ✔ test › can use `options.shell: string` (760ms)
  ✔ stream › can use all: true with stderr: ignore (1.3s)
  ✔ test › can use `options.shell: true` (961ms)
  ✔ test › execPath option (2.1s)
  ✔ test › detach child process (860ms)
  ✔ test › preferLocal: true (2.5s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsPureDep/execa/variant5/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/error.js

  SyntaxError: The requested module 'path-key' does not provide an export named 'default'

  Uncaught exception in test/command.js

  SyntaxError: The requested module 'path-key' does not provide an export named 'default'

  ✖ test/error.js exited with a non-zero exit code: 1
  ✖ test/command.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  SyntaxError: The requested module 'path-key' does not provide an export named 'default'

  Uncaught exception in test/node.js

  SyntaxError: The requested module 'path-key' does not provide an export named 'default'

  ✖ test/kill.js exited with a non-zero exit code: 1
  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  SyntaxError: The requested module 'path-key' does not provide an export named 'default'

  Uncaught exception in test/promise.js

  SyntaxError: The requested module 'path-key' does not provide an export named 'default'

  ✖ test/override-promise.js exited with a non-zero exit code: 1
  ✖ test/promise.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }

  Uncaught exception in test/stream.js

  SyntaxError: The requested module 'path-key' does not provide an export named 'default'

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  SyntaxError: The requested module 'path-key' does not provide an export named 'default'

  ✖ test/test.js exited with a non-zero exit code: 1
  ─

  36 tests passed
  8 uncaught exceptions
----------|---------|----------|---------|---------|-------------------
File      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
----------|---------|----------|---------|---------|-------------------
All files |     100 |      100 |     100 |     100 |                   
 stdio.js |     100 |      100 |     100 |     100 |                   
----------|---------|----------|---------|---------|-------------------
./VariantsPureDep/execa/variant4/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/command.js

  SyntaxError: The requested module 'npm-run-path' does not provide an export named 'npmRunPathEnv'

  Uncaught exception in test/error.js

  SyntaxError: The requested module 'npm-run-path' does not provide an export named 'npmRunPathEnv'

  ✖ test/command.js exited with a non-zero exit code: 1
  ✖ test/error.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  SyntaxError: The requested module 'npm-run-path' does not provide an export named 'npmRunPathEnv'

  ✖ test/kill.js exited with a non-zero exit code: 1

  Uncaught exception in test/node.js

  SyntaxError: The requested module 'npm-run-path' does not provide an export named 'npmRunPathEnv'

  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  SyntaxError: The requested module 'npm-run-path' does not provide an export named 'npmRunPathEnv'

  ✖ test/override-promise.js exited with a non-zero exit code: 1

  Uncaught exception in test/promise.js

  SyntaxError: The requested module 'npm-run-path' does not provide an export named 'npmRunPathEnv'

  ✖ test/promise.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }

  Uncaught exception in test/stream.js

  SyntaxError: The requested module 'npm-run-path' does not provide an export named 'npmRunPathEnv'

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  SyntaxError: The requested module 'npm-run-path' does not provide an export named 'npmRunPathEnv'

  ✖ test/test.js exited with a non-zero exit code: 1
  ─

  36 tests passed
  8 uncaught exceptions
------------|---------|----------|---------|---------|----------------------------------------------
File        | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                            
------------|---------|----------|---------|---------|----------------------------------------------
All files   |   36.84 |      100 |   10.71 |   36.84 |                                              
 command.js |    43.9 |      100 |       0 |    43.9 | 2-6,13-17,28-40                              
 error.js   |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                   
 kill.js    |   36.27 |      100 |       0 |   36.27 | ...4-29,38-46,51-55,59-60,65-80,84-86,91-101 
 promise.js |   30.55 |      100 |       0 |   30.55 | 3-4,9-18,23-35                               
 stdio.js   |     100 |      100 |     100 |     100 |                                              
 stream.js  |   29.06 |      100 |       0 |   29.06 | 7-15,20-34,39-49,53-61,66-79,83-85           
------------|---------|----------|---------|---------|----------------------------------------------
./VariantsPureDep/execa/variant3/execa

> execa@6.1.0 test
> xo && c8 ava && tsd

./VariantsPureDep/execa/variant2/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/error.js

  SyntaxError: The requested module 'is-stream' does not provide an export named 'isStream'

  Uncaught exception in test/command.js

  SyntaxError: The requested module 'is-stream' does not provide an export named 'isStream'

  ✖ test/error.js exited with a non-zero exit code: 1
  ✖ test/command.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  SyntaxError: The requested module 'is-stream' does not provide an export named 'isStream'

  Uncaught exception in test/stream.js

  SyntaxError: The requested module 'is-stream' does not provide an export named 'isStream'

  ✖ test/kill.js exited with a non-zero exit code: 1
  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/node.js

  SyntaxError: The requested module 'is-stream' does not provide an export named 'isStream'

  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  SyntaxError: The requested module 'is-stream' does not provide an export named 'isStream'

  ✖ test/test.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  SyntaxError: The requested module 'is-stream' does not provide an export named 'isStream'

  ✖ test/override-promise.js exited with a non-zero exit code: 1

  Uncaught exception in test/promise.js

  SyntaxError: The requested module 'is-stream' does not provide an export named 'isStream'

  ✖ test/promise.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ─

  36 tests passed
  8 uncaught exceptions
----------|---------|----------|---------|---------|------------------------------------------------
File      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                              
----------|---------|----------|---------|---------|------------------------------------------------
All files |    39.4 |      100 |      20 |    39.4 |                                                
 error.js |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                     
 kill.js  |   36.27 |      100 |       0 |   36.27 | ...,14-29,38-46,51-55,59-60,65-80,84-86,91-101 
 stdio.js |     100 |      100 |     100 |     100 |                                                
----------|---------|----------|---------|---------|------------------------------------------------
./VariantsPureDep/execa/variant1/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (867ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.8s)
  ✔ error › result.killed is false if not killed, in sync mode (950ms)
  ✔ error › result.killed is false on process error, in sync mode (281ms)
  ✔ error › Original error.message is kept (1.4s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (371ms)
  ✔ error › stdout/stderr/all on process errors (1.9s)
  ✔ error › stdout/stderr/all available on errors (2s)
  ✔ error › exitCode is 0 on success (1.9s)
  ✔ error › exitCode is 2 (1.9s)
  ✔ error › exitCode is 3 (1.8s)
  ✔ error › exitCode is 4 (1.8s)
  ✔ error › error.message contains the command (1.8s)
  ✔ error › error.message contains stdout/stderr if available (1.7s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.7s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.6s)
  ✔ error › failed is false on success (1.5s)
  ✔ error › failed is true on failure (1.4s)
  ✔ error › error.killed is true if process was killed directly (1.3s)
  ✔ error › error.killed is false if process was killed indirectly (1.2s)
  ✔ error › result.killed is false if not killed (1.1s)
  ✔ error › error.signal is SIGINT (414ms)
  ✔ error › error.signalDescription is defined (404ms)
  ✔ error › error.signal is SIGTERM (383ms)
  ✔ error › exitCode is undefined on signal termination (337ms)
  ✔ error › custom error.signal (368ms)
  ✔ error › error.code is undefined on success (306ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (436ms)
  ✔ error › result.signal is undefined for successful execution (478ms)
  ✔ error › result.signalDescription is undefined for successful execution (440ms)
  ✔ command › allow commands with spaces and no array arguments (2.4s)
  ✔ command › allow commands with spaces and array arguments (2.4s)
  ✔ command › execaCommand() (2.3s)
  ✔ command › execaCommand() ignores consecutive spaces (2.3s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.2s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.1s)
  ✔ command › execaCommand() escapes other whitespaces (2s)
  ✔ command › execaCommand() trims (1.9s)
  ✔ command › command is: " foo bar" (2.6s)
  ✔ command › command is: " baz quz" (2.5s)
  ✔ command › command is: "" (2.5s)
  ✔ command › escapedCommand is: "foo bar" (2.7s)
  ✔ command › escapedCommand is: "\"foo bar\"" (2.8s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (2.9s)
  ✔ command › escapedCommand is: "\"*\"" (3s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3s)
  ✔ kill › execa() returns a promise with kill() (3s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.8s)
  ✔ kill › cancel method kills the subprocess (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (1s)
  ✔ kill › timeout kills the process if it times out, in sync mode (2.9s)
  ✔ kill › timeout must not be negative (2.8s)
  ✔ kill › timeout must be an integer (2.8s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (129ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (183ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (193ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.2s)
  ✔ kill › timeout does not kill the process if it does not time out (3s)
  ✔ kill › timedOut is false if timeout is undefined (2.9s)
  ✔ kill › timedOut is false if timeout is 0 (2.9s)
  ✔ kill › spawnAndExit (2.6s)
  ✔ kill › spawnAndExit cleanup (2.6s)
  ✔ kill › spawnAndExit detached (2.6s)
  ✔ kill › spawnAndExit cleanup detached (2.6s)
  ✔ kill › spawnAndKill SIGTERM (2.5s)
  ✔ kill › spawnAndKill SIGKILL (2.5s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.5s)
  ✔ kill › spawnAndKill detached SIGTERM (2.5s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.4s)
  ✔ kill › removes exit handler on exit (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.2s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (369ms)
  ✔ kill › error.isCanceled is true when cancel method is used (326ms)
  ✔ kill › error.isCanceled is false when kill method is used (305ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (291ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (284ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (278ms)
  ✔ kill › spawnAndKill detached SIGKILL (2.5s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.4s)
  ✔ kill › timeout kills the process if it times out (3.1s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.3s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (237ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.3s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.5s)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (206ms)
  ✔ node › node pipe stdout (196ms)
  ✔ node › node's forked script has a communication channel (195ms)
  ✔ node › node pass on nodeOptions (218ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on success (216ms)
  ✔ promise › finally function is executed on failure (219ms)
  ✔ promise › throw in finally function bubbles up on success (221ms)
  ✔ promise › throw in finally bubbles up on error (212ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.2s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.4s)
  ✔ stream › input option can be a String - sync (945ms)
  ✔ stream › input option can be a Buffer - sync (703ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (499ms)
  ✔ stream › buffer (1.6s)
  ✔ stream › pass `stdout` to a file descriptor (1.6s)
  ✔ stream › pass `stderr` to a file descriptor (1.6s)
  ✔ stream › result.all is undefined unless opts.all is true (1.6s)
  ✔ stream › stdout/stderr/all are undefined if ignored (1.5s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (784ms)
  ✔ stream › input option can be a String (1.4s)
  ✔ stream › input option can be a Buffer (1.4s)
  ✔ stream › you can write to child.stdin (1.3s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (1s)
  ✔ stream › input can be a Stream (1.5s)
  ✔ stream › buffer: false > promise resolves (891ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (997ms)
  ✔ stream › do not buffer when streaming (972ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (999ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1.2s)
  ✔ stream › can use all: true with stdout: ignore (1.2s)
  ✔ stream › can use all: true with stderr: ignore (1.1s)
  ✔ stream › maxBuffer affects stdout (1.6s)
  ✔ stream › maxBuffer affects stderr (1.6s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.4s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.4s)
  ✔ test › execaSync() (2.8s)
  ✔ test › execaSync() throws error if written to stderr (2.7s)
  ✔ test › skip throwing when using reject option in sync mode (2.6s)
  ✔ test › stripFinalNewline in sync mode (2.2s)
  ✔ test › stripFinalNewline in sync mode on failure (1.8s)
  ✔ test › execa() returns a promise with pid (1.4s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1.4s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (1.2s)
  ✔ test › child_process.spawn() errors are propagated (1.4s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (1s)
  ✔ test › execa() rejects if running non-executable (1.1s)
  ✔ test › preferLocal: undefined (1.8s)
  ✔ test › preferLocal: false (1.8s)
  ✔ test › child process errors rejects promise right away (1.6s)
  ✔ test › child process errors are handled (1.7s)
  ✔ test › stdin errors are handled (1.7s)
  ✔ test › execa() (3.1s)
  ✔ test › skip throwing when using reject option (3s)
  ✔ test › stripFinalNewline: true (2.6s)
  ✔ test › stripFinalNewline: false (2.6s)
  ✔ test › stripFinalNewline on failure (2.6s)
  ✔ test › localDir option (1.9s)
  ✔ test › do not try to consume streams twice (1.5s)
  ✔ test › use relative path with '..' chars (1.4s)
  ✔ test › write to fast-exit process (1s)
  ✔ test › use environment variables by default (978ms)
  ✔ test › extend environment variables by default (889ms)
  ✔ test › localDir option can be a URL (704ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (479ms)
  ✔ test › can use `options.cwd` as a string (773ms)
  ✔ test › can use `options.shell: true` (603ms)
  ✔ test › do not extend environment with `extendEnv: false` (839ms)
  ✔ test › can use `options.cwd` as a URL (667ms)
  ✔ test › can use `options.shell: string` (604ms)
  ✔ test › execPath option (1.9s)
  ✔ test › detach child process (594ms)
  ✔ test › preferLocal: true (2.4s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------

10
./VariantsSubtree/execa/variant10/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/command.js

  SyntaxError: The requested module 'is-stream' does not provide an export named 'isStream'

  Uncaught exception in test/error.js

  SyntaxError: The requested module 'is-stream' does not provide an export named 'isStream'

  ✖ test/command.js exited with a non-zero exit code: 1
  ✖ test/error.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  SyntaxError: The requested module 'is-stream' does not provide an export named 'isStream'

  ✖ test/kill.js exited with a non-zero exit code: 1

  Uncaught exception in test/stream.js

  SyntaxError: The requested module 'is-stream' does not provide an export named 'isStream'

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/node.js

  SyntaxError: The requested module 'is-stream' does not provide an export named 'isStream'

  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  SyntaxError: The requested module 'is-stream' does not provide an export named 'isStream'

  ✖ test/test.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  SyntaxError: The requested module 'is-stream' does not provide an export named 'isStream'

  Uncaught exception in test/promise.js

  SyntaxError: The requested module 'is-stream' does not provide an export named 'isStream'

  ✖ test/override-promise.js exited with a non-zero exit code: 1
  ✖ test/promise.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ─

  36 tests passed
  8 uncaught exceptions
----------|---------|----------|---------|---------|------------------------------------------------
File      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                              
----------|---------|----------|---------|---------|------------------------------------------------
All files |    39.4 |      100 |      20 |    39.4 |                                                
 error.js |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                     
 kill.js  |   36.27 |      100 |       0 |   36.27 | ...,14-29,38-46,51-55,59-60,65-80,84-86,91-101 
 stdio.js |     100 |      100 |     100 |     100 |                                                
----------|---------|----------|---------|---------|------------------------------------------------
./VariantsSubtree/execa/variant9/execa

> execa@6.1.0 test
> xo && c8 ava && tsd

./VariantsSubtree/execa/variant8/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/command.js

  SyntaxError: The requested module 'human-signals' does not provide an export named 'signalsByName'

  Uncaught exception in test/error.js

  SyntaxError: The requested module 'human-signals' does not provide an export named 'signalsByName'

  ✖ test/command.js exited with a non-zero exit code: 1
  ✖ test/error.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  SyntaxError: The requested module 'human-signals' does not provide an export named 'signalsByName'

  ✖ test/kill.js exited with a non-zero exit code: 1

  Uncaught exception in test/node.js

  SyntaxError: The requested module 'human-signals' does not provide an export named 'signalsByName'

  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  SyntaxError: The requested module 'human-signals' does not provide an export named 'signalsByName'

  Uncaught exception in test/promise.js

  SyntaxError: The requested module 'human-signals' does not provide an export named 'signalsByName'

  ✖ test/override-promise.js exited with a non-zero exit code: 1
  ✖ test/promise.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }

  Uncaught exception in test/stream.js

  SyntaxError: The requested module 'human-signals' does not provide an export named 'signalsByName'

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  SyntaxError: The requested module 'human-signals' does not provide an export named 'signalsByName'

  ✖ test/test.js exited with a non-zero exit code: 1
  ─

  36 tests passed
  8 uncaught exceptions
----------|---------|----------|---------|---------|-------------------
File      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
----------|---------|----------|---------|---------|-------------------
All files |     100 |      100 |     100 |     100 |                   
 stdio.js |     100 |      100 |     100 |     100 |                   
----------|---------|----------|---------|---------|-------------------
./VariantsSubtree/execa/variant7/execa

> execa@6.1.0 test
> xo && c8 ava && tsd

----------|---------|----------|---------|---------|-------------------
File      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
----------|---------|----------|---------|---------|-------------------
All files |       0 |        0 |       0 |       0 |                   
----------|---------|----------|---------|---------|-------------------
./VariantsSubtree/execa/variant6/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/command.js

  SyntaxError: The requested module 'npm-run-path' does not provide an export named 'npmRunPathEnv'

  Uncaught exception in test/error.js

  SyntaxError: The requested module 'npm-run-path' does not provide an export named 'npmRunPathEnv'

  ✖ test/error.js exited with a non-zero exit code: 1
  ✖ test/command.js exited with a non-zero exit code: 1

  Uncaught exception in test/node.js

  SyntaxError: The requested module 'npm-run-path' does not provide an export named 'npmRunPathEnv'

  Uncaught exception in test/kill.js

  SyntaxError: The requested module 'npm-run-path' does not provide an export named 'npmRunPathEnv'

  ✖ test/node.js exited with a non-zero exit code: 1
  ✖ test/kill.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  SyntaxError: The requested module 'npm-run-path' does not provide an export named 'npmRunPathEnv'

  Uncaught exception in test/promise.js

  SyntaxError: The requested module 'npm-run-path' does not provide an export named 'npmRunPathEnv'

  ✖ test/override-promise.js exited with a non-zero exit code: 1
  ✖ test/promise.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }

  Uncaught exception in test/stream.js

  SyntaxError: The requested module 'npm-run-path' does not provide an export named 'npmRunPathEnv'

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  SyntaxError: The requested module 'npm-run-path' does not provide an export named 'npmRunPathEnv'

  ✖ test/test.js exited with a non-zero exit code: 1
  ─

  36 tests passed
  8 uncaught exceptions
------------|---------|----------|---------|---------|----------------------------------------------
File        | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                            
------------|---------|----------|---------|---------|----------------------------------------------
All files   |   36.84 |      100 |   10.71 |   36.84 |                                              
 command.js |    43.9 |      100 |       0 |    43.9 | 2-6,13-17,28-40                              
 error.js   |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                   
 kill.js    |   36.27 |      100 |       0 |   36.27 | ...4-29,38-46,51-55,59-60,65-80,84-86,91-101 
 promise.js |   30.55 |      100 |       0 |   30.55 | 3-4,9-18,23-35                               
 stdio.js   |     100 |      100 |     100 |     100 |                                              
 stream.js  |   29.06 |      100 |       0 |   29.06 | 7-15,20-34,39-49,53-61,66-79,83-85           
------------|---------|----------|---------|---------|----------------------------------------------
./VariantsSubtree/execa/variant5/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/command.js

  SyntaxError: The requested module 'strip-final-newline' does not provide an export named 'default'

  Uncaught exception in test/error.js

  SyntaxError: The requested module 'strip-final-newline' does not provide an export named 'default'

  ✖ test/command.js exited with a non-zero exit code: 1
  ✖ test/error.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  SyntaxError: The requested module 'strip-final-newline' does not provide an export named 'default'

  ✖ test/kill.js exited with a non-zero exit code: 1

  Uncaught exception in test/node.js

  SyntaxError: The requested module 'strip-final-newline' does not provide an export named 'default'

  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  SyntaxError: The requested module 'strip-final-newline' does not provide an export named 'default'

  Uncaught exception in test/promise.js

  SyntaxError: The requested module 'strip-final-newline' does not provide an export named 'default'

  ✖ test/override-promise.js exited with a non-zero exit code: 1
  ✖ test/promise.js exited with a non-zero exit code: 1

  Uncaught exception in test/stream.js

  SyntaxError: The requested module 'strip-final-newline' does not provide an export named 'default'

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  SyntaxError: The requested module 'strip-final-newline' does not provide an export named 'default'

  ✖ test/test.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ─

  36 tests passed
  8 uncaught exceptions
------------|---------|----------|---------|---------|----------------------------------------------
File        | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                            
------------|---------|----------|---------|---------|----------------------------------------------
All files   |   36.84 |      100 |   10.71 |   36.84 |                                              
 command.js |    43.9 |      100 |       0 |    43.9 | 2-6,13-17,28-40                              
 error.js   |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                   
 kill.js    |   36.27 |      100 |       0 |   36.27 | ...4-29,38-46,51-55,59-60,65-80,84-86,91-101 
 promise.js |   30.55 |      100 |       0 |   30.55 | 3-4,9-18,23-35                               
 stdio.js   |     100 |      100 |     100 |     100 |                                              
 stream.js  |   29.06 |      100 |       0 |   29.06 | 7-15,20-34,39-49,53-61,66-79,83-85           
------------|---------|----------|---------|---------|----------------------------------------------
./VariantsSubtree/execa/variant4/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (1s)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.9s)
  ✔ error › result.killed is false if not killed, in sync mode (919ms)
  ✔ error › result.killed is false on process error, in sync mode (305ms)
  ✔ error › Original error.message is kept (1.2s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (422ms)
  ✔ error › stdout/stderr/all on process errors (2.1s)
  ✔ error › stdout/stderr/all available on errors (2.3s)
  ✔ error › exitCode is 0 on success (2s)
  ✔ error › exitCode is 2 (1.8s)
  ✔ error › exitCode is 3 (1.8s)
  ✔ error › exitCode is 4 (1.7s)
  ✔ error › error.message contains the command (1.6s)
  ✔ error › error.message contains stdout/stderr if available (1.6s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.5s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.4s)
  ✔ error › failed is false on success (1.4s)
  ✔ error › failed is true on failure (1.3s)
  ✔ error › error.killed is true if process was killed directly (1.2s)
  ✔ error › error.killed is false if process was killed indirectly (1.2s)
  ✔ error › result.killed is false if not killed (1.1s)
  ✔ error › error.signal is SIGINT (461ms)
  ✔ error › error.signalDescription is defined (438ms)
  ✔ error › error.signal is SIGTERM (405ms)
  ✔ error › exitCode is undefined on signal termination (353ms)
  ✔ error › custom error.signal (384ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (398ms)
  ✔ error › error.code is undefined on success (412ms)
  ✔ error › result.signal is undefined for successful execution (539ms)
  ✔ error › result.signalDescription is undefined for successful execution (522ms)
  ✔ command › allow commands with spaces and no array arguments (3.1s)
  ✔ command › allow commands with spaces and array arguments (3s)
  ✔ command › execaCommand() (3s)
  ✔ command › execaCommand() ignores consecutive spaces (2.9s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.9s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.8s)
  ✔ command › execaCommand() escapes other whitespaces (2.7s)
  ✔ command › execaCommand() trims (2.7s)
  ✔ command › command is: " foo bar" (3.3s)
  ✔ command › command is: " baz quz" (3.2s)
  ✔ command › command is: "" (3.2s)
  ✔ command › escapedCommand is: "foo bar" (3.4s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.7s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3.9s)
  ✔ command › escapedCommand is: "\"*\"" (4.2s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.6s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.5s)
  ✔ kill › execa() returns a promise with kill() (3.5s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3.3s)
  ✔ kill › cancel method kills the subprocess (2.4s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (967ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (3.4s)
  ✔ kill › timeout must not be negative (3.4s)
  ✔ kill › timeout must be an integer (3.3s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (117ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (159ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (191ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.9s)
  ✔ kill › timeout does not kill the process if it does not time out (3.5s)
  ✔ kill › timedOut is false if timeout is undefined (3.5s)
  ✔ kill › timedOut is false if timeout is 0 (3.5s)
  ✔ kill › spawnAndExit (3.1s)
  ✔ kill › spawnAndExit cleanup (3.1s)
  ✔ kill › spawnAndExit detached (3.1s)
  ✔ kill › spawnAndExit cleanup detached (3s)
  ✔ kill › spawnAndKill SIGTERM (3s)
  ✔ kill › spawnAndKill SIGKILL (3s)
  ✔ kill › spawnAndKill cleanup SIGKILL (3s)
  ✔ kill › spawnAndKill detached SIGTERM (2.9s)
  ✔ kill › spawnAndKill detached SIGKILL (2.9s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.8s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.8s)
  ✔ kill › removes exit handler on exit (2.7s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.6s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.5s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (480ms)
  ✔ kill › error.isCanceled is true when cancel method is used (457ms)
  ✔ kill › error.isCanceled is false when kill method is used (443ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (418ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (363ms)
  ✔ kill › timeout kills the process if it times out (3.7s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (4s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (417ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.9s)
  ✔ kill › spawnAndKill cleanup SIGTERM (3s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (366ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (122ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process (101ms)
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process (101ms)
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process (101ms)
  ✔ node › node should not remove --inspect when passed through nodeOptions (106ms)
  ✔ node › node correctly use nodePath
  ✔ node › node pass on nodeOptions (195ms)
  ✔ node › node() (265ms)
  ✔ node › node's forked script has a communication channel (260ms)
  ✔ node › node pipe stdout (340ms)
  ✔ override-promise › should work with third-party Promise (129ms)
  ✔ promise › promise methods are not enumerable (118ms)
  ✔ promise › finally function is executed on failure (329ms)
  ✔ promise › throw in finally bubbles up on error (317ms)
  ✔ promise › finally function is executed on success (412ms)
  ✔ promise › throw in finally function bubbles up on success (354ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.8s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.7s)
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ test › execaSync() (2.3s)
  ✔ test › execaSync() throws error if written to stderr (2s)
  ✔ test › skip throwing when using reject option in sync mode (2s)
  ✔ test › stripFinalNewline in sync mode (1.8s)
  ✔ test › stripFinalNewline in sync mode on failure (1.4s)
  ✔ test › execa() returns a promise with pid (1s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (902ms)
  ✔ test › child_process.spawn() errors are propagated (996ms)
  ✔ test › write to fast-exit process (808ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (869ms)
  ✔ test › execa() rejects if running non-executable (940ms)
  ✔ test › preferLocal: undefined (1.4s)
  ✔ test › preferLocal: false (1.4s)
  ✔ test › child process errors rejects promise right away (1.2s)
  ✔ test › child process errors are handled (1.3s)
  ✔ test › stdin errors are handled (1.3s)
  ✔ test › execa() (2.7s)
  ✔ test › skip throwing when using reject option (2.4s)
  ✔ test › stripFinalNewline: true (2.2s)
  ✔ test › stripFinalNewline: false (2.2s)
  ✔ test › stripFinalNewline on failure (2.2s)
  ✔ test › localDir option (1.5s)
  ✔ test › do not try to consume streams twice (1.2s)
  ✔ test › use relative path with '..' chars (1.1s)
  ✔ test › use environment variables by default (942ms)
  ✔ test › extend environment variables by default (863ms)
  ✔ test › can use `options.cwd` as a string (802ms)
  ✔ test › localDir option can be a URL (711ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (513ms)
  ✔ test › do not extend environment with `extendEnv: false` (835ms)
  ✔ test › can use `options.cwd` as a URL (713ms)
  ✔ test › can use `options.shell: true` (668ms)
  ✔ test › can use `options.shell: string` (722ms)
  ✔ test › detach child process (897ms)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (2.4s)
  ✔ stream › input option can be a String - sync (1.7s)
  ✔ stream › input option can be a Buffer - sync (983ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (601ms)
  ✔ stream › buffer (2.7s)
  ✔ stream › pass `stdout` to a file descriptor (2.7s)
  ✔ stream › pass `stderr` to a file descriptor (2.7s)
  ✔ stream › result.all is undefined unless opts.all is true (2.6s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.6s)
  ✔ test › execPath option (2.6s)
  ✔ stream › input option can be a String (2.1s)
  ✔ stream › you can write to child.stdin (1.9s)
  ✔ stream › input option can be a Buffer (2.1s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (860ms)
  ✔ stream › input can be a Stream (2s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (890ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (894ms)
  ✔ stream › do not buffer when streaming (892ms)
  ✔ stream › buffer: false > promise resolves (867ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (824ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1s)
  ✔ stream › maxBuffer affects stderr (1.3s)
  ✔ stream › maxBuffer affects stdout (1.4s)
  ✔ stream › can use all: true with stdout: ignore (958ms)
  ✔ stream › can use all: true with stderr: ignore (942ms)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.1s)
  ✔ test › preferLocal: true (3.7s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsSubtree/execa/variant3/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (828ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.8s)
  ✔ error › result.killed is false if not killed, in sync mode (1s)
  ✔ error › result.killed is false on process error, in sync mode (188ms)
  ✔ error › Original error.message is kept (1.4s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (270ms)
  ✔ error › stdout/stderr/all on process errors (2s)
  ✔ error › stdout/stderr/all available on errors (2.1s)
  ✔ error › exitCode is 0 on success (2s)
  ✔ error › exitCode is 2 (1.9s)
  ✔ error › exitCode is 3 (1.9s)
  ✔ error › exitCode is 4 (1.9s)
  ✔ error › error.message contains the command (1.8s)
  ✔ error › error.message contains stdout/stderr if available (1.8s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.7s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.7s)
  ✔ error › failed is false on success (1.6s)
  ✔ error › failed is true on failure (1.5s)
  ✔ error › error.killed is true if process was killed directly (1.5s)
  ✔ error › error.killed is false if process was killed indirectly (1.3s)
  ✔ error › result.killed is false if not killed (1.3s)
  ✔ error › error.signal is SIGINT (372ms)
  ✔ error › error.signalDescription is defined (350ms)
  ✔ error › error.signal is SIGTERM (339ms)
  ✔ error › exitCode is undefined on signal termination (306ms)
  ✔ error › custom error.signal (349ms)
  ✔ error › result.signal is undefined for successful execution (421ms)
  ✔ error › error.code is undefined on success (439ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (521ms)
  ✔ error › result.signalDescription is undefined for successful execution (540ms)
  ✔ command › allow commands with spaces and no array arguments (3.1s)
  ✔ command › allow commands with spaces and array arguments (3.1s)
  ✔ command › execaCommand() (3s)
  ✔ command › execaCommand() ignores consecutive spaces (2.9s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.8s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.8s)
  ✔ command › execaCommand() escapes other whitespaces (2.6s)
  ✔ command › execaCommand() trims (2.6s)
  ✔ command › command is: " foo bar" (3.4s)
  ✔ command › command is: " baz quz" (3.4s)
  ✔ command › command is: "" (3.4s)
  ✔ command › escapedCommand is: "foo bar" (3.6s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.9s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (4.4s)
  ✔ command › escapedCommand is: "\"*\"" (4.7s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.4s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.4s)
  ✔ kill › execa() returns a promise with kill() (3.4s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3.1s)
  ✔ kill › cancel method kills the subprocess (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (928ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (3.3s)
  ✔ kill › timeout must not be negative (3.3s)
  ✔ kill › timeout must be an integer (3.3s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel (101ms)
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (138ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (175ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (219ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.7s)
  ✔ kill › timeout does not kill the process if it does not time out (3.5s)
  ✔ kill › timedOut is false if timeout is undefined (3.5s)
  ✔ kill › timedOut is false if timeout is 0 (3.4s)
  ✔ kill › spawnAndExit (3s)
  ✔ kill › spawnAndExit cleanup (3s)
  ✔ kill › spawnAndExit detached (2.9s)
  ✔ kill › spawnAndExit cleanup detached (2.9s)
  ✔ kill › spawnAndKill SIGTERM (2.8s)
  ✔ kill › spawnAndKill SIGKILL (2.8s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.8s)
  ✔ kill › spawnAndKill detached SIGTERM (2.7s)
  ✔ kill › spawnAndKill detached SIGKILL (2.7s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.7s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.7s)
  ✔ kill › removes exit handler on exit (2.6s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.4s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.4s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (511ms)
  ✔ kill › error.isCanceled is true when cancel method is used (502ms)
  ✔ kill › error.isCanceled is false when kill method is used (481ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (458ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (421ms)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.8s)
  ✔ kill › timeout kills the process if it times out (3.6s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.9s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (468ms)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (371ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.8s)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (135ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process (113ms)
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process (109ms)
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process (102ms)
  ✔ node › node should not remove --inspect when passed through nodeOptions (104ms)
  ✔ node › node correctly use nodePath
  ✔ node › node pass on nodeOptions (296ms)
  ✔ node › node's forked script has a communication channel (280ms)
  ✔ node › node() (359ms)
  ✔ node › node pipe stdout (350ms)
  ✔ override-promise › should work with third-party Promise (131ms)
  ✔ promise › promise methods are not enumerable (101ms)
  ✔ promise › finally function is executed on success (319ms)
  ✔ promise › finally function is executed on failure (311ms)
  ✔ promise › throw in finally function bubbles up on success (296ms)
  ✔ promise › throw in finally bubbles up on error (289ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.6s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.6s)
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ test › execaSync() (1.9s)
  ✔ test › execaSync() throws error if written to stderr (1.7s)
  ✔ test › skip throwing when using reject option in sync mode (1.6s)
  ✔ test › stripFinalNewline in sync mode (1.4s)
  ✔ test › stripFinalNewline in sync mode on failure (1.1s)
  ✔ test › execa() returns a promise with pid (946ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (928ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (877ms)
  ✔ test › child_process.spawn() errors are propagated (1s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (1s)
  ✔ test › execa() rejects if running non-executable (1s)
  ✔ test › preferLocal: undefined (1.3s)
  ✔ test › preferLocal: false (1.3s)
  ✔ test › child process errors rejects promise right away (1.2s)
  ✔ test › child process errors are handled (1.2s)
  ✔ test › stdin errors are handled (1.3s)
  ✔ test › execa() (2.5s)
  ✔ test › skip throwing when using reject option (2.2s)
  ✔ test › stripFinalNewline: true (2s)
  ✔ test › stripFinalNewline: false (2s)
  ✔ test › stripFinalNewline on failure (2s)
  ✔ test › localDir option (1.5s)
  ✔ test › do not try to consume streams twice (1.4s)
  ✔ test › use relative path with '..' chars (1.3s)
  ✔ test › write to fast-exit process (1.2s)
  ✔ test › use environment variables by default (1.2s)
  ✔ test › localDir option can be a URL (1s)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (736ms)
  ✔ test › extend environment variables by default (1.1s)
  ✔ test › can use `options.cwd` as a string (1.1s)
  ✔ test › can use `options.cwd` as a URL (1s)
  ✔ test › do not extend environment with `extendEnv: false` (1.1s)
  ✔ test › can use `options.shell: true` (925ms)
  ✔ test › can use `options.shell: string` (932ms)
  ✔ test › detach child process (1.1s)
  ✔ test › execPath option (2.1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (2.4s)
  ✔ stream › input option can be a String - sync (1.2s)
  ✔ stream › input option can be a Buffer - sync (874ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (615ms)
  ✔ stream › buffer (2.8s)
  ✔ stream › pass `stdout` to a file descriptor (2.8s)
  ✔ stream › pass `stderr` to a file descriptor (2.7s)
  ✔ stream › result.all is undefined unless opts.all is true (2.6s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.6s)
  ✔ stream › do not buffer when streaming (761ms)
  ✔ stream › input option can be a String (1.7s)
  ✔ stream › input option can be a Buffer (1.7s)
  ✔ stream › input can be a Stream (1.6s)
  ✔ stream › you can write to child.stdin (1.6s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (963ms)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (851ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (823ms)
  ✔ stream › buffer: false > promise resolves (745ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (654ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (982ms)
  ✔ test › preferLocal: true (3.8s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (938ms)
  ✔ stream › maxBuffer affects stderr (1.2s)
  ✔ stream › maxBuffer affects stdout (1.3s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1s)
  ✔ stream › can use all: true with stdout: ignore (911ms)
  ✔ stream › can use all: true with stderr: ignore (869ms)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsSubtree/execa/variant2/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (974ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (2.1s)
  ✔ error › result.killed is false if not killed, in sync mode (1.1s)
  ✔ error › result.killed is false on process error, in sync mode (289ms)
  ✔ error › Original error.message is kept (1.5s)
  ✔ error › error.code is defined on failure if applicable
  ✔ error › result.killed is false on process error (385ms)
  ✔ error › stdout/stderr/all on process errors (2.2s)
  ✔ error › stdout/stderr/all available on errors (2.4s)
  ✔ error › exitCode is 0 on success (2.2s)
  ✔ error › exitCode is 2 (2.1s)
  ✔ error › exitCode is 3 (2s)
  ✔ error › exitCode is 4 (2s)
  ✔ error › error.message contains the command (1.9s)
  ✔ error › error.message contains stdout/stderr if available (1.8s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.8s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.7s)
  ✔ error › failed is false on success (1.6s)
  ✔ error › failed is true on failure (1.5s)
  ✔ error › error.killed is true if process was killed directly (1.5s)
  ✔ error › error.killed is false if process was killed indirectly (1.4s)
  ✔ error › result.killed is false if not killed (1.3s)
  ✔ error › error.signal is SIGINT (422ms)
  ✔ error › error.signalDescription is defined (406ms)
  ✔ error › error.signal is SIGTERM (382ms)
  ✔ error › exitCode is undefined on signal termination (337ms)
  ✔ error › custom error.signal (380ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (399ms)
  ✔ error › result.signalDescription is undefined for successful execution (464ms)
  ✔ error › result.signal is undefined for successful execution (566ms)
  ✔ error › error.code is undefined on success (554ms)
  ✔ command › allow commands with spaces and no array arguments (2.9s)
  ✔ command › allow commands with spaces and array arguments (2.8s)
  ✔ command › execaCommand() (2.8s)
  ✔ command › execaCommand() ignores consecutive spaces (2.7s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.6s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.6s)
  ✔ command › execaCommand() escapes other whitespaces (2.5s)
  ✔ command › execaCommand() trims (2.5s)
  ✔ command › command is: " foo bar" (3.1s)
  ✔ command › command is: " baz quz" (3.1s)
  ✔ command › command is: "" (3s)
  ✔ command › escapedCommand is: "foo bar" (3.3s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.5s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3.7s)
  ✔ command › escapedCommand is: "\"*\"" (4.1s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.5s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.5s)
  ✔ kill › execa() returns a promise with kill() (3.4s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (3.2s)
  ✔ kill › cancel method kills the subprocess (2.5s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2.4s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (972ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (3.4s)
  ✔ kill › timeout must not be negative (3.3s)
  ✔ kill › timeout must be an integer (3.3s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel (105ms)
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (126ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (156ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (251ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.7s)
  ✔ kill › timeout does not kill the process if it does not time out (3.5s)
  ✔ kill › timedOut is false if timeout is undefined (3.5s)
  ✔ kill › timedOut is false if timeout is 0 (3.5s)
  ✔ kill › spawnAndExit (3.1s)
  ✔ kill › spawnAndExit cleanup (3s)
  ✔ kill › spawnAndExit detached (3s)
  ✔ kill › spawnAndExit cleanup detached (3s)
  ✔ kill › spawnAndKill SIGTERM (3s)
  ✔ kill › spawnAndKill SIGKILL (3s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.9s)
  ✔ kill › spawnAndKill detached SIGTERM (2.9s)
  ✔ kill › spawnAndKill detached SIGKILL (2.8s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.8s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.8s)
  ✔ kill › removes exit handler on exit (2.7s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.7s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.6s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (492ms)
  ✔ kill › error.isCanceled is true when cancel method is used (475ms)
  ✔ kill › error.isCanceled is false when kill method is used (465ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (446ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (406ms)
  ✔ kill › timeout kills the process if it times out (3.7s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.9s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.8s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (444ms)
  ✔ kill › spawnAndKill cleanup SIGTERM (3s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (365ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (104ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (173ms)
  ✔ node › node pipe stdout (168ms)
  ✔ node › node pass on nodeOptions (205ms)
  ✔ node › node's forked script has a communication channel (199ms)
  ✔ override-promise › should work with third-party Promise (130ms)
  ✔ promise › promise methods are not enumerable (115ms)
  ✔ promise › finally function is executed on failure (241ms)
  ✔ promise › finally function is executed on success (344ms)
  ✔ promise › throw in finally bubbles up on error (266ms)
  ✔ promise › throw in finally function bubbles up on success (327ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.7s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.7s)
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ test › execaSync() (2.1s)
  ✔ test › execaSync() throws error if written to stderr (2s)
  ✔ test › skip throwing when using reject option in sync mode (2s)
  ✔ test › stripFinalNewline in sync mode (1.9s)
  ✔ test › stripFinalNewline in sync mode on failure (1.7s)
  ✔ test › execa() returns a promise with pid (1.1s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (994ms)
  ✔ test › child_process.spawn() errors are propagated (1.1s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (1s)
  ✔ test › execa() rejects if running non-executable (1s)
  ✔ test › preferLocal: undefined (1.6s)
  ✔ test › preferLocal: false (1.7s)
  ✔ test › child process errors rejects promise right away (1.4s)
  ✔ test › child process errors are handled (1.5s)
  ✔ test › stdin errors are handled (1.6s)
  ✔ test › execa() (2.5s)
  ✔ test › skip throwing when using reject option (2.4s)
  ✔ test › stripFinalNewline: true (2.3s)
  ✔ test › stripFinalNewline: false (2.3s)
  ✔ test › stripFinalNewline on failure (2.3s)
  ✔ test › localDir option (1.8s)
  ✔ test › do not try to consume streams twice (1.3s)
  ✔ test › use relative path with '..' chars (1.3s)
  ✔ test › write to fast-exit process (1.1s)
  ✔ test › use environment variables by default (1.1s)
  ✔ test › can use `options.cwd` as a string (909ms)
  ✔ test › localDir option can be a URL (857ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (662ms)
  ✔ test › extend environment variables by default (1s)
  ✔ test › do not extend environment with `extendEnv: false` (971ms)
  ✔ test › can use `options.cwd` as a URL (784ms)
  ✔ test › can use `options.shell: true` (799ms)
  ✔ test › can use `options.shell: string` (856ms)
  ✔ test › execPath option (2s)
  ✔ test › detach child process (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (2.8s)
  ✔ stream › input option can be a String - sync (1.7s)
  ✔ stream › input option can be a Buffer - sync (845ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (520ms)
  ✔ stream › buffer (3s)
  ✔ stream › pass `stdout` to a file descriptor (3s)
  ✔ stream › pass `stderr` to a file descriptor (3s)
  ✔ stream › result.all is undefined unless opts.all is true (3s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.9s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (729ms)
  ✔ stream › you can write to child.stdin (2s)
  ✔ stream › input option can be a Buffer (2.1s)
  ✔ stream › input option can be a String (2.2s)
  ✔ stream › input can be a Stream (2.1s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (810ms)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (799ms)
  ✔ stream › do not buffer when streaming (752ms)
  ✔ stream › buffer: false > promise resolves (758ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (936ms)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (798ms)
  ✔ stream › maxBuffer affects stderr (1.2s)
  ✔ stream › maxBuffer affects stdout (1.2s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (997ms)
  ✔ stream › can use all: true with stderr: ignore (816ms)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1s)
  ✔ stream › can use all: true with stdout: ignore (885ms)
  ✔ test › preferLocal: true (4.1s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./VariantsSubtree/execa/variant1/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/command.js

  SyntaxError: The requested module 'path-key' does not provide an export named 'default'

  Uncaught exception in test/error.js

  SyntaxError: The requested module 'path-key' does not provide an export named 'default'

  ✖ test/command.js exited with a non-zero exit code: 1
  ✖ test/error.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  SyntaxError: The requested module 'path-key' does not provide an export named 'default'

  Uncaught exception in test/node.js

  SyntaxError: The requested module 'path-key' does not provide an export named 'default'

  ✖ test/kill.js exited with a non-zero exit code: 1
  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  SyntaxError: The requested module 'path-key' does not provide an export named 'default'

  ✖ test/override-promise.js exited with a non-zero exit code: 1

  Uncaught exception in test/promise.js

  SyntaxError: The requested module 'path-key' does not provide an export named 'default'

  ✖ test/promise.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }

  Uncaught exception in test/stream.js

  SyntaxError: The requested module 'path-key' does not provide an export named 'default'

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  SyntaxError: The requested module 'path-key' does not provide an export named 'default'

  ✖ test/test.js exited with a non-zero exit code: 1
  ─

  36 tests passed
  8 uncaught exceptions
----------|---------|----------|---------|---------|-------------------
File      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
----------|---------|----------|---------|---------|-------------------
All files |     100 |      100 |     100 |     100 |                   
 stdio.js |     100 |      100 |     100 |     100 |                   
----------|---------|----------|---------|---------|-------------------

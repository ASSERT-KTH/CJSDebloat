11
./Variants/execa/variant11/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✖ command › execaCommandSync() Error thrown in test
  ✖ error › stdout/stderr/all on process errors, in sync mode 
  ✖ error › result.killed is false if not killed, in sync mode Error thrown in test
  ✖ error › result.killed is false on process error, in sync mode 
  ✔ error › Original error.message is kept (1.5s)
  ✔ error › error.code is defined on failure if applicable (254ms)
  ✔ error › result.killed is false on process error (1.3s)
  ✔ error › stdout/stderr/all on process errors (1.9s)
  ✔ error › stdout/stderr/all available on errors (2.1s)
  ✔ error › exitCode is 0 on success (2.1s)
  ✔ error › exitCode is 2 (2.1s)
  ✔ error › exitCode is 3 (2s)
  ✔ error › exitCode is 4 (2s)
  ✔ error › error.message contains the command (2s)
  ✔ error › error.message contains stdout/stderr if available (2s)
  ✔ error › error.message does not contain stdout/stderr if not available (2s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.9s)
  ✔ error › failed is false on success (1.9s)
  ✔ error › failed is true on failure (1.9s)
  ✔ error › error.killed is true if process was killed directly (1.8s)
  ✔ error › error.killed is false if process was killed indirectly (1.7s)
  ✔ error › result.killed is false if not killed (1.7s)
  ✔ error › error.signal is SIGINT (1.4s)
  ✔ error › error.signalDescription is defined (1.3s)
  ✔ error › error.signal is SIGTERM (1.3s)
  ✔ error › exitCode is undefined on signal termination (1.1s)
  ✔ error › custom error.signal (1.2s)
  ✔ command › allow commands with spaces and no array arguments (1.8s)
  ✔ command › allow commands with spaces and array arguments (1.7s)
  ✔ command › execaCommand() (1.5s)
  ✔ command › execaCommand() ignores consecutive spaces (1.5s)
  ✔ command › execaCommand() allows escaping spaces in commands (1.4s)
  ✔ command › execaCommand() allows escaping spaces in arguments (1.4s)
  ✔ command › execaCommand() escapes other whitespaces (1.3s)
  ✔ command › execaCommand() trims (1.2s)
  ✔ error › result.signal is undefined if process failed, but was not killed (1s)
  ✔ error › result.signal is undefined for successful execution (1.1s)
  ✔ error › result.signalDescription is undefined for successful execution (1s)
  ✔ error › error.code is undefined on success (995ms)
  ✔ command › command is: " baz quz" (2.3s)
  ✖ command › escapedCommand is: "foo bar" 
  ✖ command › escapedCommand is: "\"*\"" 
  ✔ command › command is: " foo bar" (2.5s)
  ✔ command › command is: "" (2.4s)
  ✖ command › escapedCommand is: "\"\\\"foo\\\"\"" 
  ✖ command › escapedCommand is: "\"foo bar\"" 
  ✔ kill › `forceKillAfterTimeout` should not be NaN (1.4s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (1.4s)
  ✔ kill › execa() returns a promise with kill() (1.4s)
  ✖ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode Error thrown in test
  ✔ kill › cancel method kills the subprocess (824ms)
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) Error thrown in test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) 
  ✖ kill › timeout kills the process if it times out, in sync mode 
  ✔ kill › timeout must not be negative (1.5s)
  ✔ kill › timeout must be an integer (1.5s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel (362ms)
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (425ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (542ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (630ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (1.9s)
  ✔ kill › timeout does not kill the process if it does not time out (2s)
  ✔ kill › timedOut is false if timeout is undefined (2s)
  ✔ kill › timedOut is false if timeout is 0 (1.9s)
  ✔ kill › removes exit handler on exit (1.5s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (1.2s)
  ✔ kill › error.isCanceled is true when cancel method is used (1.1s)
  ✔ kill › error.isCanceled is false when kill method is used (1.1s)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (1.1s)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (1s)
  ✔ kill › timeout kills the process if it times out (2.1s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (1.4s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (1.4s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (2.2s)
  ✔ kill › spawnAndKill SIGTERM (1.9s)
  ✔ kill › spawnAndKill cleanup SIGKILL (1.8s)
  ✔ kill › spawnAndKill SIGKILL (1.9s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (1.8s)
  ✔ kill › spawnAndKill detached SIGKILL (1.8s)
  ✔ kill › spawnAndKill detached SIGTERM (1.9s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (1.8s)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (1.2s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (1.3s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.1s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (1.2s)
  ✔ kill › spawnAndExit (2.4s)
  ✔ kill › spawnAndExit detached (2.3s)
  ✔ kill › spawnAndExit cleanup (2.4s)
  ✔ kill › spawnAndExit cleanup detached (2.4s)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process (314ms)
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (260ms)
  ✔ node › node's forked script has a communication channel (255ms)
  ✔ node › node pass on nodeOptions (279ms)
  ✔ node › node pipe stdout (309ms)
  ✔ override-promise › should work with third-party Promise
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on success (243ms)
  ✔ promise › finally function is executed on failure (250ms)
  ✔ promise › throw in finally bubbles up on error (251ms)
  ✔ promise › throw in finally function bubbles up on success (275ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (6.9s)
  ✔ kill › kill() with no arguments should kill after a timeout (6.9s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✖ test › execaSync() Error thrown in test
  ✖ test › execaSync() throws error if written to stderr 
  ✖ test › skip throwing when using reject option in sync mode Error thrown in test
  ✖ test › stripFinalNewline in sync mode Error thrown in test
  ✖ test › stripFinalNewline in sync mode on failure 
  ✔ test › execa() returns a promise with pid (879ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (871ms)
  ✖ test › child_process.spawnSync() errors are propagated with a correct shape 
  ✖ test › execa() rejects with correct error and doesn't throw if running non-executable with input Rejected promise returned by test
  ✖ test › write to fast-exit process 
  ✔ test › child_process.spawn() errors are propagated (1s)
  ✔ test › execa() rejects if running non-executable (1.1s)
  ✔ test › preferLocal: undefined (1.4s)
  ✔ test › preferLocal: false (1.5s)
  ✔ test › child process errors rejects promise right away (1.4s)
  ✔ test › child process errors are handled (1.4s)
  ✔ test › stdin errors are handled (1.5s)
  ✔ test › execa() (2s)
  ✔ test › skip throwing when using reject option (2s)
  ✔ test › stripFinalNewline: true (2s)
  ✔ test › stripFinalNewline: false (2s)
  ✔ test › stripFinalNewline on failure (2s)
  ✔ test › localDir option (1.9s)
  ✔ test › do not try to consume streams twice (1.7s)
  ✔ test › use relative path with '..' chars (1.7s)
  ✔ test › use environment variables by default (1.6s)
  ✔ test › do not extend environment with `extendEnv: false` (1.5s)
  ✔ test › can use `options.cwd` as a string (1.5s)
  ✔ test › localDir option can be a URL (1.4s)
  ✔ test › can use `options.cwd` as a URL (1.4s)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (1.2s)
  ✔ test › extend environment variables by default (1.6s)
  ✔ test › can use `options.shell: true` (1.4s)
  ✔ test › can use `options.shell: string` (1.4s)
  ✖ stream › stdout/stderr/all are undefined if ignored in sync mode Error thrown in test
  ✖ stream › input option can be a String - sync Error thrown in test
  ✖ stream › input option can be a Buffer - sync Error thrown in test
  ✖ stream › helpful error trying to provide an input stream in sync mode 
  ✖ stream › input option can be a String Rejected promise returned by test
  ✖ stream › input option can be a Buffer Rejected promise returned by test
  ✖ stream › input can be a Stream Rejected promise returned by test
  ✖ stream › opts.stdout:ignore - stdout will not collect data Rejected promise returned by test
  ✔ stream › buffer (1.8s)
  ✔ stream › pass `stdout` to a file descriptor (1.8s)
  ✔ stream › pass `stderr` to a file descriptor (1.7s)
  ✔ stream › result.all is undefined unless opts.all is true (1.7s)
  ✔ stream › stdout/stderr/all are undefined if ignored (1.6s)
  ✔ test › detach child process (1.7s)
  ✔ stream › you can write to child.stdin (1.4s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (1.1s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (1.1s)
  ✔ stream › do not buffer when streaming (1.1s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (821ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1s)
  ✔ stream › buffer: false > promise resolves (1.1s)
  ✔ stream › maxBuffer affects stderr (1.5s)
  ✔ test › execPath option (3s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1s)
  ✔ stream › can use all: true with stdout: ignore (947ms)
  ✔ stream › maxBuffer affects stdout (1.7s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.2s)
  ✔ stream › can use all: true with stderr: ignore (917ms)
  ✔ test › preferLocal: true (3.4s)

  Unhandled rejection in test/test.js

  Error: spawn non-executable.js EACCES

  ─

  command › execaCommandSync()

  test/command.js:85

   84: test('execaCommandSync()', t => {                                        
   85:   const {stdout} = execaCommandSync('node test/fixtures/echo.js foo bar'…
   86:   t.is(stdout, 'foo\nbar');                                              

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › execaCommandSync (file://index.js:234:9)
  › file://test/command.js:85:19



  error › stdout/stderr/all on process errors, in sync mode

  test/error.js:38

   37:   });                         
   38:   t.is(stdout, '');           
   39:   t.is(stderr, WRONG_COMMAND);

  Difference:

  - undefined
  + ''

  › file://test/error.js:38:4



  error › result.killed is false if not killed, in sync mode

  test/error.js:120

   119: test('result.killed is false if not killed, in sync mode', t => {
   120:   const {killed} = execaSync('noop.js');                         
   121:   t.false(killed);                                               

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › file://test/error.js:120:19



  error › result.killed is false on process error, in sync mode

  test/error.js:133

   132:   });             
   133:   t.false(killed);
   134: });               

  Value is not `false`:

  undefined

  › file://test/error.js:133:9



  command › escapedCommand is: "foo bar"

  test/command.js:28

   27:   });                                                 
   28:   t.is(failEscapedCommandSync, `fail.js ${expected}`);
   29:                                                       

  Difference:

  - undefined
  + 'fail.js foo bar'

  › testEscapedCommand (file://test/command.js:28:4)



  command › escapedCommand is: "\"*\""

  test/command.js:28

   27:   });                                                 
   28:   t.is(failEscapedCommandSync, `fail.js ${expected}`);
   29:                                                       

  Difference:

  - undefined
  + 'fail.js "*"'

  › testEscapedCommand (file://test/command.js:28:4)



  command › escapedCommand is: "\"\\\"foo\\\"\""

  test/command.js:28

   27:   });                                                 
   28:   t.is(failEscapedCommandSync, `fail.js ${expected}`);
   29:                                                       

  Difference:

  - undefined
  + 'fail.js "\\"foo\\""'

  › testEscapedCommand (file://test/command.js:28:4)



  command › escapedCommand is: "\"foo bar\""

  test/command.js:28

   27:   });                                                 
   28:   t.is(failEscapedCommandSync, `fail.js ${expected}`);
   29:                                                       

  Difference:

  - undefined
  + 'fail.js "foo bar"'

  › testEscapedCommand (file://test/command.js:28:4)



  kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode

  test/kill.js:127

   126: test('timedOut is false if timeout is undefined and exit code is 0 in s…
   127:   const {timedOut} = execaSync('noop.js');                              
   128:   t.false(timedOut);                                                    

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › file://test/kill.js:127:21



  kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success)

  test/kill.js:211

   210: test('result.isCanceled is false when spawned.cancel() isn\'t called in…
   211:   const {isCanceled} = execaSync('noop.js');                            
   212:   t.false(isCanceled);                                                  

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › file://test/kill.js:211:23



  kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure)

  test/kill.js:219

   218:   });                 
   219:   t.false(isCanceled);
   220: });                   

  Value is not `false`:

  undefined

  › file://test/kill.js:219:9



  kill › timeout kills the process if it times out, in sync mode

  test/kill.js:93

   92:   });              
   93:   t.false(killed); 
   94:   t.true(timedOut);

  Value is not `false`:

  undefined

  › file://test/kill.js:93:9



  test › execaSync()

  test/test.js:33

   32: test('execaSync()', t => {                       
   33:   const {stdout} = execaSync('noop.js', ['foo']);
   34:   t.is(stdout, 'foo');                           

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › file://test/test.js:33:19



  test › execaSync() throws error if written to stderr

  test/test.js:38

   37: test('execaSync() throws error if written to stderr', t => {
   38:   t.throws(() => {                                          
   39:     execaSync('foo');                                       

  Function threw unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /spawn.* ENOENT/

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › t.throws.message (file://test/test.js:39:3)
  › file://test/test.js:38:4



  test › skip throwing when using reject option in sync mode

  test/test.js:49

   48: test('skip throwing when using reject option in sync mode', t => {
   49:   const {exitCode} = execaSync('fail.js', {reject: false});       
   50:   t.is(exitCode, 2);                                              

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › file://test/test.js:49:21



  test › stripFinalNewline in sync mode

  test/test.js:69

   68: test('stripFinalNewline in sync mode', t => {                            
   69:   const {stdout} = execaSync('noop.js', ['foo'], {stripFinalNewline: tru…
   70:   t.is(stdout, 'foo');                                                   

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › file://test/test.js:69:19



  test › stripFinalNewline in sync mode on failure

  test/test.js:77

   76:   });                 
   77:   t.is(stderr, 'foo');
   78: });                   

  Difference:

  - undefined
  + 'foo'

  › file://test/test.js:77:4



  test › child_process.spawnSync() errors are propagated with a correct shape

  test/test.js:153

   152:   });            
   153:   t.true(failed);
   154: });              

  Value is not `true`:

  undefined

  › file://test/test.js:153:8



  test › execa() rejects with correct error and doesn't throw if running non-executable with input

  test/test.js:177

   176:   test('execa() rejects with correct error and doesn\'t throw if runnin…
   177:     await t.throwsAsync(execa('non-executable.js', {input: 'Hey!'}), {m…
   178:   });                                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › handleInput (file://lib/stream.js:11:6)
  › execa (file://index.js:157:2)
  › file://test/test.js:177:23



  test › write to fast-exit process

  test/test.js:189

   188:     } catch (error) {           
   189:       t.is(error.code, 'EPIPE');
   190:     }                           

  Difference:

  - undefined
  + 'EPIPE'

  › file://test/test.js:189:6



  stream › stdout/stderr/all are undefined if ignored in sync mode

  test/stream.js:49

   48: test('stdout/stderr/all are undefined if ignored in sync mode', t => {   
   49:   const {stdout, stderr, all} = execaSync('noop.js', {stdio: 'ignore', a…
   50:   t.is(stdout, undefined);                                               

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › file://test/stream.js:49:32



  stream › input option can be a String - sync

  test/stream.js:81

   80: test('input option can be a String - sync', t => {          
   81:   const {stdout} = execaSync('stdin.js', {input: 'foobar'});
   82:   t.is(stdout, 'foobar');                                   

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › file://test/stream.js:81:19



  stream › input option can be a Buffer - sync

  test/stream.js:86

   85: test('input option can be a Buffer - sync', t => {                       
   86:   const {stdout} = execaSync('stdin.js', {input: Buffer.from('testing12'…
   87:   t.is(stdout, 'testing12');                                             

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › file://test/stream.js:86:19



  stream › helpful error trying to provide an input stream in sync mode

  test/stream.js:99

   98: test('helpful error trying to provide an input stream in sync mode', t =…
   99:   t.throws(                                                              
   100:     () => {                                                              

  Function threw unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /The `input` option cannot be a stream in sync mode/

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › validateInputSync (file://lib/stream.js:83:6)
  › execaSync (file://index.js:169:2)
  › t.throws.message (file://test/stream.js:101:4)
  › file://test/stream.js:99:4



  stream › input option can be a String

  test/stream.js:56

   55: test('input option can be a String', async t => {             
   56:   const {stdout} = await execa('stdin.js', {input: 'foobar'});
   57:   t.is(stdout, 'foobar');                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › handleInput (file://lib/stream.js:11:6)
  › execa (file://index.js:157:2)
  › file://test/stream.js:56:25



  stream › input option can be a Buffer

  test/stream.js:61

   60: test('input option can be a Buffer', async t => {                
   61:   const {stdout} = await execa('stdin.js', {input: 'testing12'});
   62:   t.is(stdout, 'testing12');                                     

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › handleInput (file://lib/stream.js:11:6)
  › execa (file://index.js:157:2)
  › file://test/stream.js:61:25



  stream › input can be a Stream

  test/stream.js:69

   68:   stream.end();                                             
   69:   const {stdout} = await execa('stdin.js', {input: stream});
   70:   t.is(stdout, 'howdy');                                    

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › handleInput (file://lib/stream.js:11:6)
  › execa (file://index.js:157:2)
  › file://test/stream.js:69:25



  stream › opts.stdout:ignore - stdout will not collect data

  test/stream.js:91

   90: test('opts.stdout:ignore - stdout will not collect data', async t => {
   91:   const {stdout} = await execa('stdin.js', {                          
   92:     input: 'hello',                                                   

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › isStream (file://node_modules/is-stream/index.js:2:5)
  › handleInput (file://lib/stream.js:11:6)
  › execa (file://index.js:157:2)
  › file://test/stream.js:91:25

  ─

  28 tests failed
  1 unhandled rejection
-------------|---------|----------|---------|---------|-----------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s     
-------------|---------|----------|---------|---------|-----------------------
All files    |   91.29 |    96.11 |     100 |   91.29 |                       
 execa       |   80.52 |    86.36 |     100 |   80.52 |                       
  index.js   |   80.52 |    86.36 |     100 |   80.52 | 55-57,175-191,193-224 
 execa/lib   |   98.49 |    98.76 |     100 |   98.49 |                       
  command.js |     100 |      100 |     100 |     100 |                       
  error.js   |     100 |      100 |     100 |     100 |                       
  kill.js    |     100 |      100 |     100 |     100 |                       
  promise.js |     100 |      100 |     100 |     100 |                       
  stdio.js   |     100 |      100 |     100 |     100 |                       
  stream.js  |   93.02 |    93.75 |     100 |   93.02 | 12-15,84-85           
-------------|---------|----------|---------|---------|-----------------------
./Variants/execa/variant10/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (949ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.8s)
  ✔ error › result.killed is false if not killed, in sync mode (1.2s)
  ✔ error › result.killed is false on process error, in sync mode (184ms)
  ✔ error › Original error.message is kept (1.7s)
  ✔ error › error.code is defined on failure if applicable (106ms)
  ✔ error › result.killed is false on process error (285ms)
  ✔ error › stdout/stderr/all on process errors (2s)
  ✔ error › stdout/stderr/all available on errors (2.1s)
  ✔ error › exitCode is 0 on success (2.1s)
  ✔ error › exitCode is 2 (2.1s)
  ✔ error › exitCode is 3 (2s)
  ✔ error › exitCode is 4 (2s)
  ✔ error › error.message contains the command (2s)
  ✔ error › error.message contains stdout/stderr if available (1.9s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.9s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.9s)
  ✔ error › failed is false on success (1.8s)
  ✔ error › failed is true on failure (1.8s)
  ✔ error › error.killed is true if process was killed directly (1.7s)
  ✔ error › error.killed is false if process was killed indirectly (1.6s)
  ✔ error › result.killed is false if not killed (1.6s)
  ✔ error › error.signal is SIGINT (404ms)
  ✔ error › error.signalDescription is defined (394ms)
  ✔ error › error.signal is SIGTERM (388ms)
  ✔ error › exitCode is undefined on signal termination (376ms)
  ✔ error › custom error.signal (401ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (490ms)
  ✔ error › error.code is undefined on success (513ms)
  ✔ error › result.signal is undefined for successful execution (639ms)
  ✔ error › result.signalDescription is undefined for successful execution (618ms)
  ✔ command › allow commands with spaces and no array arguments (2.7s)
  ✔ command › allow commands with spaces and array arguments (2.6s)
  ✔ command › execaCommand() (2.6s)
  ✔ command › execaCommand() ignores consecutive spaces (2.5s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.4s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.3s)
  ✔ command › execaCommand() escapes other whitespaces (2.3s)
  ✔ command › execaCommand() trims (2.2s)
  ✔ command › command is: " foo bar" (3s)
  ✔ command › command is: " baz quz" (2.9s)
  ✔ command › command is: "" (2.9s)
  ✔ command › escapedCommand is: "foo bar" (3.1s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.2s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3.3s)
  ✔ command › escapedCommand is: "\"*\"" (3.7s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3s)
  ✔ kill › execa() returns a promise with kill() (3s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.8s)
  ✔ kill › cancel method kills the subprocess (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (989ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (3s)
  ✔ kill › timeout must not be negative (2.9s)
  ✔ kill › timeout must be an integer (2.9s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel (118ms)
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (159ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (229ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (256ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.2s)
  ✔ kill › timeout does not kill the process if it does not time out (3.1s)
  ✔ kill › timedOut is false if timeout is undefined (3.1s)
  ✔ kill › timedOut is false if timeout is 0 (3.1s)
  ✔ kill › spawnAndExit (2.6s)
  ✔ kill › spawnAndExit cleanup (2.6s)
  ✔ kill › spawnAndExit detached (2.6s)
  ✔ kill › spawnAndExit cleanup detached (2.5s)
  ✔ kill › spawnAndKill SIGTERM (2.5s)
  ✔ kill › spawnAndKill SIGKILL (2.5s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.5s)
  ✔ kill › spawnAndKill detached SIGTERM (2.5s)
  ✔ kill › spawnAndKill detached SIGKILL (2.4s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.4s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.4s)
  ✔ kill › removes exit handler on exit (2.4s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.3s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (496ms)
  ✔ kill › error.isCanceled is true when cancel method is used (485ms)
  ✔ kill › error.isCanceled is false when kill method is used (466ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (452ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (422ms)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.5s)
  ✔ kill › timeout kills the process if it times out (3.2s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.4s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (452ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.4s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (392ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node pipe stdout (307ms)
  ✔ node › node's forked script has a communication channel (269ms)
  ✔ node › node() (319ms)
  ✔ node › node pass on nodeOptions (298ms)
  ✔ override-promise › should work with third-party Promise (111ms)
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on failure (257ms)
  ✔ promise › finally function is executed on success (276ms)
  ✔ promise › throw in finally function bubbles up on success (274ms)
  ✔ promise › throw in finally bubbles up on error (261ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.2s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.2s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (2s)
  ✔ stream › input option can be a String - sync (1.4s)
  ✔ stream › input option can be a Buffer - sync (1.2s)
  ✔ stream › helpful error trying to provide an input stream in sync mode (926ms)
  ✔ stream › buffer (2.2s)
  ✔ stream › pass `stdout` to a file descriptor (2.2s)
  ✔ stream › pass `stderr` to a file descriptor (2.2s)
  ✔ stream › result.all is undefined unless opts.all is true (2.2s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.1s)
  ✔ test › execaSync() (2.3s)
  ✔ test › execaSync() throws error if written to stderr (2.2s)
  ✔ test › skip throwing when using reject option in sync mode (2.2s)
  ✔ test › stripFinalNewline in sync mode (2s)
  ✔ test › stripFinalNewline in sync mode on failure (1.5s)
  ✔ test › execa() returns a promise with pid (1s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (1s)
  ✔ test › child_process.spawn() errors are propagated (1.2s)
  ✔ stream › input option can be a String (1.8s)
  ✔ stream › input option can be a Buffer (1.7s)
  ✔ stream › you can write to child.stdin (1.7s)
  ✔ stream › input can be a Stream (1.7s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (1.3s)
  ✔ test › execa() rejects if running non-executable (1.3s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (1.3s)
  ✔ test › preferLocal: undefined (1.6s)
  ✔ test › preferLocal: false (1.6s)
  ✔ test › child process errors rejects promise right away (1.5s)
  ✔ test › child process errors are handled (1.6s)
  ✔ test › stdin errors are handled (1.6s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (1.4s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (1.4s)
  ✔ stream › do not buffer when streaming (1.4s)
  ✔ test › execa() (3.2s)
  ✔ test › skip throwing when using reject option (3s)
  ✔ test › stripFinalNewline: true (2.9s)
  ✔ test › stripFinalNewline: false (2.8s)
  ✔ test › stripFinalNewline on failure (2.8s)
  ✔ test › localDir option (1.9s)
  ✔ test › do not try to consume streams twice (1.7s)
  ✔ test › use relative path with '..' chars (1.7s)
  ✔ test › write to fast-exit process (1.6s)
  ✔ test › localDir option can be a URL (1.4s)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (1s)
  ✔ test › use environment variables by default (1.6s)
  ✔ test › do not extend environment with `extendEnv: false` (1.5s)
  ✔ test › extend environment variables by default (1.6s)
  ✔ test › can use `options.cwd` as a string (1.5s)
  ✔ test › can use `options.cwd` as a URL (1.4s)
  ✔ stream › buffer: false > promise resolves (1.5s)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1.6s)
  ✔ test › can use `options.shell: true` (1.4s)
  ✔ test › can use `options.shell: string` (1.4s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (1.4s)
  ✔ stream › can use all: true with stdout: ignore (1.4s)
  ✔ stream › can use all: true with stderr: ignore (1.2s)
  ✔ stream › maxBuffer affects stdout (2.1s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.6s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.7s)
  ✔ stream › maxBuffer affects stderr (2.1s)
  ✔ test › execPath option (2.3s)
  ✔ test › detach child process (1.5s)
  ✔ test › preferLocal: true (2.8s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./Variants/execa/variant9/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/command.js

  ReferenceError: lyx is not defined

  › supported (node_modules/human-signals/src/main.js:9:3)
  › <anonymous> (node_modules/human-signals/src/main.js:24:34)

  Uncaught exception in test/error.js

  ReferenceError: lyx is not defined

  › supported (node_modules/human-signals/src/main.js:9:3)
  › <anonymous> (node_modules/human-signals/src/main.js:24:34)

  ✖ test/command.js exited with a non-zero exit code: 1
  ✖ test/error.js exited with a non-zero exit code: 1

  Uncaught exception in test/node.js

  ReferenceError: lyx is not defined

  › supported (node_modules/human-signals/src/main.js:9:3)
  › <anonymous> (node_modules/human-signals/src/main.js:24:34)

  Uncaught exception in test/kill.js

  ReferenceError: lyx is not defined

  › supported (node_modules/human-signals/src/main.js:9:3)
  › <anonymous> (node_modules/human-signals/src/main.js:24:34)

  ✖ test/kill.js exited with a non-zero exit code: 1
  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  ReferenceError: lyx is not defined

  › supported (node_modules/human-signals/src/main.js:9:3)
  › <anonymous> (node_modules/human-signals/src/main.js:24:34)

  Uncaught exception in test/promise.js

  ReferenceError: lyx is not defined

  › supported (node_modules/human-signals/src/main.js:9:3)
  › <anonymous> (node_modules/human-signals/src/main.js:24:34)

  ✖ test/promise.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }

  Uncaught exception in test/stream.js

  ReferenceError: lyx is not defined

  › supported (node_modules/human-signals/src/main.js:9:3)
  › <anonymous> (node_modules/human-signals/src/main.js:24:34)

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  ReferenceError: lyx is not defined

  › supported (node_modules/human-signals/src/main.js:9:3)
  › <anonymous> (node_modules/human-signals/src/main.js:24:34)

  ✖ test/test.js exited with a non-zero exit code: 1

  ✖ Timed out while running tests

  ─

  36 tests passed
  8 uncaught exceptions
-------------|---------|----------|---------|---------|---------------------------------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                           
-------------|---------|----------|---------|---------|---------------------------------------------
All files    |   27.32 |      100 |    8.33 |   27.32 |                                             
 execa       |    13.1 |      100 |       0 |    13.1 |                                             
  index.js   |    13.1 |      100 |       0 |    13.1 | ...2,76-162,165-225,228-230,233-235,238-267 
 execa/lib   |   36.84 |      100 |   10.71 |   36.84 |                                             
  command.js |    43.9 |      100 |       0 |    43.9 | 2-6,13-17,28-40                             
  error.js   |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                  
  kill.js    |   36.27 |      100 |       0 |   36.27 | ...-29,38-46,51-55,59-60,65-80,84-86,91-101 
  promise.js |   30.55 |      100 |       0 |   30.55 | 3-4,9-18,23-35                              
  stdio.js   |     100 |      100 |     100 |     100 |                                             
  stream.js  |   29.06 |      100 |       0 |   29.06 | 7-15,20-34,39-49,53-61,66-79,83-85          
-------------|---------|----------|---------|---------|---------------------------------------------
./Variants/execa/variant8/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (988ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.9s)
  ✔ error › result.killed is false if not killed, in sync mode (1.2s)
  ✔ error › result.killed is false on process error, in sync mode (185ms)
  ✖ error › exitCode is 0 on success Rejected promise returned by test
  ✖ error › failed is false on success Rejected promise returned by test
  ✖ error › result.killed is false if not killed Rejected promise returned by test
  ✖ error › result.signal is undefined for successful execution Rejected promise returned by test
  ✖ error › result.signalDescription is undefined for successful execution Rejected promise returned by test
  ✖ error › error.code is undefined on success Rejected promise returned by test
  ✖ error › stdout/stderr/all available on errors 
  ✖ error › stdout/stderr/all on process errors 
  ✖ error › exitCode is 2 
  ✖ error › exitCode is 3 
  ✖ error › exitCode is 4 
  ✖ error › error.message contains the command 
  ✖ error › error.message contains stdout/stderr if available 
  ✔ error › error.message does not contain stdout/stderr if not available (1.8s)
  ✖ error › error.shortMessage does not contain stdout/stderr Rejected promise returned by test
  ✖ error › failed is true on failure 
  ✖ error › error.killed is true if process was killed directly 
  ✖ error › error.killed is false if process was killed indirectly 
  ✖ error › result.killed is false on process error 
  ✖ error › error.signal is SIGINT 
  ✖ error › error.signalDescription is defined 
  ✖ error › error.signal is SIGTERM 
  ✖ error › custom error.signal 
  ✔ error › exitCode is undefined on signal termination (230ms)
  ✖ error › result.signal is undefined if process failed, but was not killed 
  ✔ error › Original error.message is kept (1.7s)
  ✔ error › error.code is defined on failure if applicable (129ms)

  Unhandled rejection in test/error.js

  Error: spawn wrong command ENOENT

  Unhandled rejection in test/error.js

  Error: spawn wrong command ENOENT

  ✖ command › allow commands with spaces and no array arguments Rejected promise returned by test
  ✖ command › allow commands with spaces and array arguments Rejected promise returned by test
  ✖ command › execaCommand() Rejected promise returned by test
  ✖ command › execaCommand() ignores consecutive spaces Rejected promise returned by test
  ✖ command › execaCommand() allows escaping spaces in commands Rejected promise returned by test
  ✖ command › execaCommand() allows escaping spaces in arguments Rejected promise returned by test
  ✖ command › execaCommand() escapes other whitespaces Rejected promise returned by test
  ✖ command › execaCommand() trims Rejected promise returned by test
  ✖ command › command is: " foo bar" 
  ✖ command › command is: " baz quz" 
  ✖ command › command is: "" 
  ✖ command › escapedCommand is: "foo bar" 
  ✖ command › escapedCommand is: "\"foo bar\"" 
  ✖ command › escapedCommand is: "\"\\\"foo\\\"\"" 
  ✖ command › escapedCommand is: "\"*\"" 
  ✖ node › node removes --inspect from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect=9222 from nodeOptions when defined by parent process Rejected promise returned by test
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3s)
  ✔ kill › execa() returns a promise with kill() (3s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.8s)
  ✔ kill › cancel method kills the subprocess (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (1.9s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (779ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (3s)
  ✔ kill › timeout must not be negative (2.9s)
  ✔ kill › timeout must be an integer (2.9s)
  ✖ kill › timeout does not kill the process if it does not time out Rejected promise returned by test
  ✖ kill › timedOut is false if timeout is undefined Rejected promise returned by test
  ✖ kill › timedOut is false if timeout is 0 Rejected promise returned by test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called (success) Rejected promise returned by test
  ✖ kill › calling cancel method on a successfully completed process does not make result.isCanceled true Rejected promise returned by test
  ✖ kill › calling abort on a successfully completed process does not make result.isCanceled true Rejected promise returned by test
  ✖ kill › spawnAndExit 
  ✖ kill › spawnAndExit cleanup 
  ✖ kill › spawnAndExit detached 
  ✖ kill › spawnAndExit cleanup detached 
  ✖ node › node removes --inspect-brk from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ kill › timeout kills the process if it times out 
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) 
  ✖ kill › calling cancel method throws an error with message "Command was canceled" 
  ✖ kill › error.isCanceled is true when cancel method is used 
  ✖ kill › error.isCanceled is false when kill method is used 
  ✖ kill › calling cancel method twice should show the same behaviour as calling it once 
  ✖ kill › calling cancel method on a process which has been killed does not make error.isCanceled true 
  ✖ kill › calling abort throws an error with message "Command was canceled" 
  ✖ kill › calling abort twice should show the same behaviour as calling it once 
  ✖ kill › calling cancel after abort should show the same behaviour as only calling cancel 
  ✖ kill › calling abort after cancel should show the same behaviour as only calling cancel 
  ✖ node › node should not remove --inspect when passed through nodeOptions Rejected promise returned by test
  ✖ kill › kill("SIGKILL") should terminate cleanly 
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.3s)
  ✖ kill › `forceKillAfterTimeout: number` should kill after a timeout 
  ✖ kill › `forceKillAfterTimeout: true` should kill after a timeout 
  ✖ kill › kill() with no arguments should kill after a timeout 
  ✖ node › node() Rejected promise returned by test
  ✖ node › node pipe stdout Rejected promise returned by test
  ✖ node › node correctly use nodePath Rejected promise returned by test
  ✖ node › node pass on nodeOptions Rejected promise returned by test
  ✖ kill › spawnAndKill SIGTERM 
  ✖ kill › spawnAndKill SIGKILL 
  ✖ kill › spawnAndKill cleanup SIGTERM 
  ✖ kill › spawnAndKill cleanup SIGKILL 
  ✖ kill › spawnAndKill detached SIGTERM 
  ✖ kill › spawnAndKill detached SIGKILL 
  ✖ kill › spawnAndKill cleanup detached SIGTERM 
  ✖ kill › spawnAndKill cleanup detached SIGKILL 
  ✔ kill › removes exit handler on exit (2.5s)

  Unhandled rejection in test/kill.js

  test/kill.js:269

   268:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   269:     abortController.abort();                                            
   270:     await t.throwsAsync(subprocess, {message: /Command was canceled/}); 

  AbortError: The operation was aborted

  › file://test/kill.js:269:19

  Unhandled rejection in test/kill.js

  test/kill.js:276

   275:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   276:     abortController.abort();                                            
   277:     abortController.abort();                                            

  AbortError: The operation was aborted

  › file://test/kill.js:276:19

  Unhandled rejection in test/kill.js

  test/kill.js:294

   293:     const subprocess = execa('noop.js', [], {signal: abortController.si…
   294:     abortController.abort();                                            
   295:     subprocess.cancel();                                                

  AbortError: The operation was aborted

  › file://test/kill.js:294:19

  Unhandled rejection in test/kill.js

  test/kill.js:305

   304:     subprocess.cancel();                                 
   305:     abortController.abort();                             
   306:     const {isCanceled} = await t.throwsAsync(subprocess);

  AbortError: The operation was aborted

  › file://test/kill.js:305:19

  Unhandled rejection in test/kill.js

  Error: Timed out

  › timeoutKill (file://lib/kill.js:60:23)
  › Timeout.<anonymous> (file://lib/kill.js:72:4)

  ✔ node › node's forked script has a communication channel (518ms)
  ✖ override-promise › should work with third-party Promise Rejected promise returned by test
  ✔ promise › promise methods are not enumerable
  ✖ promise › finally function is executed on success Rejected promise returned by test
  ✖ promise › finally function is executed on failure Rejected promise returned by test
  ✖ promise › throw in finally function bubbles up on success Rejected promise returned by test
  ✖ promise › throw in finally bubbles up on error Rejected promise returned by test
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✖ stream › result.all shows both `stdout` and `stderr` intermixed Rejected promise returned by test
  ✖ stream › buffer: false > promise does not resolve when output is big and is not read 
  ✖ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read 
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.3s)
  ✔ stream › input option can be a String - sync (824ms)
  ✔ stream › input option can be a Buffer - sync (516ms)
  ✔ stream › helpful error trying to provide an input stream in sync mode (351ms)
  ✖ stream › buffer Rejected promise returned by test
  ✖ stream › pass `stdout` to a file descriptor Rejected promise returned by test
  ✖ stream › pass `stderr` to a file descriptor Rejected promise returned by test
  ✖ stream › result.all is undefined unless opts.all is true Rejected promise returned by test
  ✖ stream › stdout/stderr/all are undefined if ignored Rejected promise returned by test
  ✖ stream › input option can be a String Rejected promise returned by test
  ✖ stream › input option can be a Buffer Rejected promise returned by test
  ✖ stream › input can be a Stream Rejected promise returned by test
  ✖ stream › you can write to child.stdin Rejected promise returned by test
  ✖ stream › opts.stdout:ignore - stdout will not collect data Rejected promise returned by test
  ✖ stream › do not buffer stdout when `buffer` set to `false` Rejected promise returned by test
  ✖ stream › do not buffer stderr when `buffer` set to `false` Rejected promise returned by test
  ✖ stream › buffer: false > promise resolves 
  ✖ stream › buffer: false > promise resolves when output is big but is not pipable 
  ✖ stream › buffer: false > promise resolves when output is big and is read 
  ✖ stream › buffer: false > promise resolves when output is big and "all" is used and is read 
  ✖ stream › can use all: true with stdout: ignore 
  ✖ stream › can use all: true with stderr: ignore 
  ✖ stream › buffer: false > promise rejects when process returns non-zero 
  ✖ stream › maxBuffer affects stdout 
  ✖ stream › maxBuffer affects stderr 
  ✔ stream › do not buffer when streaming (809ms)

  Unhandled rejection in test/stream.js

  Error: Timed out

  › timeoutKill (file://lib/kill.js:60:23)
  › Timeout.<anonymous> (file://lib/kill.js:72:4)

  Unhandled rejection in test/stream.js

  Error: Timed out

  › timeoutKill (file://lib/kill.js:60:23)
  › Timeout.<anonymous> (file://lib/kill.js:72:4)

  ✔ test › execaSync() (1s)
  ✔ test › execaSync() throws error if written to stderr (959ms)
  ✔ test › skip throwing when using reject option in sync mode (946ms)
  ✔ test › stripFinalNewline in sync mode (811ms)
  ✔ test › stripFinalNewline in sync mode on failure (596ms)
  ✔ test › execa() returns a promise with pid (461ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (453ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (421ms)
  ✖ test › execa() Rejected promise returned by test
  ✖ test › skip throwing when using reject option Rejected promise returned by test
  ✖ test › stripFinalNewline: true Rejected promise returned by test
  ✖ test › stripFinalNewline: false Rejected promise returned by test
  ✖ test › localDir option Rejected promise returned by test
  ✖ test › do not try to consume streams twice Rejected promise returned by test
  ✖ test › use relative path with '..' chars Rejected promise returned by test
  ✖ test › write to fast-exit process 
  ✖ test › use environment variables by default Rejected promise returned by test
  ✖ test › extend environment variables by default Rejected promise returned by test
  ✖ test › do not extend environment with `extendEnv: false` Rejected promise returned by test
  ✖ test › can use `options.cwd` as a string Rejected promise returned by test
  ✖ test › localDir option can be a URL Rejected promise returned by test
  ✖ test › can use `options.cwd` as a URL Rejected promise returned by test
  ✖ test › can use `options.shell: true` Rejected promise returned by test
  ✖ test › can use `options.shell: string` Rejected promise returned by test
  ✖ test › use extend environment with `extendEnv: true` and `shell: true` Rejected promise returned by test
  ✖ test › detach child process Rejected promise returned by test
  ✖ test › preferLocal: true 
  ✖ test › stripFinalNewline on failure 
  ✖ test › preferLocal: false 
  ✖ test › preferLocal: undefined 
  ✖ test › stdin errors are handled 
  ✖ test › child process errors are handled 
  ✖ test › child process errors rejects promise right away 
  ✔ test › execa() rejects if running non-executable (532ms)
  ✖ test › execa() rejects with correct error and doesn't throw if running non-executable with input 
  ✔ test › child_process.spawn() errors are propagated (585ms)
  ✖ test › execPath option Rejected promise returned by test

  Unhandled rejection in test/test.js

  test/test.js:114

   113:   const subprocess = execa('noop.js');               
   114:   subprocess.stdin.emit('error', new Error('test')); 
   115:   await t.throwsAsync(subprocess, {message: /test/});

  Error: test

  › file://test/test.js:114:33

  Unhandled rejection in test/test.js

  test/test.js:120

   119:   const subprocess = execa('noop.js');               
   120:   subprocess.emit('error', new Error('test'));       
   121:   await t.throwsAsync(subprocess, {message: /test/});

  Error: test

  › file://test/test.js:120:27

  Unhandled rejection in test/test.js

  test/test.js:126

   125:   const subprocess = execa('noop.js');               
   126:   subprocess.emit('error', new Error('test'));       
   127:   await t.throwsAsync(subprocess, {message: /test/});

  Error: test

  › file://test/test.js:126:27

  Unhandled rejection in test/test.js

  Error: spawn ava ENOENT

  Unhandled rejection in test/test.js

  Error: spawn ava ENOENT

  Unhandled rejection in test/test.js

  Error: spawn non-executable.js EACCES

  Unhandled rejection in test/test.js

  Error: spawn non-executable.js EACCES

  ─

  error › exitCode is 0 on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  error › failed is false on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  error › result.killed is false if not killed

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  error › result.signal is undefined for successful execution

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  error › result.signalDescription is undefined for successful execution

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  error › error.code is undefined on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  error › stdout/stderr/all available on errors

  test/error.js:17

   16: test('stdout/stderr/all available on errors', async t => {               
   17:   const {stdout, stderr, all} = await t.throwsAsync(execa('exit.js', ['2…
   18:   t.is(typeof stdout, 'string');                                         

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 2/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  error › stdout/stderr/all on process errors

  test/error.js:29

   28:   const {stdout, stderr, all} = await t.throwsAsync(execa('wrong command…
   29:   t.is(stdout, '');                                                      
   30:   t.is(stderr, WRONG_COMMAND);                                           

  Difference:

  - undefined
  + ''

  › file://test/error.js:29:4



  error › exitCode is 2

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 2/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  error › exitCode is 3

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 3/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  error › exitCode is 4

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 4/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  error › error.message contains the command

  test/error.js:58

   57: test('error.message contains the command', async t => {                  
   58:   await t.throwsAsync(execa('exit.js', ['2', 'foo', 'bar']), {message: /…
   59: });                                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /exit.js 2 foo bar/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  error › error.message contains stdout/stderr if available

  test/error.js:63

   62:   const {message} = await t.throwsAsync(execa('echo-fail.js'));
   63:   t.true(message.includes('stderr'));                          
   64:   t.true(message.includes('stdout'));                          

  Value is not `true`:

  false

  › file://test/error.js:63:8



  error › error.shortMessage does not contain stdout/stderr

  test/error.js:75

   74:   const {shortMessage} = await t.throwsAsync(execa('echo-fail.js'));
   75:   t.false(shortMessage.includes('stderr'));                         
   76:   t.false(shortMessage.includes('stdout'));                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'Cannot read properties of undefined (reading \'includes\')',
  }

  › file://test/error.js:75:23



  error › failed is true on failure

  test/error.js:91

   90:   const {failed} = await t.throwsAsync(execa('exit.js', ['2']));
   91:   t.true(failed);                                               
   92: });                                                             

  Value is not `true`:

  undefined

  › file://test/error.js:91:8



  error › error.killed is true if process was killed directly

  test/error.js:99

   98:                                                                          
   99:   const {killed} = await t.throwsAsync(subprocess, {message: /was killed…
   100:   t.true(killed);                                                        

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGTERM/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  error › error.killed is false if process was killed indirectly

  test/error.js:110

   109:   const message = process.platform === 'win32' ? /failed with exit code…
   110:   const {killed} = await t.throwsAsync(subprocess, {message});          
   111:   t.false(killed);                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGINT/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  error › result.killed is false on process error

  test/error.js:126

   125:   const {killed} = await t.throwsAsync(execa('wrong command'));
   126:   t.false(killed);                                             
   127: });                                                            

  Value is not `false`:

  undefined

  › file://test/error.js:126:9



  error › error.signal is SIGINT

  test/error.js:154

   153:                                                                         
   154:     const {signal} = await t.throwsAsync(subprocess, {message: /was kil…
   155:     t.is(signal, 'SIGINT');                                             

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGINT/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  error › error.signalDescription is defined

  test/error.js:163

   162:                                                                         
   163:     const {signalDescription} = await t.throwsAsync(subprocess, {messag…
   164:     t.is(signalDescription, 'User interruption with CTRL-C');           

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /User interruption with CTRL-C/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  error › error.signal is SIGTERM

  test/error.js:172

   171:                                                                         
   172:     const {signal} = await t.throwsAsync(subprocess, {message: /was kil…
   173:     t.is(signal, 'SIGTERM');                                            

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGTERM/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  error › custom error.signal

  test/error.js:178

   177:     const {signal} = await t.throwsAsync(execa('noop.js', {killSignal: …
   178:     t.is(signal, 'SIGHUP');                                             
   179:   });                                                                   

  Difference:

  - undefined
  + 'SIGHUP'

  › file://test/error.js:178:5



  error › result.signal is undefined if process failed, but was not killed

  test/error.js:197

   196: test('result.signal is undefined if process failed, but was not killed'…
   197:   const {signal} = await t.throwsAsync(execa('exit.js', [2]), {message:…
   198:   t.is(signal, undefined);                                              

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 2/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  command › allow commands with spaces and no array arguments

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  command › allow commands with spaces and array arguments

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  command › execaCommand()

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  command › execaCommand() ignores consecutive spaces

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  command › execaCommand() allows escaping spaces in commands

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  command › execaCommand() allows escaping spaces in arguments

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  command › execaCommand() escapes other whitespaces

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  command › execaCommand() trims

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  command › command is: " foo bar"

  test/command.js:9

   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                
   10:                                                                           

  Difference:

  - undefined
  + 'fail.js foo bar'

  › command (file://test/command.js:9:4)



  command › command is: " baz quz"

  test/command.js:9

   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                
   10:                                                                           

  Difference:

  - undefined
  + 'fail.js baz quz'

  › command (file://test/command.js:9:4)



  command › command is: ""

  test/command.js:9

   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                
   10:                                                                           

  Difference:

  - undefined
  + 'fail.js'

  › command (file://test/command.js:9:4)



  command › escapedCommand is: "foo bar"

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js foo bar'

  › testEscapedCommand (file://test/command.js:23:4)



  command › escapedCommand is: "\"foo bar\""

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js "foo bar"'

  › testEscapedCommand (file://test/command.js:23:4)



  command › escapedCommand is: "\"\\\"foo\\\"\""

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js "\\"foo\\""'

  › testEscapedCommand (file://test/command.js:23:4)



  command › escapedCommand is: "\"*\""

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js "*"'

  › testEscapedCommand (file://test/command.js:23:4)



  node › node removes --inspect from nodeOptions when defined by parent process

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  node › node removes --inspect=9222 from nodeOptions when defined by parent process

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  kill › timeout does not kill the process if it does not time out

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  kill › timedOut is false if timeout is undefined

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  kill › timedOut is false if timeout is 0

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  kill › result.isCanceled is false when spawned.cancel() isn't called (success)

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  kill › calling cancel method on a successfully completed process does not make result.isCanceled true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  kill › calling abort on a successfully completed process does not make result.isCanceled true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  kill › spawnAndExit

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › spawnAndExit cleanup

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › spawnAndExit detached

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › spawnAndExit cleanup detached

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  node › node removes --inspect-brk from nodeOptions when defined by parent process

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  kill › timeout kills the process if it times out

  test/kill.js:84

   83: test('timeout kills the process if it times out', async t => {           
   84:   const {killed, timedOut} = await t.throwsAsync(execa('noop.js', {timeo…
   85:   t.false(killed);                                                       

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /timed out after/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  kill › result.isCanceled is false when spawned.cancel() isn't called (failure)

  test/kill.js:207

   206:   const {isCanceled} = await t.throwsAsync(execa('fail.js'));
   207:   t.false(isCanceled);                                       
   208: });                                                          

  Value is not `false`:

  undefined

  › file://test/kill.js:207:9



  kill › calling cancel method throws an error with message "Command was canceled"

  test/kill.js:225

   224:   subprocess.cancel();                                               
   225:   await t.throwsAsync(subprocess, {message: /Command was canceled/});
   226: });                                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /Command was canceled/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  kill › error.isCanceled is true when cancel method is used

  test/kill.js:232

   231:   const {isCanceled} = await t.throwsAsync(subprocess);
   232:   t.true(isCanceled);                                  
   233: });                                                    

  Value is not `true`:

  undefined

  › file://test/kill.js:232:8



  kill › error.isCanceled is false when kill method is used

  test/kill.js:239

   238:   const {isCanceled} = await t.throwsAsync(subprocess);
   239:   t.false(isCanceled);                                 
   240: });                                                    

  Value is not `false`:

  undefined

  › file://test/kill.js:239:9



  kill › calling cancel method twice should show the same behaviour as calling it once

  test/kill.js:247

   246:   const {isCanceled} = await t.throwsAsync(subprocess);
   247:   t.true(isCanceled);                                  
   248:   t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:247:8



  kill › calling cancel method on a process which has been killed does not make error.isCanceled true

  test/kill.js:262

   261:   const {isCanceled} = await t.throwsAsync(subprocess);
   262:   t.false(isCanceled);                                 
   263: });                                                    

  Value is not `false`:

  undefined

  › file://test/kill.js:262:9



  kill › calling abort throws an error with message "Command was canceled"

  test/kill.js:270

   269:     abortController.abort();                                           
   270:     await t.throwsAsync(subprocess, {message: /Command was canceled/});
   271:   });                                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /Command was canceled/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  kill › calling abort twice should show the same behaviour as calling it once

  test/kill.js:279

   278:     const {isCanceled} = await t.throwsAsync(subprocess);
   279:     t.true(isCanceled);                                  
   280:     t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:279:9



  kill › calling cancel after abort should show the same behaviour as only calling cancel

  test/kill.js:297

   296:     const {isCanceled} = await t.throwsAsync(subprocess);
   297:     t.true(isCanceled);                                  
   298:     t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:297:9



  kill › calling abort after cancel should show the same behaviour as only calling cancel

  test/kill.js:307

   306:     const {isCanceled} = await t.throwsAsync(subprocess);
   307:     t.true(isCanceled);                                  
   308:     t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:307:9



  node › node should not remove --inspect when passed through nodeOptions

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  kill › kill("SIGKILL") should terminate cleanly

  test/kill.js:19

   18:   const {signal} = await t.throwsAsync(subprocess);
   19:   t.is(signal, 'SIGKILL');                         
   20: });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:19:4



  kill › `forceKillAfterTimeout: number` should kill after a timeout

  test/kill.js:42

   41:     const {signal} = await t.throwsAsync(subprocess);
   42:     t.is(signal, 'SIGKILL');                         
   43:   });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:42:5



  kill › `forceKillAfterTimeout: true` should kill after a timeout

  test/kill.js:52

   51:     const {signal} = await t.throwsAsync(subprocess);
   52:     t.is(signal, 'SIGKILL');                         
   53:   });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:52:5



  kill › kill() with no arguments should kill after a timeout

  test/kill.js:62

   61:     const {signal} = await t.throwsAsync(subprocess);
   62:     t.is(signal, 'SIGKILL');                         
   63:   });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:62:5



  node › node()

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  node › node pipe stdout

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  node › node correctly use nodePath

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  node › node pass on nodeOptions

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  kill › spawnAndKill SIGTERM

  test/kill.js:153

   152:                                      
   153:   t.false(isRunning(subprocess.pid));
   154:   t.is(isRunning(pid), !isKilled);   

  Value is not `false`:

  true

  › spawnAndKill (file://test/kill.js:153:9)



  kill › spawnAndKill SIGKILL

  test/kill.js:153

   152:                                      
   153:   t.false(isRunning(subprocess.pid));
   154:   t.is(isRunning(pid), !isKilled);   

  Value is not `false`:

  true

  › spawnAndKill (file://test/kill.js:153:9)



  kill › spawnAndKill cleanup SIGTERM

  test/kill.js:153

   152:                                      
   153:   t.false(isRunning(subprocess.pid));
   154:   t.is(isRunning(pid), !isKilled);   

  Value is not `false`:

  true

  › spawnAndKill (file://test/kill.js:153:9)



  kill › spawnAndKill cleanup SIGKILL

  test/kill.js:153

   152:                                      
   153:   t.false(isRunning(subprocess.pid));
   154:   t.is(isRunning(pid), !isKilled);   

  Value is not `false`:

  true

  › spawnAndKill (file://test/kill.js:153:9)



  kill › spawnAndKill detached SIGTERM

  test/kill.js:153

   152:                                      
   153:   t.false(isRunning(subprocess.pid));
   154:   t.is(isRunning(pid), !isKilled);   

  Value is not `false`:

  true

  › spawnAndKill (file://test/kill.js:153:9)



  kill › spawnAndKill detached SIGKILL

  test/kill.js:153

   152:                                      
   153:   t.false(isRunning(subprocess.pid));
   154:   t.is(isRunning(pid), !isKilled);   

  Value is not `false`:

  true

  › spawnAndKill (file://test/kill.js:153:9)



  kill › spawnAndKill cleanup detached SIGTERM

  test/kill.js:153

   152:                                      
   153:   t.false(isRunning(subprocess.pid));
   154:   t.is(isRunning(pid), !isKilled);   

  Value is not `false`:

  true

  › spawnAndKill (file://test/kill.js:153:9)



  kill › spawnAndKill cleanup detached SIGKILL

  test/kill.js:153

   152:                                      
   153:   t.false(isRunning(subprocess.pid));
   154:   t.is(isRunning(pid), !isKilled);   

  Value is not `false`:

  true

  › spawnAndKill (file://test/kill.js:153:9)



  override-promise › should work with third-party Promise

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  promise › finally function is executed on success

  test/promise.js:16

   15:   let isCalled = false;                                           
   16:   const {stdout} = await execa('noop.js', ['foo']).finally(() => {
   17:     isCalled = true;                                              

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)
  › file://test/promise.js:16:58



  promise › finally function is executed on failure

  test/promise.js:25

   24:   let isError = false;                                                   
   25:   const {stdout, stderr} = await t.throwsAsync(execa('exit.js', ['2']).f…
   26:     isError = true;                                                      

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)
  › file://test/promise.js:25:78



  promise › throw in finally function bubbles up on success

  test/promise.js:34

   33: test('throw in finally function bubbles up on success', async t => {     
   34:   const {message} = await t.throwsAsync(execa('noop.js', ['foo']).finall…
   35:     throw new Error('called');                                           

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)
  › file://test/promise.js:34:73



  promise › throw in finally bubbles up on error

  test/promise.js:41

   40: test('throw in finally bubbles up on error', async t => {                
   41:   const {message} = await t.throwsAsync(execa('exit.js', ['2']).finally(…
   42:     throw new Error('called');                                           

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)
  › file://test/promise.js:41:71



  stream › result.all shows both `stdout` and `stderr` intermixed

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  stream › buffer: false > promise does not resolve when output is big and is not read

  test/stream.js:190

   189:     const {timedOut} = await t.throwsAsync(execa('max-buffer.js', {buff…
   190:     t.true(timedOut);                                                   
   191:   });                                                                   

  Value is not `true`:

  undefined

  › file://test/stream.js:190:9



  stream › buffer: false > promise does not resolve when output is big and "all" is used but not read

  test/stream.js:198

   197:     const {timedOut} = await t.throwsAsync(subprocess);
   198:     t.true(timedOut);                                  
   199:   });                                                  

  Value is not `true`:

  undefined

  › file://test/stream.js:198:9



  stream › buffer

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  stream › pass `stdout` to a file descriptor

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  stream › pass `stderr` to a file descriptor

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  stream › result.all is undefined unless opts.all is true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  stream › stdout/stderr/all are undefined if ignored

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  stream › input option can be a String

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  stream › input option can be a Buffer

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  stream › input can be a Stream

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  stream › you can write to child.stdin

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  stream › opts.stdout:ignore - stdout will not collect data

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  stream › do not buffer stdout when `buffer` set to `false`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  stream › do not buffer stderr when `buffer` set to `false`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  stream › buffer: false > promise resolves

  test/stream.js:150

   149: test('buffer: false > promise resolves', async t => {       
   150:   await t.notThrowsAsync(execa('noop.js', {buffer: false}));
   151: });                                                         

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/stream.js:150:10



  stream › buffer: false > promise resolves when output is big but is not pipable

  test/stream.js:154

   153: test('buffer: false > promise resolves when output is big but is not pi…
   154:   await t.notThrowsAsync(execa('max-buffer.js', {buffer: false, stdout:…
   155: });                                                                     

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/stream.js:154:10



  stream › buffer: false > promise resolves when output is big and is read

  test/stream.js:161

   160:   subprocess.stderr.resume();        
   161:   await t.notThrowsAsync(subprocess);
   162: });                                  

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/stream.js:161:10



  stream › buffer: false > promise resolves when output is big and "all" is used and is read

  test/stream.js:167

   166:   subprocess.all.resume();           
   167:   await t.notThrowsAsync(subprocess);
   168: });                                  

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/stream.js:167:10



  stream › can use all: true with stdout: ignore

  test/stream.js:177

   176: test('can use all: true with stdout: ignore', async t => {              
   177:   await t.notThrowsAsync(execa('max-buffer.js', {buffer: false, stdout:…
   178: });                                                                     

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/stream.js:177:10



  stream › can use all: true with stderr: ignore

  test/stream.js:181

   180: test('can use all: true with stderr: ignore', async t => {              
   181:   await t.notThrowsAsync(execa('max-buffer.js', ['stderr'], {buffer: fa…
   182: });                                                                     

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/stream.js:181:10



  stream › buffer: false > promise rejects when process returns non-zero

  test/stream.js:173

   172:   const {exitCode} = await t.throwsAsync(subprocess);
   173:   t.is(exitCode, 2);                                 
   174: });                                                  

  Difference:

  - undefined
  + 2

  › file://test/stream.js:173:4



  stream › maxBuffer affects stdout

  test/stream.js:108

   107: test('maxBuffer affects stdout', async t => {                           
   108:   await t.notThrowsAsync(execa('max-buffer.js', ['stdout', '10'], {maxB…
   109:   const {stdout, all} = await t.throwsAsync(execa('max-buffer.js', ['st…

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/stream.js:108:10



  stream › maxBuffer affects stderr

  test/stream.js:115

   114: test('maxBuffer affects stderr', async t => {                           
   115:   await t.notThrowsAsync(execa('max-buffer.js', ['stderr', '10'], {maxB…
   116:   const {stderr, all} = await t.throwsAsync(execa('max-buffer.js', ['st…

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/stream.js:115:10



  test › execa()

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › skip throwing when using reject option

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › stripFinalNewline: true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › stripFinalNewline: false

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › localDir option

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › do not try to consume streams twice

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › use relative path with '..' chars

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › write to fast-exit process

  test/test.js:189

   188:     } catch (error) {           
   189:       t.is(error.code, 'EPIPE');
   190:     }                           

  Difference:

  - undefined
  + 'EPIPE'

  › file://test/test.js:189:6



  test › use environment variables by default

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › extend environment variables by default

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › do not extend environment with `extendEnv: false`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › can use `options.cwd` as a string

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › localDir option can be a URL

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › can use `options.cwd` as a URL

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › can use `options.shell: true`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › can use `options.shell: string`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › use extend environment with `extendEnv: true` and `shell: true`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › detach child process

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › preferLocal: true

  test/test.js:88

   87: test('preferLocal: true', async t => {                                   
   88:   await t.notThrowsAsync(execa('ava', ['--version'], {preferLocal: true,…
   89: });                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/test.js:88:10



  test › stripFinalNewline on failure

  test/test.js:65

   64:   const {stderr} = await t.throwsAsync(execa('noop-throw.js', ['foo'], {…
   65:   t.is(stderr, 'foo');                                                   
   66: });                                                                      

  Difference:

  - undefined
  + 'foo'

  › file://test/test.js:65:4



  test › preferLocal: false

  test/test.js:92

   91: test('preferLocal: false', async t => {                                  
   92:   await t.throwsAsync(execa('ava', ['--version'], {preferLocal: false, e…
   93: });                                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /spawn.* ENOENT/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › preferLocal: undefined

  test/test.js:96

   95: test('preferLocal: undefined', async t => {                              
   96:   await t.throwsAsync(execa('ava', ['--version'], {env: getPathWithoutLo…
   97: });                                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /spawn.* ENOENT/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › stdin errors are handled

  test/test.js:115

   114:   subprocess.stdin.emit('error', new Error('test')); 
   115:   await t.throwsAsync(subprocess, {message: /test/});
   116: });                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /test/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › child process errors are handled

  test/test.js:121

   120:   subprocess.emit('error', new Error('test'));       
   121:   await t.throwsAsync(subprocess, {message: /test/});
   122: });                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /test/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › child process errors rejects promise right away

  test/test.js:127

   126:   subprocess.emit('error', new Error('test'));       
   127:   await t.throwsAsync(subprocess, {message: /test/});
   128: });                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /test/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › execa() rejects with correct error and doesn't throw if running non-executable with input

  test/test.js:177

   176:   test('execa() rejects with correct error and doesn\'t throw if runnin…
   177:     await t.throwsAsync(execa('non-executable.js', {input: 'Hey!'}), {m…
   178:   });                                                                   

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /EACCES/

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)



  test › execPath option

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › handlePromise (file://node_modules/onetime/index.js:15:9)
  › ChildProcess.<anonymous> (file://lib/promise.js:12:51)

  ─

  136 tests failed
  16 unhandled rejections
-------------|---------|----------|---------|---------|------------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s      
-------------|---------|----------|---------|---------|------------------------
All files    |   86.93 |    96.25 |   89.18 |   86.93 |                        
 execa       |   83.14 |     92.5 |   88.88 |   83.14 |                        
  index.js   |   83.14 |     92.5 |   88.88 |   83.14 | 55-57,71-72,113-152    
 execa/lib   |   89.47 |    97.27 |   89.28 |   89.47 |                        
  command.js |     100 |      100 |     100 |     100 |                        
  error.js   |   90.58 |    85.71 |     100 |   90.58 | 9-10,17-18,23-24,76-77 
  kill.js    |     100 |      100 |     100 |     100 |                        
  promise.js |     100 |      100 |     100 |     100 |                        
  stdio.js   |     100 |      100 |     100 |     100 |                        
  stream.js  |   60.46 |      100 |      50 |   60.46 | 39-49,53-61,66-79      
-------------|---------|----------|---------|---------|------------------------
./Variants/execa/variant7/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/error.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  Uncaught exception in test/command.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/error.js exited with a non-zero exit code: 1
  ✖ test/command.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  Uncaught exception in test/node.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/kill.js exited with a non-zero exit code: 1
  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/promise.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  Uncaught exception in test/override-promise.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/promise.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }

  Uncaught exception in test/stream.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › <anonymous> (node_modules/get-node/src/archive/p7z.js:93:18)

  ✖ test/test.js exited with a non-zero exit code: 1

  ✖ Timed out while running tests

  ─

  36 tests passed
  8 uncaught exceptions
-------------|---------|----------|---------|---------|---------------------------------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                           
-------------|---------|----------|---------|---------|---------------------------------------------
All files    |   27.62 |      100 |    8.33 |   27.62 |                                             
 execa       |    13.1 |      100 |       0 |    13.1 |                                             
  index.js   |    13.1 |      100 |       0 |    13.1 | ...2,76-162,165-225,228-230,233-235,238-267 
 execa/lib   |   37.34 |      100 |   10.71 |   37.34 |                                             
  command.js |    43.9 |      100 |       0 |    43.9 | 2-6,13-17,28-40                             
  error.js   |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                  
  kill.js    |   36.27 |      100 |       0 |   36.27 | ...-29,38-46,51-55,59-60,65-80,84-86,91-101 
  promise.js |   36.11 |      100 |       0 |   36.11 | 9-18,23-35                                  
  stdio.js   |     100 |      100 |     100 |     100 |                                             
  stream.js  |   29.06 |      100 |       0 |   29.06 | 7-15,20-34,39-49,53-61,66-79,83-85          
-------------|---------|----------|---------|---------|---------------------------------------------
./Variants/execa/variant6/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✖ command › execaCommandSync() Error thrown in test
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.9s)
  ✖ error › result.killed is false if not killed, in sync mode Error thrown in test
  ✔ error › result.killed is false on process error, in sync mode (132ms)
  ✔ error › Original error.message is kept (1.7s)
  ✔ error › error.code is defined on failure if applicable (111ms)
  ✖ error › result.killed is false on process error 
  ✖ error › stdout/stderr/all on process errors 
  ✖ error › stdout/stderr/all available on errors 
  ✖ error › exitCode is 0 on success Rejected promise returned by test
  ✖ error › exitCode is 2 
  ✖ error › exitCode is 3 
  ✖ error › exitCode is 4 
  ✖ error › error.message contains the command 
  ✖ error › error.message contains stdout/stderr if available 
  ✔ error › error.message does not contain stdout/stderr if not available (2.1s)
  ✖ error › error.shortMessage does not contain stdout/stderr Rejected promise returned by test
  ✖ error › failed is false on success Rejected promise returned by test
  ✖ error › failed is true on failure 
  ✖ error › error.killed is true if process was killed directly 
  ✖ error › error.killed is false if process was killed indirectly 
  ✖ error › result.killed is false if not killed Rejected promise returned by test
  ✖ error › error.signal is SIGINT 
  ✖ error › error.signalDescription is defined 
  ✖ error › error.signal is SIGTERM 
  ✔ error › exitCode is undefined on signal termination (530ms)
  ✖ error › custom error.signal 
  ✖ error › result.signal is undefined if process failed, but was not killed 
  ✖ error › result.signalDescription is undefined for successful execution Rejected promise returned by test
  ✖ error › result.signal is undefined for successful execution Rejected promise returned by test
  ✖ error › error.code is undefined on success Rejected promise returned by test
  ✖ command › allow commands with spaces and no array arguments Rejected promise returned by test
  ✖ command › allow commands with spaces and array arguments Rejected promise returned by test
  ✖ command › execaCommand() Rejected promise returned by test
  ✖ command › execaCommand() ignores consecutive spaces Rejected promise returned by test
  ✖ command › execaCommand() allows escaping spaces in commands Rejected promise returned by test
  ✖ command › execaCommand() allows escaping spaces in arguments Rejected promise returned by test
  ✖ command › execaCommand() escapes other whitespaces Rejected promise returned by test
  ✖ command › execaCommand() trims Rejected promise returned by test
  ✖ command › command is: " foo bar" 
  ✖ command › command is: " baz quz" 
  ✖ command › command is: "" 
  ✖ command › escapedCommand is: "foo bar" 
  ✖ command › escapedCommand is: "\"foo bar\"" 
  ✖ command › escapedCommand is: "\"\\\"foo\\\"\"" 
  ✖ command › escapedCommand is: "\"*\"" 
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.1s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.1s)
  ✔ kill › execa() returns a promise with kill() (3.1s)
  ✖ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode Error thrown in test
  ✔ kill › cancel method kills the subprocess (2.3s)
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) Error thrown in test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) 
  ✖ kill › timeout kills the process if it times out, in sync mode 
  ✔ kill › timeout must not be negative (3s)
  ✔ kill › timeout must be an integer (3s)
  ✖ kill › calling abort after cancel should show the same behaviour as only calling cancel 
  ✖ kill › calling cancel after abort should show the same behaviour as only calling cancel 
  ✖ kill › calling abort twice should show the same behaviour as calling it once 
  ✖ kill › calling abort throws an error with message "Command was canceled" 
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.2s)
  ✖ kill › timeout does not kill the process if it does not time out Rejected promise returned by test
  ✖ kill › timedOut is false if timeout is undefined Rejected promise returned by test
  ✖ kill › timedOut is false if timeout is 0 Rejected promise returned by test
  ✖ kill › spawnAndExit 
  ✖ kill › spawnAndExit cleanup 
  ✖ kill › spawnAndExit detached 
  ✖ kill › spawnAndExit cleanup detached 
  ✔ kill › spawnAndKill SIGTERM (2.7s)
  ✔ kill › spawnAndKill SIGKILL (2.6s)
  ✔ kill › spawnAndKill detached SIGKILL (2.6s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.5s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.5s)
  ✔ kill › removes exit handler on exit (2.5s)
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called (success) Rejected promise returned by test
  ✖ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) 
  ✖ kill › calling cancel method throws an error with message "Command was canceled" 
  ✖ kill › error.isCanceled is true when cancel method is used 
  ✖ kill › error.isCanceled is false when kill method is used 
  ✖ kill › calling cancel method twice should show the same behaviour as calling it once 
  ✖ kill › calling cancel method on a successfully completed process does not make result.isCanceled true Rejected promise returned by test
  ✖ kill › calling cancel method on a process which has been killed does not make error.isCanceled true 
  ✔ kill › spawnAndKill cleanup SIGTERM (2.7s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.6s)
  ✔ kill › spawnAndKill detached SIGTERM (2.6s)
  ✖ kill › timeout kills the process if it times out 
  ✖ kill › kill("SIGKILL") should terminate cleanly 
  ✖ kill › `forceKillAfterTimeout: number` should kill after a timeout 
  ✖ kill › calling abort on a successfully completed process does not make result.isCanceled true Rejected promise returned by test
  ✖ node › node removes --inspect from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect=9222 from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect-brk from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process Rejected promise returned by test
  ✖ node › node should not remove --inspect when passed through nodeOptions Rejected promise returned by test
  ✖ node › node correctly use nodePath Rejected promise returned by test
  ✖ node › node() Rejected promise returned by test
  ✔ node › node's forked script has a communication channel (199ms)
  ✖ node › node pipe stdout Rejected promise returned by test
  ✖ node › node pass on nodeOptions Rejected promise returned by test
  ✖ override-promise › should work with third-party Promise Rejected promise returned by test
  ✔ promise › promise methods are not enumerable
  ✔ promise › throw in finally bubbles up on error (206ms)
  ✖ promise › finally function is executed on failure 
  ✖ promise › finally function is executed on success Rejected promise returned by test
  ✔ promise › throw in finally function bubbles up on success (283ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✖ stream › result.all shows both `stdout` and `stderr` intermixed Rejected promise returned by test
  ✖ kill › `forceKillAfterTimeout: true` should kill after a timeout 
  ✖ kill › kill() with no arguments should kill after a timeout 
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✖ test › execaSync() Error thrown in test
  ✔ test › execaSync() throws error if written to stderr (1.7s)
  ✖ test › skip throwing when using reject option in sync mode Error thrown in test
  ✖ test › stripFinalNewline in sync mode Error thrown in test
  ✖ test › stripFinalNewline in sync mode on failure 
  ✔ test › execa() returns a promise with pid (714ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (683ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (651ms)
  ✔ test › child_process.spawn() errors are propagated (774ms)
  ✖ test › execa() rejects with correct error and doesn't throw if running non-executable with input 
  ✔ test › execa() rejects if running non-executable (807ms)
  ✖ test › preferLocal: undefined 
  ✖ test › preferLocal: false 
  ✖ test › child process errors rejects promise right away 
  ✖ test › child process errors are handled 
  ✖ test › stdin errors are handled 
  ✖ test › execa() Rejected promise returned by test
  ✖ test › skip throwing when using reject option Rejected promise returned by test
  ✖ test › stripFinalNewline: true Rejected promise returned by test
  ✔ test › stripFinalNewline: false (2s)
  ✖ test › stripFinalNewline on failure 
  ✖ test › localDir option Rejected promise returned by test
  ✖ test › do not try to consume streams twice Rejected promise returned by test
  ✖ test › use relative path with '..' chars Rejected promise returned by test
  ✖ test › write to fast-exit process 
  ✖ test › extend environment variables by default Rejected promise returned by test
  ✖ test › localDir option can be a URL Rejected promise returned by test
  ✖ test › use extend environment with `extendEnv: true` and `shell: true` Rejected promise returned by test
  ✖ test › use environment variables by default Rejected promise returned by test
  ✖ test › can use `options.cwd` as a string Rejected promise returned by test
  ✖ test › can use `options.cwd` as a URL Rejected promise returned by test
  ✖ test › do not extend environment with `extendEnv: false` Rejected promise returned by test
  ✖ test › can use `options.shell: true` Rejected promise returned by test
  ✖ test › can use `options.shell: string` Rejected promise returned by test
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (2.5s)
  ✖ stream › input option can be a String - sync Error thrown in test
  ✖ stream › input option can be a Buffer - sync Error thrown in test
  ✔ stream › helpful error trying to provide an input stream in sync mode (529ms)
  ✖ stream › buffer Rejected promise returned by test
  ✖ stream › pass `stdout` to a file descriptor Rejected promise returned by test
  ✖ stream › pass `stderr` to a file descriptor Rejected promise returned by test
  ✖ stream › result.all is undefined unless opts.all is true Rejected promise returned by test
  ✔ stream › stdout/stderr/all are undefined if ignored (2.6s)
  ✖ stream › input option can be a Buffer Rejected promise returned by test
  ✖ stream › input option can be a String Rejected promise returned by test
  ✖ stream › input can be a Stream Rejected promise returned by test
  ✖ stream › you can write to child.stdin Rejected promise returned by test
  ✖ stream › opts.stdout:ignore - stdout will not collect data Rejected promise returned by test
  ✖ test › detach child process Rejected promise returned by test
  ✔ stream › do not buffer stdout when `buffer` set to `false` (1s)
  ✔ stream › do not buffer when streaming (989ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (1s)
  ✔ stream › buffer: false > promise resolves (1s)
  ✖ test › execPath option Rejected promise returned by test
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (950ms)
  ✔ stream › can use all: true with stdout: ignore (976ms)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.1s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1s)
  ✖ stream › maxBuffer affects stderr 
  ✖ stream › maxBuffer affects stdout 
  ✔ stream › can use all: true with stderr: ignore (996ms)
  ✖ test › preferLocal: true 
  ─

  command › execaCommandSync()

  test/command.js:85

   84: test('execaCommandSync()', t => {                                        
   85:   const {stdout} = execaCommandSync('node test/fixtures/echo.js foo bar'…
   86:   t.is(stdout, 'foo\nbar');                                              

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › execaCommandSync (file://index.js:234:9)
  › file://test/command.js:85:19



  error › result.killed is false if not killed, in sync mode

  test/error.js:120

   119: test('result.killed is false if not killed, in sync mode', t => {
   120:   const {killed} = execaSync('noop.js');                         
   121:   t.false(killed);                                               

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/error.js:120:19



  error › result.killed is false on process error

  test/error.js:126

   125:   const {killed} = await t.throwsAsync(execa('wrong command'));
   126:   t.false(killed);                                             
   127: });                                                            

  Value is not `false`:

  undefined

  › file://test/error.js:126:9



  error › stdout/stderr/all on process errors

  test/error.js:29

   28:   const {stdout, stderr, all} = await t.throwsAsync(execa('wrong command…
   29:   t.is(stdout, '');                                                      
   30:   t.is(stderr, WRONG_COMMAND);                                           

  Difference:

  - undefined
  + ''

  › file://test/error.js:29:4



  error › stdout/stderr/all available on errors

  test/error.js:17

   16: test('stdout/stderr/all available on errors', async t => {               
   17:   const {stdout, stderr, all} = await t.throwsAsync(execa('exit.js', ['2…
   18:   t.is(typeof stdout, 'string');                                         

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 2/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › exitCode is 0 on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:44:21



  error › exitCode is 2

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 2/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › exitCode is 3

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 3/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › exitCode is 4

  test/error.js:49

   48: const testExitCode = async (t, number) => {                              
   49:   const {exitCode} = await t.throwsAsync(execa('exit.js', [`${number}`])…
   50:   t.is(exitCode, number);                                                

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 4/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.message contains the command

  test/error.js:58

   57: test('error.message contains the command', async t => {                  
   58:   await t.throwsAsync(execa('exit.js', ['2', 'foo', 'bar']), {message: /…
   59: });                                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /exit.js 2 foo bar/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.message contains stdout/stderr if available

  test/error.js:63

   62:   const {message} = await t.throwsAsync(execa('echo-fail.js'));
   63:   t.true(message.includes('stderr'));                          
   64:   t.true(message.includes('stdout'));                          

  Value is not `true`:

  false

  › file://test/error.js:63:8



  error › error.shortMessage does not contain stdout/stderr

  test/error.js:75

   74:   const {shortMessage} = await t.throwsAsync(execa('echo-fail.js'));
   75:   t.false(shortMessage.includes('stderr'));                         
   76:   t.false(shortMessage.includes('stdout'));                         

  Rejected promise returned by test. Reason:

  TypeError {
    message: 'Cannot read properties of undefined (reading \'includes\')',
  }

  › file://test/error.js:75:23



  error › failed is false on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:85:19



  error › failed is true on failure

  test/error.js:91

   90:   const {failed} = await t.throwsAsync(execa('exit.js', ['2']));
   91:   t.true(failed);                                               
   92: });                                                             

  Value is not `true`:

  undefined

  › file://test/error.js:91:8



  error › error.killed is true if process was killed directly

  test/error.js:99

   98:                                                                          
   99:   const {killed} = await t.throwsAsync(subprocess, {message: /was killed…
   100:   t.true(killed);                                                        

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGTERM/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.killed is false if process was killed indirectly

  test/error.js:110

   109:   const message = process.platform === 'win32' ? /failed with exit code…
   110:   const {killed} = await t.throwsAsync(subprocess, {message});          
   111:   t.false(killed);                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGINT/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › result.killed is false if not killed

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:115:19



  error › error.signal is SIGINT

  test/error.js:154

   153:                                                                         
   154:     const {signal} = await t.throwsAsync(subprocess, {message: /was kil…
   155:     t.is(signal, 'SIGINT');                                             

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGINT/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.signalDescription is defined

  test/error.js:163

   162:                                                                         
   163:     const {signalDescription} = await t.throwsAsync(subprocess, {messag…
   164:     t.is(signalDescription, 'User interruption with CTRL-C');           

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /User interruption with CTRL-C/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › error.signal is SIGTERM

  test/error.js:172

   171:                                                                         
   172:     const {signal} = await t.throwsAsync(subprocess, {message: /was kil…
   173:     t.is(signal, 'SIGTERM');                                            

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /was killed with SIGTERM/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › custom error.signal

  test/error.js:178

   177:     const {signal} = await t.throwsAsync(execa('noop.js', {killSignal: …
   178:     t.is(signal, 'SIGHUP');                                             
   179:   });                                                                   

  Difference:

  - undefined
  + 'SIGHUP'

  › file://test/error.js:178:5



  error › result.signal is undefined if process failed, but was not killed

  test/error.js:197

   196: test('result.signal is undefined if process failed, but was not killed'…
   197:   const {signal} = await t.throwsAsync(execa('exit.js', [2]), {message:…
   198:   t.is(signal, undefined);                                              

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /failed with exit code 2/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  error › result.signalDescription is undefined for successful execution

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:202:30



  error › result.signal is undefined for successful execution

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:192:19



  error › error.code is undefined on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/error.js:207:17



  command › allow commands with spaces and no array arguments

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:45:19



  command › allow commands with spaces and array arguments

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:50:19



  command › execaCommand()

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:55:19



  command › execaCommand() ignores consecutive spaces

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:60:19



  command › execaCommand() allows escaping spaces in commands

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:65:19



  command › execaCommand() allows escaping spaces in arguments

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:70:19



  command › execaCommand() escapes other whitespaces

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:75:19



  command › execaCommand() trims

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/command.js:80:19



  command › command is: " foo bar"

  test/command.js:9

   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                
   10:                                                                           

  Difference:

  - undefined
  + 'fail.js foo bar'

  › command (file://test/command.js:9:4)



  command › command is: " baz quz"

  test/command.js:9

   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                
   10:                                                                           

  Difference:

  - undefined
  + 'fail.js baz quz'

  › command (file://test/command.js:9:4)



  command › command is: ""

  test/command.js:9

   8:   const {command: failCommand} = await t.throwsAsync(execa('fail.js', arg…
   9:   t.is(failCommand, `fail.js${expected}`);                                
   10:                                                                           

  Difference:

  - undefined
  + 'fail.js'

  › command (file://test/command.js:9:4)



  command › escapedCommand is: "foo bar"

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js foo bar'

  › testEscapedCommand (file://test/command.js:23:4)



  command › escapedCommand is: "\"foo bar\""

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js "foo bar"'

  › testEscapedCommand (file://test/command.js:23:4)



  command › escapedCommand is: "\"\\\"foo\\\"\""

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js "\\"foo\\""'

  › testEscapedCommand (file://test/command.js:23:4)



  command › escapedCommand is: "\"*\""

  test/command.js:23

   22:   const {escapedCommand: failEscapedCommand} = await t.throwsAsync(execa…
   23:   t.is(failEscapedCommand, `fail.js ${expected}`);                       
   24:                                                                          

  Difference:

  - undefined
  + 'fail.js "*"'

  › testEscapedCommand (file://test/command.js:23:4)



  kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode

  test/kill.js:127

   126: test('timedOut is false if timeout is undefined and exit code is 0 in s…
   127:   const {timedOut} = execaSync('noop.js');                              
   128:   t.false(timedOut);                                                    

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/kill.js:127:21



  kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success)

  test/kill.js:211

   210: test('result.isCanceled is false when spawned.cancel() isn\'t called in…
   211:   const {isCanceled} = execaSync('noop.js');                            
   212:   t.false(isCanceled);                                                  

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/kill.js:211:23



  kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure)

  test/kill.js:219

   218:   });                 
   219:   t.false(isCanceled);
   220: });                   

  Value is not `false`:

  undefined

  › file://test/kill.js:219:9



  kill › timeout kills the process if it times out, in sync mode

  test/kill.js:93

   92:   });              
   93:   t.false(killed); 
   94:   t.true(timedOut);

  Value is not `false`:

  undefined

  › file://test/kill.js:93:9



  kill › calling abort after cancel should show the same behaviour as only calling cancel

  test/kill.js:307

   306:     const {isCanceled} = await t.throwsAsync(subprocess);
   307:     t.true(isCanceled);                                  
   308:     t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:307:9



  kill › calling cancel after abort should show the same behaviour as only calling cancel

  test/kill.js:297

   296:     const {isCanceled} = await t.throwsAsync(subprocess);
   297:     t.true(isCanceled);                                  
   298:     t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:297:9



  kill › calling abort twice should show the same behaviour as calling it once

  test/kill.js:279

   278:     const {isCanceled} = await t.throwsAsync(subprocess);
   279:     t.true(isCanceled);                                  
   280:     t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:279:9



  kill › calling abort throws an error with message "Command was canceled"

  test/kill.js:270

   269:     abortController.abort();                                           
   270:     await t.throwsAsync(subprocess, {message: /Command was canceled/});
   271:   });                                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /Command was canceled/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  kill › timeout does not kill the process if it does not time out

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:98:21



  kill › timedOut is false if timeout is undefined

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:117:21



  kill › timedOut is false if timeout is 0

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:122:21



  kill › spawnAndExit

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › spawnAndExit cleanup

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › spawnAndExit detached

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › spawnAndExit cleanup detached

  test/kill.js:133

   132: const spawnAndExit = async (t, cleanup, detached) => {                  
   133:   await t.notThrowsAsync(execa('sub-process-exit.js', [cleanup, detache…
   134: };                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › spawnAndExit (file://test/kill.js:133:10)



  kill › result.isCanceled is false when spawned.cancel() isn't called (success)

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:201:23



  kill › result.isCanceled is false when spawned.cancel() isn't called (failure)

  test/kill.js:207

   206:   const {isCanceled} = await t.throwsAsync(execa('fail.js'));
   207:   t.false(isCanceled);                                       
   208: });                                                          

  Value is not `false`:

  undefined

  › file://test/kill.js:207:9



  kill › calling cancel method throws an error with message "Command was canceled"

  test/kill.js:225

   224:   subprocess.cancel();                                               
   225:   await t.throwsAsync(subprocess, {message: /Command was canceled/});
   226: });                                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /Command was canceled/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  kill › error.isCanceled is true when cancel method is used

  test/kill.js:232

   231:   const {isCanceled} = await t.throwsAsync(subprocess);
   232:   t.true(isCanceled);                                  
   233: });                                                    

  Value is not `true`:

  undefined

  › file://test/kill.js:232:8



  kill › error.isCanceled is false when kill method is used

  test/kill.js:239

   238:   const {isCanceled} = await t.throwsAsync(subprocess);
   239:   t.false(isCanceled);                                 
   240: });                                                    

  Value is not `false`:

  undefined

  › file://test/kill.js:239:9



  kill › calling cancel method twice should show the same behaviour as calling it once

  test/kill.js:247

   246:   const {isCanceled} = await t.throwsAsync(subprocess);
   247:   t.true(isCanceled);                                  
   248:   t.true(subprocess.killed);                           

  Value is not `true`:

  undefined

  › file://test/kill.js:247:8



  kill › calling cancel method on a successfully completed process does not make result.isCanceled true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:253:23



  kill › calling cancel method on a process which has been killed does not make error.isCanceled true

  test/kill.js:262

   261:   const {isCanceled} = await t.throwsAsync(subprocess);
   262:   t.false(isCanceled);                                 
   263: });                                                    

  Value is not `false`:

  undefined

  › file://test/kill.js:262:9



  kill › timeout kills the process if it times out

  test/kill.js:84

   83: test('timeout kills the process if it times out', async t => {           
   84:   const {killed, timedOut} = await t.throwsAsync(execa('noop.js', {timeo…
   85:   t.false(killed);                                                       

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /timed out after/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  kill › kill("SIGKILL") should terminate cleanly

  test/kill.js:19

   18:   const {signal} = await t.throwsAsync(subprocess);
   19:   t.is(signal, 'SIGKILL');                         
   20: });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:19:4



  kill › `forceKillAfterTimeout: number` should kill after a timeout

  test/kill.js:42

   41:     const {signal} = await t.throwsAsync(subprocess);
   42:     t.is(signal, 'SIGKILL');                         
   43:   });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:42:5



  kill › calling abort on a successfully completed process does not make result.isCanceled true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/kill.js:286:24



  node › node removes --inspect from nodeOptions when defined by parent process

  test/node.js:17

   16:                                               
   17:     const {stdout, stderr} = await subprocess;
   18:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async inspectMacro (file://test/node.js:17:28)



  node › node removes --inspect=9222 from nodeOptions when defined by parent process

  test/node.js:17

   16:                                               
   17:     const {stdout, stderr} = await subprocess;
   18:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async inspectMacro (file://test/node.js:17:28)



  node › node removes --inspect-brk from nodeOptions when defined by parent process

  test/node.js:17

   16:                                               
   17:     const {stdout, stderr} = await subprocess;
   18:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async inspectMacro (file://test/node.js:17:28)



  node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process

  test/node.js:17

   16:                                               
   17:     const {stdout, stderr} = await subprocess;
   18:                                               

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async inspectMacro (file://test/node.js:17:28)



  node › node should not remove --inspect when passed through nodeOptions

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:85:28



  node › node correctly use nodePath

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:40:19



  node › node()

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:27:21



  node › node pipe stdout

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:32:19



  node › node pass on nodeOptions

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/node.js:50:19



  override-promise › should work with third-party Promise

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/override-promise.js:12:19



  promise › finally function is executed on failure

  test/promise.js:29

   28:   t.is(isError, true);          
   29:   t.is(typeof stdout, 'string');
   30:   t.is(typeof stderr, 'string');

  Difference:

  - 'undefined'
  + 'string'

  › file://test/promise.js:29:4



  promise › finally function is executed on success

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/promise.js:16:19



  stream › result.all shows both `stdout` and `stderr` intermixed

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:32:16



  kill › `forceKillAfterTimeout: true` should kill after a timeout

  test/kill.js:52

   51:     const {signal} = await t.throwsAsync(subprocess);
   52:     t.is(signal, 'SIGKILL');                         
   53:   });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:52:5



  kill › kill() with no arguments should kill after a timeout

  test/kill.js:62

   61:     const {signal} = await t.throwsAsync(subprocess);
   62:     t.is(signal, 'SIGKILL');                         
   63:   });                                                

  Difference:

  - undefined
  + 'SIGKILL'

  › file://test/kill.js:62:5



  test › execaSync()

  test/test.js:33

   32: test('execaSync()', t => {                       
   33:   const {stdout} = execaSync('noop.js', ['foo']);
   34:   t.is(stdout, 'foo');                           

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/test.js:33:19



  test › skip throwing when using reject option in sync mode

  test/test.js:49

   48: test('skip throwing when using reject option in sync mode', t => {
   49:   const {exitCode} = execaSync('fail.js', {reject: false});       
   50:   t.is(exitCode, 2);                                              

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/test.js:49:21



  test › stripFinalNewline in sync mode

  test/test.js:69

   68: test('stripFinalNewline in sync mode', t => {                            
   69:   const {stdout} = execaSync('noop.js', ['foo'], {stripFinalNewline: tru…
   70:   t.is(stdout, 'foo');                                                   

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/test.js:69:19



  test › stripFinalNewline in sync mode on failure

  test/test.js:77

   76:   });                 
   77:   t.is(stderr, 'foo');
   78: });                   

  Difference:

  - undefined
  + 'foo'

  › file://test/test.js:77:4



  test › execa() rejects with correct error and doesn't throw if running non-executable with input

  test/test.js:177

   176:   test('execa() rejects with correct error and doesn\'t throw if runnin…
   177:     await t.throwsAsync(execa('non-executable.js', {input: 'Hey!'}), {m…
   178:   });                                                                   

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /EACCES/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › preferLocal: undefined

  test/test.js:96

   95: test('preferLocal: undefined', async t => {                              
   96:   await t.throwsAsync(execa('ava', ['--version'], {env: getPathWithoutLo…
   97: });                                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /spawn.* ENOENT/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › preferLocal: false

  test/test.js:92

   91: test('preferLocal: false', async t => {                                  
   92:   await t.throwsAsync(execa('ava', ['--version'], {preferLocal: false, e…
   93: });                                                                      

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /spawn.* ENOENT/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › child process errors rejects promise right away

  test/test.js:127

   126:   subprocess.emit('error', new Error('test'));       
   127:   await t.throwsAsync(subprocess, {message: /test/});
   128: });                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /test/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › child process errors are handled

  test/test.js:121

   120:   subprocess.emit('error', new Error('test'));       
   121:   await t.throwsAsync(subprocess, {message: /test/});
   122: });                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /test/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › stdin errors are handled

  test/test.js:115

   114:   subprocess.stdin.emit('error', new Error('test')); 
   115:   await t.throwsAsync(subprocess, {message: /test/});
   116: });                                                  

  Promise rejected with unexpected exception:

  ReferenceError {
    message: 'lyx is not defined',
  }

  Expected message to match:

  /test/

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)



  test › execa()

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:16:19



  test › skip throwing when using reject option

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:44:21



  test › stripFinalNewline: true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:54:19



  test › stripFinalNewline on failure

  test/test.js:65

   64:   const {stderr} = await t.throwsAsync(execa('noop-throw.js', ['foo'], {…
   65:   t.is(stderr, 'foo');                                                   
   66: });                                                                      

  Difference:

  - undefined
  + 'foo'

  › file://test/test.js:65:4



  test › localDir option

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:101:19



  test › do not try to consume streams twice

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:158:19



  test › use relative path with '..' chars

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:166:19



  test › write to fast-exit process

  test/test.js:189

   188:     } catch (error) {           
   189:       t.is(error.code, 'EPIPE');
   190:     }                           

  Difference:

  - undefined
  + 'EPIPE'

  › file://test/test.js:189:6



  test › extend environment variables by default

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:200:19



  test › localDir option can be a URL

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:217:19



  test › use extend environment with `extendEnv: true` and `shell: true`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:243:19



  test › use environment variables by default

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:195:19



  test › can use `options.cwd` as a string

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:211:19



  test › can use `options.cwd` as a URL

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:225:19



  test › do not extend environment with `extendEnv: false`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:205:19



  test › can use `options.shell: true`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:230:19



  test › can use `options.shell: string`

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:236:19



  stream › input option can be a String - sync

  test/stream.js:81

   80: test('input option can be a String - sync', t => {          
   81:   const {stdout} = execaSync('stdin.js', {input: 'foobar'});
   82:   t.is(stdout, 'foobar');                                   

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/stream.js:81:19



  stream › input option can be a Buffer - sync

  test/stream.js:86

   85: test('input option can be a Buffer - sync', t => {                       
   86:   const {stdout} = execaSync('stdin.js', {input: Buffer.from('testing12'…
   87:   t.is(stdout, 'testing12');                                             

  Error thrown in test:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › execaSync (file://index.js:189:17)
  › file://test/stream.js:86:19



  stream › buffer

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:14:19



  stream › pass `stdout` to a file descriptor

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:115:18)
  › async file://test/stream.js:21:2



  stream › pass `stderr` to a file descriptor

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:27:2



  stream › result.all is undefined unless opts.all is true

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:37:16



  stream › input option can be a Buffer

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:61:19



  stream › input option can be a String

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:56:19



  stream › input can be a Stream

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:69:19



  stream › you can write to child.stdin

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/stream.js:76:19



  stream › opts.stdout:ignore - stdout will not collect data

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:115:18)
  › async file://test/stream.js:91:19



  test › detach child process

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:249:19



  test › execPath option

  Rejected promise returned by test. Reason:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › stripFinalNewline (file://node_modules/strip-final-newline/index.js:2:5)
  › handleOutput (file://index.js:69:10)
  › handlePromise (file://index.js:114:18)
  › async file://test/test.js:108:19



  stream › maxBuffer affects stderr

  test/stream.js:115

   114: test('maxBuffer affects stderr', async t => {                           
   115:   await t.notThrowsAsync(execa('max-buffer.js', ['stderr', '10'], {maxB…
   116:   const {stderr, all} = await t.throwsAsync(execa('max-buffer.js', ['st…

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/stream.js:115:10



  stream › maxBuffer affects stdout

  test/stream.js:108

   107: test('maxBuffer affects stdout', async t => {                           
   108:   await t.notThrowsAsync(execa('max-buffer.js', ['stdout', '10'], {maxB…
   109:   const {stdout, all} = await t.throwsAsync(execa('max-buffer.js', ['st…

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/stream.js:108:10



  test › preferLocal: true

  test/test.js:88

   87: test('preferLocal: true', async t => {                                   
   88:   await t.notThrowsAsync(execa('ava', ['--version'], {preferLocal: true,…
   89: });                                                                      

  Promise rejected with:

  ReferenceError {
    message: 'lyx is not defined',
  }

  › file://test/test.js:88:10

  ─

  125 tests failed
-------------|---------|----------|---------|---------|-----------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s     
-------------|---------|----------|---------|---------|-----------------------
All files    |   98.04 |    96.13 |     100 |   98.04 |                       
 execa       |   97.37 |    89.58 |     100 |   97.37 |                       
  index.js   |   97.37 |    89.58 |     100 |   97.37 | 55-57,135-136,208-209 
 execa/lib   |   98.49 |    98.11 |     100 |   98.49 |                       
  command.js |     100 |      100 |     100 |     100 |                       
  error.js   |   92.94 |    88.46 |     100 |   92.94 | 9-10,23-24,76-77      
  kill.js    |     100 |      100 |     100 |     100 |                       
  promise.js |     100 |      100 |     100 |     100 |                       
  stdio.js   |     100 |      100 |     100 |     100 |                       
  stream.js  |     100 |      100 |     100 |     100 |                       
-------------|---------|----------|---------|---------|-----------------------
./Variants/execa/variant5/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (1s)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.9s)
  ✔ error › result.killed is false if not killed, in sync mode (1.1s)
  ✔ error › result.killed is false on process error, in sync mode (204ms)
  ✔ error › Original error.message is kept (1.7s)
  ✔ error › error.code is defined on failure if applicable (130ms)
  ✔ error › result.killed is false on process error (423ms)
  ✔ error › stdout/stderr/all on process errors (2.1s)
  ✔ error › stdout/stderr/all available on errors (2.2s)
  ✔ error › exitCode is 0 on success (2.2s)
  ✔ error › exitCode is 2 (2.1s)
  ✔ error › exitCode is 3 (2.1s)
  ✔ error › exitCode is 4 (2.1s)
  ✔ error › error.message contains the command (2.1s)
  ✔ error › error.message contains stdout/stderr if available (2s)
  ✔ error › error.message does not contain stdout/stderr if not available (2s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.9s)
  ✔ error › failed is false on success (1.9s)
  ✔ error › failed is true on failure (1.7s)
  ✔ error › error.killed is true if process was killed directly (1.6s)
  ✔ error › error.killed is false if process was killed indirectly (1.6s)
  ✔ error › result.killed is false if not killed (1.5s)
  ✔ error › error.signal is SIGINT (526ms)
  ✔ error › error.signalDescription is defined (518ms)
  ✔ error › error.signal is SIGTERM (511ms)
  ✔ error › exitCode is undefined on signal termination (483ms)
  ✔ error › custom error.signal (492ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (497ms)
  ✔ error › result.signal is undefined for successful execution (530ms)
  ✔ error › result.signalDescription is undefined for successful execution (542ms)
  ✔ error › error.code is undefined on success (523ms)
  ✔ command › allow commands with spaces and no array arguments (2.8s)
  ✔ command › allow commands with spaces and array arguments (2.8s)
  ✔ command › execaCommand() (2.8s)
  ✔ command › execaCommand() ignores consecutive spaces (2.7s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.5s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.5s)
  ✔ command › execaCommand() escapes other whitespaces (2.5s)
  ✔ command › execaCommand() trims (2.3s)
  ✔ command › command is: " foo bar" (3s)
  ✔ command › command is: " baz quz" (3s)
  ✔ command › command is: "" (3s)
  ✔ command › escapedCommand is: "foo bar" (3.1s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.2s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3.3s)
  ✔ command › escapedCommand is: "\"*\"" (3.8s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.1s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.1s)
  ✔ kill › execa() returns a promise with kill() (3s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.8s)
  ✔ kill › cancel method kills the subprocess (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (980ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (3s)
  ✔ kill › timeout must not be negative (2.9s)
  ✔ kill › timeout must be an integer (2.9s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel
  ✔ kill › calling abort twice should show the same behaviour as calling it once (108ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (118ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.2s)
  ✔ kill › timeout does not kill the process if it does not time out (3s)
  ✔ kill › timedOut is false if timeout is undefined (3s)
  ✔ kill › timedOut is false if timeout is 0 (3s)
  ✔ kill › spawnAndExit (2.5s)
  ✔ kill › spawnAndExit cleanup (2.5s)
  ✔ kill › spawnAndExit detached (2.5s)
  ✔ kill › spawnAndExit cleanup detached (2.5s)
  ✔ kill › spawnAndKill SIGTERM (2.5s)
  ✔ kill › spawnAndKill SIGKILL (2.5s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.4s)
  ✔ kill › spawnAndKill detached SIGTERM (2.4s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.4s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.3s)
  ✔ kill › removes exit handler on exit (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.2s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (287ms)
  ✔ kill › error.isCanceled is true when cancel method is used (261ms)
  ✔ kill › error.isCanceled is false when kill method is used (250ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (243ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (231ms)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.5s)
  ✔ kill › spawnAndKill detached SIGKILL (2.4s)
  ✔ kill › timeout kills the process if it times out (3.2s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.4s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (251ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.3s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (283ms)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (102ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (255ms)
  ✔ node › node pass on nodeOptions (233ms)
  ✔ node › node pipe stdout (307ms)
  ✔ node › node's forked script has a communication channel (264ms)
  ✔ override-promise › should work with third-party Promise (125ms)
  ✔ promise › promise methods are not enumerable (117ms)
  ✔ promise › finally function is executed on failure (278ms)
  ✔ promise › finally function is executed on success (313ms)
  ✔ promise › throw in finally function bubbles up on success (311ms)
  ✔ promise › throw in finally bubbles up on error (277ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.2s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.2s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ test › execaSync() (1.8s)
  ✔ test › execaSync() throws error if written to stderr (1.7s)
  ✔ test › skip throwing when using reject option in sync mode (1.7s)
  ✔ test › stripFinalNewline in sync mode (1.5s)
  ✔ test › stripFinalNewline in sync mode on failure (1s)
  ✔ test › execa() returns a promise with pid (740ms)
  ✔ test › child_process.spawn() propagated errors have correct shape (720ms)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (625ms)
  ✔ test › child_process.spawn() errors are propagated (757ms)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (652ms)
  ✔ test › execa() rejects if running non-executable (694ms)
  ✔ test › preferLocal: undefined (1s)
  ✔ test › preferLocal: false (1s)
  ✔ test › child process errors rejects promise right away (911ms)
  ✔ test › child process errors are handled (968ms)
  ✔ test › stdin errors are handled (992ms)
  ✔ test › execa() (2.2s)
  ✔ test › skip throwing when using reject option (2s)
  ✔ test › stripFinalNewline: true (1.9s)
  ✔ test › stripFinalNewline: false (1.9s)
  ✔ test › stripFinalNewline on failure (1.9s)
  ✔ test › localDir option (1.1s)
  ✔ test › do not try to consume streams twice (936ms)
  ✔ test › use relative path with '..' chars (915ms)
  ✔ test › write to fast-exit process (813ms)
  ✔ test › localDir option can be a URL (676ms)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (513ms)
  ✔ test › use environment variables by default (800ms)
  ✔ test › extend environment variables by default (786ms)
  ✔ test › do not extend environment with `extendEnv: false` (770ms)
  ✔ test › can use `options.cwd` as a string (750ms)
  ✔ test › can use `options.cwd` as a URL (726ms)
  ✔ test › can use `options.shell: true` (742ms)
  ✔ test › can use `options.shell: string` (676ms)
  ✔ test › execPath option (1.4s)
  ✔ test › detach child process (980ms)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (2.4s)
  ✔ stream › input option can be a String - sync (1.9s)
  ✔ stream › input option can be a Buffer - sync (1.2s)
  ✔ stream › helpful error trying to provide an input stream in sync mode (459ms)
  ✔ stream › buffer (2.6s)
  ✔ stream › pass `stdout` to a file descriptor (2.6s)
  ✔ stream › pass `stderr` to a file descriptor (2.6s)
  ✔ stream › result.all is undefined unless opts.all is true (2.6s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.5s)
  ✔ stream › input option can be a String (2.1s)
  ✔ stream › input option can be a Buffer (2.1s)
  ✔ stream › input can be a Stream (2.1s)
  ✔ stream › you can write to child.stdin (2.1s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (812ms)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (926ms)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (891ms)
  ✔ stream › do not buffer when streaming (894ms)
  ✔ stream › buffer: false > promise resolves (888ms)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (883ms)
  ✔ stream › can use all: true with stdout: ignore (833ms)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1s)
  ✔ stream › can use all: true with stderr: ignore (833ms)
  ✔ stream › maxBuffer affects stdout (1.2s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1s)
  ✔ stream › maxBuffer affects stderr (1.2s)
  ✔ test › preferLocal: true (2.9s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./Variants/execa/variant4/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (1s)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.9s)
  ✔ error › result.killed is false if not killed, in sync mode (1.1s)
  ✔ error › result.killed is false on process error, in sync mode (280ms)
  ✔ error › Original error.message is kept (1.6s)
  ✔ error › error.code is defined on failure if applicable (129ms)
  ✔ error › result.killed is false on process error (438ms)
  ✔ error › stdout/stderr/all on process errors (2.1s)
  ✔ error › stdout/stderr/all available on errors (2.3s)
  ✔ error › exitCode is 0 on success (2.2s)
  ✔ error › exitCode is 2 (2.2s)
  ✔ error › exitCode is 3 (2.1s)
  ✔ error › exitCode is 4 (2.1s)
  ✔ error › error.message contains the command (2.1s)
  ✔ error › error.message contains stdout/stderr if available (2s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.9s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.9s)
  ✔ error › failed is false on success (1.8s)
  ✔ error › failed is true on failure (1.7s)
  ✔ error › error.killed is true if process was killed directly (1.7s)
  ✔ error › error.killed is false if process was killed indirectly (1.6s)
  ✔ error › result.killed is false if not killed (1.5s)
  ✔ error › error.signal is SIGINT (539ms)
  ✔ error › error.signalDescription is defined (510ms)
  ✔ error › error.signal is SIGTERM (498ms)
  ✔ error › exitCode is undefined on signal termination (438ms)
  ✔ error › custom error.signal (491ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (432ms)
  ✔ error › result.signalDescription is undefined for successful execution (475ms)
  ✔ error › error.code is undefined on success (463ms)
  ✔ error › result.signal is undefined for successful execution (569ms)
  ✔ command › allow commands with spaces and no array arguments (2.7s)
  ✔ command › allow commands with spaces and array arguments (2.7s)
  ✔ command › execaCommand() (2.6s)
  ✔ command › execaCommand() ignores consecutive spaces (2.6s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.5s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.5s)
  ✔ command › execaCommand() escapes other whitespaces (2.3s)
  ✔ command › execaCommand() trims (2.2s)
  ✔ command › command is: " foo bar" (2.9s)
  ✔ command › command is: " baz quz" (2.9s)
  ✔ command › command is: "" (2.9s)
  ✔ command › escapedCommand is: "foo bar" (3s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.2s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3.3s)
  ✔ command › escapedCommand is: "\"*\"" (3.8s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.1s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.1s)
  ✔ kill › execa() returns a promise with kill() (3.1s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.9s)
  ✔ kill › cancel method kills the subprocess (2.2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (911ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (3s)
  ✔ kill › timeout must not be negative (3s)
  ✔ kill › timeout must be an integer (3s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (141ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (179ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (199ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.3s)
  ✔ kill › timeout does not kill the process if it does not time out (3.2s)
  ✔ kill › timedOut is false if timeout is undefined (3.1s)
  ✔ kill › timedOut is false if timeout is 0 (3.1s)
  ✔ kill › spawnAndExit (2.6s)
  ✔ kill › spawnAndExit cleanup (2.6s)
  ✔ kill › spawnAndExit detached (2.6s)
  ✔ kill › spawnAndExit cleanup detached (2.6s)
  ✔ kill › spawnAndKill SIGTERM (2.6s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.4s)
  ✔ kill › removes exit handler on exit (2.4s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.3s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (378ms)
  ✔ kill › error.isCanceled is true when cancel method is used (347ms)
  ✔ kill › error.isCanceled is false when kill method is used (320ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (308ms)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (298ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (290ms)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.5s)
  ✔ kill › spawnAndKill detached SIGTERM (2.5s)
  ✔ kill › spawnAndKill detached SIGKILL (2.4s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.4s)
  ✔ kill › timeout kills the process if it times out (3.2s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.4s)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (261ms)
  ✔ kill › spawnAndKill SIGKILL (2.5s)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.4s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.5s)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (249ms)
  ✔ node › node's forked script has a communication channel (244ms)
  ✔ node › node pass on nodeOptions (276ms)
  ✔ node › node pipe stdout (312ms)
  ✔ override-promise › should work with third-party Promise (120ms)
  ✔ promise › promise methods are not enumerable
  ✔ promise › finally function is executed on failure (243ms)
  ✔ promise › finally function is executed on success (277ms)
  ✔ promise › throw in finally function bubbles up on success (274ms)
  ✔ promise › throw in finally bubbles up on error (250ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1.1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.3s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.3s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.9s)
  ✔ stream › input option can be a String - sync (1.3s)
  ✔ stream › input option can be a Buffer - sync (1s)
  ✔ stream › helpful error trying to provide an input stream in sync mode (742ms)
  ✔ stream › buffer (2.1s)
  ✔ stream › pass `stdout` to a file descriptor (2.2s)
  ✔ stream › pass `stderr` to a file descriptor (2.1s)
  ✔ stream › result.all is undefined unless opts.all is true (2.1s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.1s)
  ✔ stream › input option can be a String (1.7s)
  ✔ stream › you can write to child.stdin (1.6s)
  ✔ stream › input option can be a Buffer (1.7s)
  ✔ stream › input can be a Stream (1.7s)
  ✔ test › execaSync() (2.4s)
  ✔ test › execaSync() throws error if written to stderr (2.2s)
  ✔ test › skip throwing when using reject option in sync mode (2.2s)
  ✔ test › stripFinalNewline in sync mode (2s)
  ✔ test › stripFinalNewline in sync mode on failure (1.4s)
  ✔ test › execa() returns a promise with pid (1.1s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (1s)
  ✔ test › child_process.spawn() errors are propagated (1.2s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (1.3s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (1.2s)
  ✔ test › execa() rejects if running non-executable (1.3s)
  ✔ test › preferLocal: undefined (1.6s)
  ✔ test › preferLocal: false (1.6s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (1.3s)
  ✔ test › child process errors rejects promise right away (1.6s)
  ✔ test › child process errors are handled (1.6s)
  ✔ test › stdin errors are handled (1.6s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (1.4s)
  ✔ stream › buffer: false > promise resolves (1.3s)
  ✔ stream › do not buffer when streaming (1.4s)
  ✔ test › execa() (3.2s)
  ✔ test › skip throwing when using reject option (3s)
  ✔ test › stripFinalNewline: true (2.8s)
  ✔ test › stripFinalNewline: false (2.8s)
  ✔ test › stripFinalNewline on failure (2.7s)
  ✔ test › localDir option (1.9s)
  ✔ test › do not try to consume streams twice (1.8s)
  ✔ test › use relative path with '..' chars (1.7s)
  ✔ test › write to fast-exit process (1.6s)
  ✔ test › localDir option can be a URL (1.3s)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (1s)
  ✔ test › do not extend environment with `extendEnv: false` (1.4s)
  ✔ test › use environment variables by default (1.6s)
  ✔ test › can use `options.cwd` as a string (1.4s)
  ✔ test › extend environment variables by default (1.5s)
  ✔ test › can use `options.cwd` as a URL (1.3s)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1.6s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.5s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (1.4s)
  ✔ test › can use `options.shell: true` (1.4s)
  ✔ test › can use `options.shell: string` (1.3s)
  ✔ stream › can use all: true with stdout: ignore (1.4s)
  ✔ stream › maxBuffer affects stdout (2s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.6s)
  ✔ stream › can use all: true with stderr: ignore (1.4s)
  ✔ stream › maxBuffer affects stderr (2s)
  ✔ test › execPath option (2.3s)
  ✔ test › detach child process (1.4s)
  ✔ test › preferLocal: true (2.7s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./Variants/execa/variant3/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  ✔ command › execaCommandSync() (999ms)
  ✔ error › stdout/stderr/all on process errors, in sync mode (1.9s)
  ✔ error › result.killed is false if not killed, in sync mode (1.2s)
  ✔ error › result.killed is false on process error, in sync mode (179ms)
  ✔ error › Original error.message is kept (1.6s)
  ✔ error › error.code is defined on failure if applicable (116ms)
  ✔ error › result.killed is false on process error (316ms)
  ✔ error › stdout/stderr/all on process errors (2s)
  ✔ error › stdout/stderr/all available on errors (2.2s)
  ✔ error › exitCode is 0 on success (2.1s)
  ✔ error › exitCode is 2 (2s)
  ✔ error › exitCode is 3 (2s)
  ✔ error › exitCode is 4 (2s)
  ✔ error › error.message contains the command (2s)
  ✔ error › error.message contains stdout/stderr if available (1.9s)
  ✔ error › error.message does not contain stdout/stderr if not available (1.9s)
  ✔ error › error.shortMessage does not contain stdout/stderr (1.9s)
  ✔ error › failed is false on success (1.8s)
  ✔ error › failed is true on failure (1.7s)
  ✔ error › error.killed is true if process was killed directly (1.6s)
  ✔ error › error.killed is false if process was killed indirectly (1.6s)
  ✔ error › result.killed is false if not killed (1.5s)
  ✔ error › error.signal is SIGINT (399ms)
  ✔ error › error.signalDescription is defined (393ms)
  ✔ error › error.signal is SIGTERM (387ms)
  ✔ error › exitCode is undefined on signal termination (387ms)
  ✔ error › custom error.signal (396ms)
  ✔ error › result.signal is undefined if process failed, but was not killed (492ms)
  ✔ error › result.signal is undefined for successful execution (544ms)
  ✔ error › result.signalDescription is undefined for successful execution (495ms)
  ✔ error › error.code is undefined on success (516ms)
  ✔ command › allow commands with spaces and no array arguments (2.7s)
  ✔ command › allow commands with spaces and array arguments (2.7s)
  ✔ command › execaCommand() (2.6s)
  ✔ command › execaCommand() ignores consecutive spaces (2.5s)
  ✔ command › execaCommand() allows escaping spaces in commands (2.5s)
  ✔ command › execaCommand() allows escaping spaces in arguments (2.4s)
  ✔ command › execaCommand() escapes other whitespaces (2.3s)
  ✔ command › execaCommand() trims (2.2s)
  ✔ command › command is: " foo bar" (2.9s)
  ✔ command › command is: " baz quz" (2.9s)
  ✔ command › command is: "" (2.9s)
  ✔ command › escapedCommand is: "foo bar" (3s)
  ✔ command › escapedCommand is: "\"foo bar\"" (3.1s)
  ✔ command › escapedCommand is: "\"\\\"foo\\\"\"" (3.4s)
  ✔ command › escapedCommand is: "\"*\"" (3.7s)
  ✔ kill › `forceKillAfterTimeout` should not be NaN (3.1s)
  ✔ kill › `forceKillAfterTimeout` should not be negative (3.1s)
  ✔ kill › execa() returns a promise with kill() (3.1s)
  ✔ kill › timedOut is false if timeout is undefined and exit code is 0 in sync mode (2.8s)
  ✔ kill › cancel method kills the subprocess (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (success) (2.1s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called in sync mode (failure) (950ms)
  ✔ kill › timeout kills the process if it times out, in sync mode (3s)
  ✔ kill › timeout must not be negative (2.9s)
  ✔ kill › timeout must be an integer (2.9s)
  ✔ kill › calling abort after cancel should show the same behaviour as only calling cancel (105ms)
  ✔ kill › calling cancel after abort should show the same behaviour as only calling cancel (144ms)
  ✔ kill › calling abort twice should show the same behaviour as calling it once (189ms)
  ✔ kill › calling abort throws an error with message "Command was canceled" (217ms)
  ✔ kill › `forceKillAfterTimeout: false` should not kill after a timeout (3.3s)
  ✔ kill › timeout does not kill the process if it does not time out (3.1s)
  ✔ kill › timedOut is false if timeout is undefined (3.1s)
  ✔ kill › timedOut is false if timeout is 0 (3s)
  ✔ kill › spawnAndExit (2.6s)
  ✔ kill › spawnAndExit cleanup (2.5s)
  ✔ kill › spawnAndExit detached (2.5s)
  ✔ kill › spawnAndExit cleanup detached (2.5s)
  ✔ kill › spawnAndKill SIGTERM (2.5s)
  ✔ kill › spawnAndKill SIGKILL (2.5s)
  ✔ kill › spawnAndKill cleanup SIGKILL (2.5s)
  ✔ kill › spawnAndKill detached SIGTERM (2.5s)
  ✔ kill › spawnAndKill cleanup detached SIGKILL (2.4s)
  ✔ kill › removes exit handler on exit (2.4s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (success) (2.3s)
  ✔ kill › result.isCanceled is false when spawned.cancel() isn't called (failure) (2.3s)
  ✔ kill › calling cancel method throws an error with message "Command was canceled" (415ms)
  ✔ kill › error.isCanceled is true when cancel method is used (390ms)
  ✔ kill › error.isCanceled is false when kill method is used (366ms)
  ✔ kill › calling cancel method twice should show the same behaviour as calling it once (353ms)
  ✔ kill › calling cancel method on a process which has been killed does not make error.isCanceled true (326ms)
  ✔ kill › spawnAndKill detached SIGKILL (2.4s)
  ✔ kill › spawnAndKill cleanup detached SIGTERM (2.4s)
  ✔ kill › timeout kills the process if it times out (3.3s)
  ✔ kill › kill("SIGKILL") should terminate cleanly (3.4s)
  ✔ kill › calling cancel method on a successfully completed process does not make result.isCanceled true (360ms)
  ✔ kill › calling abort on a successfully completed process does not make result.isCanceled true (283ms)
  ✔ kill › `forceKillAfterTimeout: number` should kill after a timeout (3.4s)
  ✔ kill › spawnAndKill cleanup SIGTERM (2.5s)
  ✔ node › node removes --inspect from nodeOptions when defined by parent process (112ms)
  ✔ node › node removes --inspect=9222 from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk from nodeOptions when defined by parent process
  ✔ node › node removes --inspect-brk=9222 from nodeOptions when defined by parent process
  ✔ node › node should not remove --inspect when passed through nodeOptions
  ✔ node › node correctly use nodePath
  ✔ node › node() (240ms)
  ✔ node › node pass on nodeOptions (257ms)
  ✔ node › node pipe stdout (284ms)
  ✔ node › node's forked script has a communication channel (253ms)
  ✔ override-promise › should work with third-party Promise (114ms)
  ✔ promise › promise methods are not enumerable
  ✔ promise › throw in finally bubbles up on error (149ms)
  ✔ promise › finally function is executed on success (297ms)
  ✔ promise › finally function is executed on failure (297ms)
  ✔ promise › throw in finally function bubbles up on success (265ms)
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stream › result.all shows both `stdout` and `stderr` intermixed (1s)
  ✔ kill › `forceKillAfterTimeout: true` should kill after a timeout (8.3s)
  ✔ kill › kill() with no arguments should kill after a timeout (8.3s)
  ✔ stream › buffer: false > promise does not resolve when output is big and is not read (1s)
  ✔ stream › buffer: false > promise does not resolve when output is big and "all" is used but not read (1s)
  ✔ stream › stdout/stderr/all are undefined if ignored in sync mode (1.9s)
  ✔ stream › input option can be a String - sync (1.3s)
  ✔ stream › input option can be a Buffer - sync (1s)
  ✔ stream › helpful error trying to provide an input stream in sync mode (767ms)
  ✔ stream › buffer (2.2s)
  ✔ stream › pass `stdout` to a file descriptor (2.2s)
  ✔ stream › pass `stderr` to a file descriptor (2.1s)
  ✔ stream › result.all is undefined unless opts.all is true (2.1s)
  ✔ stream › stdout/stderr/all are undefined if ignored (2.1s)
  ✔ stream › you can write to child.stdin (1.6s)
  ✔ stream › input option can be a Buffer (1.6s)
  ✔ stream › input option can be a String (1.7s)
  ✔ stream › input can be a Stream (1.7s)
  ✔ stream › opts.stdout:ignore - stdout will not collect data (1.2s)
  ✔ stream › do not buffer stdout when `buffer` set to `false` (1.2s)
  ✔ test › execaSync() (2.6s)
  ✔ test › execaSync() throws error if written to stderr (2.5s)
  ✔ test › skip throwing when using reject option in sync mode (2.5s)
  ✔ test › stripFinalNewline in sync mode (2.3s)
  ✔ test › stripFinalNewline in sync mode on failure (1.7s)
  ✔ test › execa() returns a promise with pid (1.4s)
  ✔ test › child_process.spawn() propagated errors have correct shape (1.3s)
  ✔ test › child_process.spawnSync() errors are propagated with a correct shape (1.3s)
  ✔ test › child_process.spawn() errors are propagated (1.4s)
  ✔ stream › do not buffer stderr when `buffer` set to `false` (1.4s)
  ✔ stream › do not buffer when streaming (1.4s)
  ✔ test › execa() rejects with correct error and doesn't throw if running non-executable with input (1.4s)
  ✔ test › execa() rejects if running non-executable (1.5s)
  ✔ test › preferLocal: undefined (1.8s)
  ✔ test › preferLocal: false (1.8s)
  ✔ stream › buffer: false > promise resolves (1.4s)
  ✔ test › child process errors rejects promise right away (1.8s)
  ✔ test › child process errors are handled (1.8s)
  ✔ test › stdin errors are handled (1.9s)
  ✔ stream › buffer: false > promise resolves when output is big but is not pipable (1.5s)
  ✔ stream › buffer: false > promise rejects when process returns non-zero (1.4s)
  ✔ test › execa() (3.4s)
  ✔ test › skip throwing when using reject option (3.2s)
  ✔ test › stripFinalNewline: true (3.1s)
  ✔ test › stripFinalNewline: false (3.1s)
  ✔ test › stripFinalNewline on failure (3s)
  ✔ test › localDir option (2.1s)
  ✔ test › do not try to consume streams twice (1.9s)
  ✔ test › use relative path with '..' chars (1.9s)
  ✔ test › write to fast-exit process (1.7s)
  ✔ test › use environment variables by default (1.7s)
  ✔ test › localDir option can be a URL (1.3s)
  ✔ test › use extend environment with `extendEnv: true` and `shell: true` (966ms)
  ✔ test › do not extend environment with `extendEnv: false` (1.6s)
  ✔ test › extend environment variables by default (1.7s)
  ✔ test › can use `options.cwd` as a string (1.5s)
  ✔ test › can use `options.cwd` as a URL (1.3s)
  ✔ stream › buffer: false > promise resolves when output is big and is read (1.7s)
  ✔ stream › can use all: true with stdout: ignore (1.6s)
  ✔ stream › can use all: true with stderr: ignore (1.4s)
  ✔ stream › buffer: false > promise resolves when output is big and "all" is used and is read (1.7s)
  ✔ test › can use `options.shell: true` (1.3s)
  ✔ test › can use `options.shell: string` (1.2s)
  ✔ stream › maxBuffer affects stdout (2.2s)
  ✔ stream › maxBuffer affects stderr (2.1s)
  ✔ test › execPath option (2.6s)
  ✔ test › detach child process (1.3s)
  ✔ test › preferLocal: true (2.9s)
  ─

  209 tests passed
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
-------------|---------|----------|---------|---------|-------------------
All files    |   99.54 |    99.06 |     100 |   99.54 |                   
 execa       |   98.87 |    96.15 |     100 |   98.87 |                   
  index.js   |   98.87 |    96.15 |     100 |   98.87 | 55-57             
 execa/lib   |     100 |      100 |     100 |     100 |                   
  command.js |     100 |      100 |     100 |     100 |                   
  error.js   |     100 |      100 |     100 |     100 |                   
  kill.js    |     100 |      100 |     100 |     100 |                   
  promise.js |     100 |      100 |     100 |     100 |                   
  stdio.js   |     100 |      100 |     100 |     100 |                   
  stream.js  |     100 |      100 |     100 |     100 |                   
-------------|---------|----------|---------|---------|-------------------
./Variants/execa/variant2/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/error.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  Uncaught exception in test/command.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/error.js exited with a non-zero exit code: 1
  ✖ test/command.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/kill.js exited with a non-zero exit code: 1

  Uncaught exception in test/node.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  Uncaught exception in test/promise.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/promise.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }

  Uncaught exception in test/stream.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › <anonymous> (node_modules/get-node/src/archive/p7z.js:93:18)

  ✖ test/test.js exited with a non-zero exit code: 1

  ✖ Timed out while running tests

  ─

  36 tests passed
  8 uncaught exceptions
-------------|---------|----------|---------|---------|---------------------------------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                           
-------------|---------|----------|---------|---------|---------------------------------------------
All files    |   27.62 |      100 |    8.33 |   27.62 |                                             
 execa       |    13.1 |      100 |       0 |    13.1 |                                             
  index.js   |    13.1 |      100 |       0 |    13.1 | ...2,76-162,165-225,228-230,233-235,238-267 
 execa/lib   |   37.34 |      100 |   10.71 |   37.34 |                                             
  command.js |    43.9 |      100 |       0 |    43.9 | 2-6,13-17,28-40                             
  error.js   |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                  
  kill.js    |   36.27 |      100 |       0 |   36.27 | ...-29,38-46,51-55,59-60,65-80,84-86,91-101 
  promise.js |   36.11 |      100 |       0 |   36.11 | 9-18,23-35                                  
  stdio.js   |     100 |      100 |     100 |     100 |                                             
  stream.js  |   29.06 |      100 |       0 |   29.06 | 7-15,20-34,39-49,53-61,66-79,83-85          
-------------|---------|----------|---------|---------|---------------------------------------------
./Variants/execa/variant1/execa

> execa@6.1.0 test
> xo && c8 ava && tsd


  Uncaught exception in test/error.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  Uncaught exception in test/command.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/error.js exited with a non-zero exit code: 1
  ✖ test/command.js exited with a non-zero exit code: 1

  Uncaught exception in test/kill.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/kill.js exited with a non-zero exit code: 1

  Uncaught exception in test/node.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/node.js exited with a non-zero exit code: 1

  Uncaught exception in test/override-promise.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  Uncaught exception in test/promise.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/promise.js exited with a non-zero exit code: 1
  ✔ stdio › execa() undefined
  ✔ stdio › execa() null
  ✔ stdio › execa() { stdio: 'inherit' }
  ✔ stdio › execa() { stdio: 'pipe' }
  ✔ stdio › execa() { stdio: 'ignore' }
  ✔ stdio › execa() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execa() {}
  ✔ stdio › execa() { stdio: [] }
  ✔ stdio › execa() { stdin: 'pipe' }
  ✔ stdio › execa() { stdout: 'ignore' }
  ✔ stdio › execa() { stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 'pipe', stdout: 'ignore' }
  ✔ stdio › execa() { stdin: 'pipe', stderr: 'inherit' }
  ✔ stdio › execa() { stdout: 'ignore', stderr: 'inherit' }
  ✔ stdio › execa() { stdin: 0, stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdin: 0, stdout: 1 }
  ✔ stdio › execa() { stdin: 0, stderr: 2 }
  ✔ stdio › execa() { stdout: 1, stderr: 2 }
  ✔ stdio › execa() { stdio: { foo: 'bar' } }
  ✔ stdio › execa() { stdin: 'inherit', stdio: 'pipe' }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ 'pipe' ] }
  ✔ stdio › execa() { stdin: 'inherit', stdio: [ undefined, 'pipe' ] }
  ✔ stdio › execa() { stdin: 0, stdio: 'pipe' }
  ✔ stdio › execaNode() undefined
  ✔ stdio › execaNode() { stdio: 'ignore' }
  ✔ stdio › execaNode() { stdio: 'ipc' }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 3 ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, 'ipc' ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, undefined ] }
  ✔ stdio › execaNode() { stdio: [ 0, 1, 2, undefined ] }
  ✔ stdio › execaNode() { stdout: 'ignore' }
  ✔ stdio › execaNode() { stdout: 'ignore', stderr: 'ignore' }
  ✔ stdio › execaNode() { stdio: { foo: 'bar' } }
  ✔ stdio › execaNode() { stdin: 'inherit', stdio: 'pipe' }

  Uncaught exception in test/stream.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › file://test/helpers/fixtures-dir.js:6:25

  ✖ test/stream.js exited with a non-zero exit code: 1

  Uncaught exception in test/test.js

  ReferenceError: lyx is not defined

  › pathKey (file://node_modules/path-key/index.js:2:5)
  › <anonymous> (node_modules/get-node/src/archive/p7z.js:93:18)

  ✖ test/test.js exited with a non-zero exit code: 1

  ✖ Timed out while running tests

  ─

  36 tests passed
  8 uncaught exceptions
-------------|---------|----------|---------|---------|---------------------------------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s                           
-------------|---------|----------|---------|---------|---------------------------------------------
All files    |   27.62 |      100 |    8.33 |   27.62 |                                             
 execa       |    13.1 |      100 |       0 |    13.1 |                                             
  index.js   |    13.1 |      100 |       0 |    13.1 | ...2,76-162,165-225,228-230,233-235,238-267 
 execa/lib   |   37.34 |      100 |   10.71 |   37.34 |                                             
  command.js |    43.9 |      100 |       0 |    43.9 | 2-6,13-17,28-40                             
  error.js   |    8.23 |      100 |       0 |    8.23 | 4-24,28-84                                  
  kill.js    |   36.27 |      100 |       0 |   36.27 | ...-29,38-46,51-55,59-60,65-80,84-86,91-101 
  promise.js |   36.11 |      100 |       0 |   36.11 | 9-18,23-35                                  
  stdio.js   |     100 |      100 |     100 |     100 |                                             
  stream.js  |   29.06 |      100 |       0 |   29.06 | 7-15,20-34,39-49,53-61,66-79,83-85          
-------------|---------|----------|---------|---------|---------------------------------------------

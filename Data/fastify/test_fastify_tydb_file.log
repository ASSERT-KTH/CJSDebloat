/data/js-variants/multee
84
tydb is testing ./Variants/fastify/variant84/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 43 packages, and audited 337 packages in 5s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 860ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 391ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (239ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (431ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (330ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (245ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant83/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 883ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 398ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (245ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (413ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (329ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (237ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant82/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 841ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 402ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (302ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (364ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (367ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (242ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually (39ms)
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant81/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 884ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 391ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (239ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (425ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (334ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (243ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant80/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 3s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 879ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 418ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (292ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (402ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (404ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (236ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant79/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 871ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 407ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (362ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (434ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (315ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (235ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (203ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant78/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 853ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 398ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (260ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (408ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (331ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (235ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (308ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant77/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 836ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 442ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (283ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (385ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (324ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (238ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (308ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant76/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 841ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 390ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (294ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (487ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (330ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (233ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant75/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 909ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 401ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (241ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (404ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (342ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (243ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (206ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant74/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 867ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 399ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (243ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (445ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (406ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (237ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant73/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 861ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 410ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (307ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (404ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (328ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (241ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant72/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 858ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 391ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (241ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (416ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (370ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (235ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents (52ms)
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant71/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 6s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 843ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 572ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (240ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (393ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (282ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (239ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant70/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 929ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 444ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (282ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (381ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (316ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (236ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant69/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 839ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 394ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (238ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (434ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (352ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (239ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant68/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 888ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 388ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (243ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (417ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (515ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (240ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant67/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 868ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 404ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (246ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (440ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (340ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (233ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant66/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 826ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 395ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (246ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (398ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (354ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (240ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant65/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 855ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 417ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (398ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (407ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (361ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (240ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting (41ms)
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed (81ms)
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant64/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 848ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 402ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (241ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (454ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (322ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (237ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data (41ms)
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed (68ms)
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant63/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 855ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 395ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (241ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (415ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (356ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (234ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant62/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 851ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 408ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (289ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (390ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (385ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (236ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant61/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 877ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 394ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (240ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (405ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (335ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (241ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant60/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 899ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 407ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (240ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (397ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (332ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (238ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant59/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 875ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 384ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (246ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (436ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (291ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (240ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (203ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant58/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 6s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 846ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 412ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (248ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (524ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (393ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (239ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant57/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 840ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 413ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (239ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (451ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (347ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (240ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant56/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 847ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 398ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (241ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (469ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (337ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (237ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant55/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 841ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 399ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (335ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (439ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (330ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (234ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant54/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 886ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 411ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (240ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (397ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (357ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (238ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually (38ms)
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant53/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 887ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 401ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (315ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (415ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (350ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (241ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant52/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 845ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 389ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (239ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (399ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (332ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (241ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (102ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting (39ms)
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed (71ms)
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state (90ms)
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant51/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 840ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 430ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (308ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (406ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (329ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (236ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant50/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 854ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 446ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (238ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (432ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (307ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (238ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant49/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 832ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 424ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (302ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (413ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (359ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (237ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting (38ms)
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant48/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 866ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 418ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (242ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (423ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (391ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (233ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (102ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant47/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 897ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 405ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (266ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (428ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (273ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (237ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant46/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 856ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 411ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (350ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (425ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (308ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (238ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant45/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 6s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 836ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 528ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (292ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (427ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (344ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (236ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant44/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 836ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 424ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (355ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (449ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (323ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (237ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant43/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 842ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 411ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (239ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (420ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (356ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (240ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant42/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 879ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 395ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (417ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (402ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (350ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (235ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant41/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 901ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 415ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (292ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (439ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (302ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (234ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting (44ms)
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant40/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 868ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 395ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (264ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (368ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (322ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (237ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant39/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 852ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 393ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (239ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (470ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (361ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (239ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant38/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 834ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 446ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (378ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (408ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (350ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (234ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant37/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 841ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 387ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (500ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (430ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (349ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (240ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (305ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting (39ms)
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant36/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 857ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 406ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (260ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (437ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (339ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (248ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant35/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 849ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 391ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (237ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (415ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (343ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (235ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant34/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 857ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 392ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (286ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (391ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (369ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (253ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant33/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 890ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 422ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (253ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (370ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (290ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (242ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting (41ms)
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant32/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 5s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 860ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 401ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (304ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (431ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (376ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (240ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant31/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 883ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 392ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (258ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (413ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (325ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (239ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant30/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 845ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 402ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (241ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (412ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (328ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (241ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed (50ms)
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant29/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 834ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 423ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (261ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (380ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (361ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (236ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant28/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 881ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 402ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (247ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (440ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (351ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (235ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant27/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 889ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 393ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (238ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (403ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (396ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (232ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant26/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 873ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 402ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (242ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (441ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (310ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (237ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant25/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 842ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 400ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (283ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (460ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (449ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (236ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant24/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 843ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 387ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (284ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (452ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (309ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (239ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant23/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 844ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 393ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (237ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (430ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (387ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (237ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (106ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting (42ms)
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant22/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 872ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 403ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (313ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (408ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (297ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (233ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant21/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 938ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 398ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (324ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (411ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (340ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (238ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant20/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 888ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 392ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (291ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (448ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (354ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (238ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant19/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 4s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 863ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 392ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 3s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (269ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (432ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (344ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (238ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting (39ms)
      ✓ Deserialization hook is correctly used when loading data (40ms)
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed (43ms)
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant18/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 860ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 398ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (278ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (419ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (305ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (238ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant17/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 836ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 396ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (416ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (418ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (339ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (238ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant16/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 833ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 397ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (242ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (624ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (465ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (239ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss (42ms)
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting (77ms)
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant15/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 835ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 409ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (240ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (475ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (356ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (241ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (308ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant14/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 844ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 390ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (252ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (467ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (336ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (236ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant13/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 853ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 387ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (239ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (398ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (359ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (238ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (203ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting (97ms)
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant12/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 872ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 409ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (338ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (420ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (350ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (237ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually (38ms)
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant11/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 883ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 444ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (244ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (398ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (361ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (241ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting (53ms)
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant10/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 902ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 396ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (238ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (426ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (361ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (240ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (140ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant9/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 897ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 394ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (241ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (463ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (333ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (234ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant8/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 882ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 405ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (237ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (398ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (342ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (238ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant7/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 861ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 400ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (320ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (398ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (338ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (238ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting (40ms)
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant6/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 6s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 838ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 407ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (296ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (454ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (398ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (241ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (203ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant5/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 870ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 402ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (240ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (524ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (284ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted (62ms)
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (238ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant4/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 874ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 423ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (242ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (419ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (387ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (235ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (203ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant3/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 830ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 402ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (261ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (414ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (346ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (234ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant2/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 825ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 419ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (284ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (432ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (320ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (239ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./Variants/fastify/variant1/fastify
/data/js-variants/multee
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 835ms

found 0 vulnerabilities
************* npm unlink globally done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 406ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (256ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (415ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (351ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (238ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
variantsDepsNum: 14
/data/js-variants/multee
14
tydb is testing ./VariantsDeps/fastify/variant14/fastify
************* npm unlink module *************

removed 1 package, and audited 337 packages in 5s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 880ms

found 0 vulnerabilities
************* npm unlink module done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 400ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (238ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (471ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (408ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (240ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (203ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename (58ms)
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile (38ms)
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./VariantsDeps/fastify/variant13/fastify
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 893ms

found 0 vulnerabilities
************* npm unlink module done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 407ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (239ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (371ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (301ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (243ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./VariantsDeps/fastify/variant12/fastify
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 878ms

found 0 vulnerabilities
************* npm unlink module done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 424ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (241ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (397ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (322ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (237ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./VariantsDeps/fastify/variant11/fastify
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 903ms

found 0 vulnerabilities
************* npm unlink module done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 411ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (331ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (408ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (356ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (239ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./VariantsDeps/fastify/variant10/fastify
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 844ms

found 0 vulnerabilities
************* npm unlink module done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 452ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (238ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (417ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (382ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (244ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (202ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./VariantsDeps/fastify/variant9/fastify
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 844ms

found 0 vulnerabilities
************* npm unlink module done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 432ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (271ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (435ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (295ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (242ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./VariantsDeps/fastify/variant8/fastify
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 843ms

found 0 vulnerabilities
************* npm unlink module done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 413ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (344ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (491ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (339ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (239ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (308ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./VariantsDeps/fastify/variant7/fastify
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 833ms

found 0 vulnerabilities
************* npm unlink module done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 401ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (238ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (393ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (399ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (240ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./VariantsDeps/fastify/variant6/fastify
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 919ms

found 0 vulnerabilities
************* npm unlink module done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 395ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (301ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (442ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (386ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (234ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (205ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./VariantsDeps/fastify/variant5/fastify
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 893ms

found 0 vulnerabilities
************* npm unlink module done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 401ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (245ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (455ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (372ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (243ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement (41ms)
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents (45ms)
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./VariantsDeps/fastify/variant4/fastify
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 879ms

found 0 vulnerabilities
************* npm unlink module done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 404ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (293ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (435ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (413ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (240ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (203ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (103ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./VariantsDeps/fastify/variant3/fastify
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 921ms

found 0 vulnerabilities
************* npm unlink module done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 403ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (241ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (443ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (338ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (242ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (307ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./VariantsDeps/fastify/variant2/fastify
************* npm unlink module *************

removed 1 package, and audited 337 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 934ms

found 0 vulnerabilities
************* npm unlink module done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 410ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (241ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (408ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (320ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (244ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (204ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (7s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
tydb is testing ./VariantsDeps/fastify/variant1/fastify
************* npm unlink module *************

removed 1 package, and audited 337 packages in 5s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm unlink module done *************
************* npm unlink globally *************

removed 1 package, and audited 1 package in 842ms

found 0 vulnerabilities
************* npm unlink module done *************
************* npm link globally *************

added 1 package, and audited 3 packages in 397ms

found 0 vulnerabilities
************* npm link globally done *************
************* npm link module *************

added 1 package, and audited 339 packages in 2s

29 packages are looking for funding
  run `npm fund` for details

15 vulnerabilities (4 moderate, 10 high, 1 critical)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
************* npm link module done *************
************* start run test *************

> tydb@0.1.5 test
> mocha



  AVL tree
    ✓ Can use undefined as key and value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Checking that all nodes heights are correct
      ✓ Calculate the balance factor
      ✓ Can check that a tree is balanced
    Insertion
      ✓ The root has a height of 1
      ✓ Insert at the root if its the first insertion
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Auto-balancing insertions
      ✓ Can insert a lot of keys and still get an AVLT (sanity check) (240ms)
    Search
      ✓ Can find data in an AVLT
      ✓ If no data can be found, return an empty array
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
      ✓ Removing falsy values does not delete the entire key
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (578ms)

  Binary search tree
    ✓ Upon creation, left, right are null, key and data can be set
    ✓ Can use undefined as key but not value
    ✓ Can use null as key and value
    Sanity checks
      ✓ Can get maxkey and minkey descendants
      ✓ Can check a condition against every node in a tree
      ✓ Can check that a tree verifies node ordering
      ✓ Checking if a tree's internal pointers (i.e. parents) are correct
      ✓ Can get the number of inserted keys
    Insertion
      ✓ Insert at the root if its the first insertion
      ✓ Insert on the left if key is less than the root's
      ✓ Insert on the right if key is greater than the root's
      ✓ Recursive insertion on the left works
      ✓ Recursive insertion on the right works
      ✓ If uniqueness constraint not enforced, we can insert different data for same key
      ✓ If uniqueness constraint is enforced, we cannot insert different data for same key
      ✓ Can insert 0 or the empty string
      ✓ Can insert a lot of keys and still get a BST (sanity check)
      ✓ All children get a pointer to their parent, the root doesnt
    Search
      ✓ Can find data in a BST
      ✓ If no data can be found, return an empty array
      ✓ Can find ascending ordered data in a BST
      ✓ Can find descending ordered data in a BST
      ✓ Can find nearest key in a BST
      ✓ Can find nearest key greater than search key in a BST
      ✓ Can find nearest key less than search key in a BST
      ✓ Can find nearest key with two equal keys in BST
      ✓ Can search for data between two bounds
      ✓ Bounded search can handle cases where query contains both $lt and $lte, or both $gt and $gte
      ✓ Bounded search can work when one or both boundaries are missing
    Deletion
      ✓ Deletion does nothing on an empty tree
      ✓ Deleting a non-existent key doesnt have any effect
      ✓ Able to delete the root if it is also a leaf
      ✓ Able to delete leaf nodes that are non-root
      ✓ Able to delete the root if it has only one child
      ✓ Able to delete non root nodes that have only one child
      ✓ Can delete the root if it has 2 children
      ✓ Can delete a non-root node that has two children
      ✓ If no value is provided, it will delete the entire node even if there are multiple pieces of data
      ✓ Can remove only one value from an array
      ✓ Removes nothing if value doesnt match
      ✓ If value provided but node contains only one value, remove entire node
      ✓ Can remove the root from a tree with height 2 when the root has two children (special case)
      ✓ Can remove the root from a tree with height 3 when the root has two children (special case where the two children themselves have children)
    Execute on every node (=tree traversal)
      ✓ Can execute a function on every node
    Randomized test (takes much longer than the rest of the test suite)
      ✓ Inserting and deleting entire nodes (343ms)

  Cursor
    Without sorting
      ✓ Without query, an empty query or a simple query and no skip or limit
      ✓ With an empty collection
      ✓ With a limit
      ✓ With a skip
      ✓ With a limit and a skip and method chaining
    Sorting of the results
      ✓ Using one sort
      ✓ With an empty collection
      ✓ Ability to chain sorting and exec
      ✓ Using limit and sort
      ✓ Using a limit higher than total number of docs shouldnt cause an error
      ✓ Using limit and skip with sort
      ✓ Using too big a limit and a skip with sort
      ✓ Using too big a skip with sort should return no result
      ✓ Sorting strings
      ✓ Sorting nested fields with dates
      ✓ Sorting when some fields are undefined
      ✓ Sorting when all fields are undefined
      ✓ Multiple consecutive sorts
      ✓ Similar data, multiple consecutive sorts
    Projections
      ✓ Takes all results if no projection or empty object given
      ✓ Can take only the expected fields
      ✓ Can omit only the expected fields
      ✓ Cannot use both modes except for _id
      ✓ Projections on embedded documents - omit type
      ✓ Projections on embedded documents - pick type

  customUtils
    uid
      ✓ Generated uids should not be the same
      ✓ Generated random strings should not be the same

  Database
    Insert
      ✓ Able to insert a document in the database, setting an _id if none provided, and retrieve it even after a reload
      ✓ Can insert multiple documents in the database
      ✓ Can insert and get back from DB complex objects with all primitive and secondary types
      ✓ If an object returned from the DB is modified and refetched, the original value should be found
      ✓ Cannot insert a doc that has a field beginning with a $ sign
      ✓ If an _id is already given when we insert a document, use that instead of generating a random one
      ✓ Modifying the insertedDoc after an insert doesnt change the copy saved in the database
      ✓ Can insert an array of documents at once
      ✓ If a bulk insert violates a constraint, all changes are rolled back
      ✓ CreatedAt field is added and persisted
      ✓ If createdAt is specified by user, don't change it
      ✓ If updatedAt is specified by user, don't change it
      ✓ Can insert a doc with id 0
    #getCandidates
      ✓ Can use an index to get docs with a basic match
      ✓ Can use an index to get docs with a $in match
      ✓ Can use an index to get docs with a $eq match
      ✓ If no index can be used, return the whole database
      ✓ Can use indexes for comparison matches
      ✓ Can set a TTL index that expires documents (241ms)
      ✓ TTL indexes can expire multiple documents and only what needs to be expired (306ms)
      ✓ Document where indexed field is absent or not a date are ignored (203ms)
    Find
      ✓ Can find all documents if an empty query is used
      ✓ Can find all documents matching a basic query
      ✓ Can find dates and objects (non JS-native types)
      ✓ Can use dot-notation to query subfields
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
      ✓ Changing the documents returned by find or findOne do not change the database state
    Count
      ✓ Count all documents if an empty query is used
      ✓ Count all documents matching a basic query
      ✓ Array fields match if any element matches
      ✓ Returns an error if the query is not well formed
    Update
      ✓ If the query doesn't match anything, database is not modified
      ✓ Update the updatedAt field (104ms)
      ✓ Can update multiple documents matching the query
      ✓ Cannot perform update if the update query is not either registered-modifiers-only or copy-only, or contain badly formatted fields
      ✓ Can update documents using multiple modifiers
      ✓ CUpserting using $setOnInsert
      ✓ When using modifiers, the only way to update subdocs is with the dot-notation
      ✓ Returns an error if the query is not well formed
      ✓ If an error is thrown by a modifier, the database state is not changed
      ✓ Cant change the _id of a document
      ✓ Non-multi updates are persistent
      ✓ Multi updates are persistent
      ✓ If a multi update fails on one document, previous updates should be rolled back
      ✓ If an index constraint is violated by an update, all changes should be rolled back
      ✓ return all updated docs
      ✓ createdAt property is unchanged and updatedAt correct after an update, even a complete document replacement
      Upserts
        ✓ Can perform upserts if needed
        ✓ If the update query is a normal object with no modifiers, it is the doc that will be upserted
        ✓ If the update query contains modifiers, it is applied to the object resulting from removing all operators from the find query 1
        ✓ Performing upsert without $setOnInsert yields a standard error not an exception
    Remove
      ✓ Can remove multiple documents
      ✓ Remove can be called multiple times in parallel and everything that needs to be removed will be
      ✓ Returns an error if the query is not well formed
      ✓ Non-multi removes are persistent
      ✓ Multi removes are persistent
    Using indexes
      ✓ Results of getMatching should never contain duplicates
      ensureIndex and index initialization in database loading
        ✓ ensureIndex can be called right after a loadDatabase and be initialized and filled correctly
        ✓ ensureIndex can be called twice on the same field, the second call will ahve no effect
        ✓ ensureIndex can be called after the data set was modified and the index still be correct
        ✓ ensureIndex can be called before a loadDatabase and still be initialized and filled correctly
        ✓ Can initialize multiple indexes on a database load
        ✓ If a unique constraint is not respected, database loading will throw but the valid data will be still be usable
        ✓ If a unique constraint is not respected, ensureIndex will return an error and not create an index
        ✓ Can remove an index
      Indexing newly inserted documents
        ✓ Newly inserted documents are indexed
        ✓ If multiple indexes are defined, the document is inserted in all of them
        ✓ Can insert two docs at the same key for a non unique index
        ✓ If the index has a unique constraint, an error is thrown if it is violated and the data is not modified
        ✓ If an index has a unique constraint, other indexes cannot be modified when it raises an error
        ✓ Unique indexes prevent you from inserting two docs where the field is undefined except if theyre sparse
        ✓ Insertion still works as before with indexing
        ✓ All indexes point to the same data as the main index on _id
        ✓ If a unique constraint is violated, no index is changed, including the main one
      Updating indexes upon document update
        ✓ Updating docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is updated
        ✓ If a simple update violates a contraint, all changes are rolled back and an error is thrown
        ✓ If a multi update violates a contraint, all changes are rolled back and an error is thrown
      Updating indexes upon document remove
        ✓ Removing docs still works as before with indexing
        ✓ Indexes get updated when a document (or multiple documents) is removed
      Persisting indexes
        1) Indexes are persisted to a separate file and recreated upon reload
        2) Indexes are persisted with their options and recreated even if some db operation happen between loads
        3) Indexes can also be removed and the remove persisted

  Indexes
    ✓ Get all elements in the index
    Insertion
      ✓ Can insert pointers to documents in the index correctly when they have the field
      ✓ Inserting twice for the same fieldName in a unique index will result in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique index results in an error thrown
      ✓ Inserting twice for a fieldName the docs dont have with a unique and sparse index will not throw, since the docs will be non indexed
      ✓ Works with dot notation
      ✓ Can insert an array of documents
      ✓ When inserting an array of elements, if an error is thrown all inserts need to be rolled back
      Array fields
        ✓ Inserts one entry per array element in the index
        ✓ Inserts one entry per array element in the index, type-checked
        ✓ Inserts one entry per unique array element in the index, the unique constraint only holds across documents
        ✓ The unique constraint holds across documents
        ✓ When removing a document, remove it from the index at all unique array elements
        ✓ If a unique constraint is violated when inserting an array key, roll back all inserts before the key
    Removal
      ✓ Can remove pointers from the index, even when multiple documents have the same key
      ✓ If we have a sparse index, removing a non indexed doc has no effect
      ✓ Works with dot notation
      ✓ Can remove an array of documents
    Update
      ✓ Can update a document whose key did or didnt change
      ✓ If a simple update violates a unique constraint, changes are rolled back and an error thrown
      ✓ Can update an array of documents
      ✓ If a unique constraint is violated during an array-update, all changes are rolled back and an error thrown
      ✓ If an update doesnt change a document, the unique constraint is not violated
      ✓ Can revert simple and batch updates
    Get matching documents
      ✓ Get all documents where fieldName is equal to the given value, or an empty array if no match
      ✓ Can get all documents for a given key in a unique index
      ✓ Can get all documents for which a field is undefined
      ✓ Can get all documents for which a field is null
      ✓ Can get all documents for a given key in a sparse index, but not unindexed docs (= field undefined)
      ✓ Can get all documents whose key is in an array of keys
      ✓ Can get all documents whose key is between certain bounds
    Resetting
      ✓ Can reset an index without any new data, the index will be empty afterwards
      ✓ Can reset an index and initialize it with one document
      ✓ Can reset an index and initialize it with an array of documents

  Model
    Serialization, deserialization
      ✓ Can serialize and deserialize strings
      ✓ Can serialize and deserialize booleans
      ✓ Can serialize and deserialize numbers
      ✓ Can serialize and deserialize null
      ✓ undefined fields are removed when serialized
      ✓ Can serialize and deserialize a date
      ✓ Can serialize and deserialize sub objects
      ✓ Can serialize and deserialize sub arrays
      ✓ Reject field names beginning with a $ sign or containing a dot, except the four edge cases
      ✓ Can serialize string fields with a new line without breaking the DB
      ✓ Can accept objects whose keys are numbers
    Object checking
      ✓ Field names beginning with a $ sign are forbidden
      ✓ Field names cannot contain a .
      ✓ Properties with a null value dont trigger an error
      ✓ Can check if an object is a primitive or not
    Deep copying
      ✓ Should be able to deep copy any serializable model
      ✓ Should deep copy the contents of an array
      ✓ Without the strictKeys option, everything gets deep copied
      ✓ With the strictKeys option, only valid keys gets deep copied
    Modifying documents
      ✓ Queries not containing any modifier just replace the document by the contents of the query but keep its _id
      ✓ Throw an error if trying to change the _id field in a copy-type modification
      ✓ Throw an error if trying to use modify in a mixed copy+modify way
      ✓ Throw an error if trying to use an inexistent modifier
      ✓ Throw an error if a modifier is used with a non-object argument
      $set modifier
        ✓ Can change already set fields without modfifying the underlying object
        ✓ Creates fields to set if they dont exist yet
        ✓ Can set sub-fields and create them if necessary
        ✓ Doesn't replace a falsy field by an object when recursively following dot notation
      $unset modifier
        ✓ Can delete a field, not throwing an error if the field doesnt exist
        ✓ Can unset sub-fields and entire nested documents
        ✓ When unsetting nested fields, should not create an empty parent to nested field
      $inc modifier
        ✓ Throw an error if you try to use it with a non-number or on a non number field
        ✓ Can increment number fields or create and initialize them if needed
        ✓ Works recursively
      $push modifier
        ✓ Can push an element to the end of an array
        ✓ Can push an element to a non-existent field and will create the array
        ✓ Can push on nested fields
        ✓ Throw if we try to push to a non-array
        ✓ Can use the $each modifier to add multiple values to an array at once
        ✓ Can use the $slice modifier to limit the number of array elements
      $addToSet modifier
        ✓ Can add an element to a set
        ✓ Can add an element to a non-existent set and will create the array
        ✓ Throw if we try to addToSet to a non-array
        ✓ Use deep-equality to check whether we can add a value to a set
        ✓ Can use the $each modifier to add multiple values to a set at once
      $pop modifier
        ✓ Throw if called on a non array, a non defined field or a non integer
        ✓ Can remove the first and last element of an array
      $pull modifier
        ✓ Can remove an element from a set
        ✓ Can remove multiple matching elements
        ✓ Throw if we try to pull from a non-array
        ✓ Use deep-equality to check whether we can remove a value from a set
        ✓ Can use any kind of nedb query with $pull
      $max modifier
        ✓ Will set the field to the updated value if value is greater than current one, without modifying the original object
        ✓ Will not update the field if new value is smaller than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
      $min modifier
        ✓ Will set the field to the updated value if value is smaller than current one, without modifying the original object
        ✓ Will not update the field if new value is greater than current one
        ✓ Will create the field if it does not exist
        ✓ Works on embedded documents
    Comparing things
      ✓ undefined is the smallest
      ✓ Then null
      ✓ Then numbers
      ✓ Then strings
      ✓ Then booleans
      ✓ Then dates
      ✓ Then arrays
      ✓ And finally objects
      ✓ Can specify custom string comparison function
    Querying
      Comparing things
        ✓ Two things of different types cannot be equal, two identical native things are equal
        ✓ Can test native types null undefined string number boolean date equality
        ✓ If one side is an array or undefined, comparison fails
        ✓ Can test objects equality
      Getting a fields value in dot notation
        ✓ Return first-level and nested values
        ✓ Return undefined if the field cannot be found in the object
        ✓ Can navigate inside arrays with dot notation, and return the array of values in that case
        ✓ Can get a single value out of an array using its index
      Field equality
        ✓ Can find documents with simple fields
        ✓ Can find documents with the dot-notation
        ✓ Cannot find undefined
        ✓ Nested objects are deep-equality matched and not treated as sub-queries
        ✓ Can match for field equality inside an array with the dot notation
      Regular expression matching
        ✓ Matching a non-string to a regular expression always yields false
        ✓ Can match strings using basic querying
        ✓ Can match strings using the $regex operator
        ✓ Will throw if $regex operator is used with a non regex value
        ✓ Can use the $regex operator in cunjunction with other operators
        ✓ Can use dot-notation
      $lt
        ✓ Cannot compare a field to an object, an array, null or a boolean, it will return false
        ✓ Can compare numbers, with or without dot notation
        ✓ Can compare strings, with or without dot notation
        ✓ If field is an array field, a match means a match on at least one element
        ✓ Works with dates too
      Other comparison operators: $lte, $gt, $gte, $ne, $in, $exists
        ✓ $lte
        ✓ $gt
        ✓ $gte
        ✓ $ne
        ✓ $in
        ✓ $nin
        ✓ $exists
      Comparing on arrays
        ✓ Can perform a direct array match
        ✓ Can query on the size of an array field
        ✓ $size operator works with empty arrays
        ✓ Should throw an error if a query operator is used without comparing to an integer
        ✓ Using $size operator on a non-array field should prevent match but not throw
        ✓ Can use $size several times in the same matcher
        ✓ Can query array documents with multiple simultaneous conditions
        ✓ $elemMatch operator works with empty arrays
        ✓ Can use more complex comparisons inside nested query documents
      Logical operators $or, $and, $not
        ✓ Any of the subqueries should match for an $or to match
        ✓ All of the subqueries should match for an $and to match
        ✓ Subquery should not match for a $not to match
        ✓ Logical operators are all top-level, only other logical operators can be above
        ✓ Logical operators can be combined as long as they are on top of the decision tree
        ✓ Should throw an error if a logical operator is used without an array or if an unknown logical operator is used
      Comparison operator $where
        ✓ Function should match and not match correctly
        ✓ Should throw an error if the $where function is not, in fact, a function
        ✓ Should throw an error if the $where function returns a non-boolean
        ✓ Should be able to do the complex matching it must be used for
      Array fields
        ✓ Field equality
        ✓ With one comparison operator
        ✓ Works with arrays that are in subdocuments
        ✓ Can query inside arrays thanks to dot notation
        ✓ Can query for a specific element inside arrays thanks to dot notation
        ✓ A single array-specific operator and the query is treated as array specific
        ✓ Can mix queries on array fields and non array filds with array specific operators

  Persistence
    ✓ Every line represents a document
    ✓ Badly formatted lines have no impact on the treated data
    ✓ Well formatted lines that have no _id are not included in the data
    ✓ If two lines concern the same doc (= same _id), the last one is the good version
    ✓ If a doc contains $$deleted: true, that means we need to remove it from the data
    ✓ If a doc contains $$deleted: true, no error is thrown if the doc wasnt in the list before
    ✓ If a doc contains $$indexCreated, no error is thrown during treatRawData and we can get the index options
    ✓ Compact database manually
    ✓ Calling loadDatabase after the data was modified doesnt change its contents
    ✓ Calling loadDatabase after the datafile was removed will reset the database
    ✓ Calling loadDatabase after the datafile was modified loads the new data
    ✓ When treating raw data, refuse to proceed if too much data is corrupt, to avoid data loss
    Serialization hooks
      ✓ Declaring only one hook will throw an exception to prevent data loss
      ✓ Declaring two hooks that are not reverse of one another will cause an exception to prevent data loss
      ✓ A serialization hook can be used to transform data before writing new state to disk
      ✓ Use serialization hook when persisting cached database or compacting
      ✓ Deserialization hook is correctly used when loading data
    Prevent dataloss when persisting data
      ✓ Creating a persistent datastore with a bad filename will cause an error
      ✓ If no file exists, ensureDataFileIntegrity creates an empty datafile
      ✓ If only datafile exists, ensureDataFileIntegrity will use it
      ✓ If temp datafile exists and datafile doesnt, ensureDataFileIntegrity will use it (cannot happen except upon first use)
      ✓ If both temp and current datafiles exist, ensureDataFileIntegrity will use the datafile, as it means that the write of the temp file failed
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state
      ✓ After a persistCachedDatabase, there should be no temp or old filename
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ persistCachedDatabase should update the contents of the datafile and leave a clean state even if there is a temp datafile
      ✓ Persistence works as expected when everything goes fine
Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

    at ChildProcess.exithandler (node:child_process:387:12)
    at ChildProcess.emit (node:events:527:28)
    at maybeClose (node:internal/child_process:1090:16)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5) {
  code: 1,
  killed: false,
  signal: null,
  cmd: 'ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts'
}
      4) Cannot cause EMFILE errors by opening too many file descriptors
    ensureFileDoesntExist
      ✓ Doesnt do anything if file already doesnt exist
      ✓ Deletes file if it exists
    Dealing with large databases
      - Loading the database
      - Writing the database

  Actions
    Connection
      ✓ Connection with an object param
      ✓ Connection with an already created DB
    Operations
      Creating
        ✓ Basic creation
        ✓ Creating while giving an ID
        ✓ Creating multiple in single call
        ✓ Test signature
        ✓ Modeling
      Read
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ limiting
        ✓ skipping
        ✓ projecting
        ✓ deep projecting
        ✓ sorting
        ✓ deep sorting
        Modeling
          ✓ Is in fact an instance of the model
          ✓ Methods exists
          ✓ filter by getter
          ✓ sort by getter
          ✓ projecting a getter
          ✓ run function
      Update
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ Multi update
        ✓ Test signature & modeling
      Upserting
        ✓ When the document is found
        ✓ When the document is not found
      Counting
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
      Delete
        ✓ Basic filter
        ✓ Deep filter
        ✓ with no filter
        ✓ multi delete

  External (through the network) instance
    Creating
      5) "before each" hook for "Basic creation"

  Operators tests
    Query Selectors
      Comparison
        ✓ $eq
        ✓ $ne
        ✓ $gt
        ✓ $lt
        ✓ $gte
        ✓ $lte
        ✓ $in
        ✓ $nin
      Element
        ✓ $exists
        ✓ $type
      Evaluation
        ✓ $mod
        ✓ $regex
        ✓ $where
      Array
        ✓ $all
        ✓ $elemMatch
        ✓ $size
      Logical
        ✓ $and
        ✓ $nor
        ✓ $not
        ✓ $or
    Update Operators
      Field update operators
        ✓ $currentDate
        ✓ $inc
        ✓ $mul
        ✓ $min
        ✓ $max
        ✓ $rename
        ✓ $set
        ✓ $unset
        ✓ $setOnInsert
      Array update operators
        ✓ $addToSet
        ✓ $pop
        ✓ $pull
        ✓ $pull $eq
        ✓ $pullAll
        ✓ $push
        ✓ $push $each
        ✓ $push $each $position
        ✓ $push $each $slice
        ✓ $push $each $sort
        variations on the sort mechanism
          ✓ $push $each $sort 1
          ✓ $push $each $sort 2
          ✓ $push $each $sort 3
          ✓ $push $each $sort 4


  455 passing (6s)
  2 pending
  5 failing

  1) Database
       Using indexes
         Persisting indexes
           Indexes are persisted to a separate file and recreated upon reload:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2798:8)
      at processImmediate (node:internal/timers:471:21)

  2) Database
       Using indexes
         Persisting indexes
           Indexes are persisted with their options and recreated even if some db operation happen between loads:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:2888:8)
      at processImmediate (node:internal/timers:471:21)

  3) Database
       Using indexes
         Persisting indexes
           Indexes can also be removed and the remove persisted:
     Error: ENOENT: no such file or directory, unlink 'workspace/persistIndexes.db'
      at Object.unlinkSync (node:fs:1771:3)
      at Context.<anonymous> (test/core/db.test.ts:3050:8)
      at processImmediate (node:internal/timers:471:21)

  4) Persistence
       Prevent dataloss when persisting data
         Cannot cause EMFILE errors by opening too many file descriptors:
     Error: Command failed: ulimit -n 128 && ts-node test/core/test_lac/openFds.test.ts
Error: EMFILE: too many open files, open './test/core/test_lac/openFdsTestFile'

      at ChildProcess.exithandler (node:child_process:387:12)
      at ChildProcess.emit (node:events:527:28)
      at maybeClose (node:internal/child_process:1090:16)
      at Process.ChildProcess._handle.onexit (node:internal/child_process:302:5)

  5) External (through the network) instance
       "before each" hook for "Basic creation":
     FetchError: request to http://localhost:3000/mydb/reload failed, reason: connect ECONNREFUSED 127.0.0.1:3000
      at ClientRequest.<anonymous> (node_modules/node-fetch/lib/index.js:1455:11)
      at ClientRequest.emit (node:events:527:28)
      at Socket.socketErrorListener (node:_http_client:462:9)
      at Socket.emit (node:events:527:28)
      at emitErrorNT (node:internal/streams/destroy:151:8)
      at emitErrorCloseNT (node:internal/streams/destroy:116:3)
      at processTicksAndRejections (node:internal/process/task_queues:82:21)



************* run test done *************
